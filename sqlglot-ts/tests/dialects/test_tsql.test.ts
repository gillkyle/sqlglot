// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "tsql";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Tsql: tsql", () => {
  it(" -> tsql: WITH x AS (SELECT 1) SELECT * FROM x UNION SELECT * FROM x ORDER BY 1 LIMIT 0", () => {
    const result = transpile("WITH x AS (SELECT 1) SELECT * FROM x UNION SELECT * FROM x ORDER BY 1 LIMIT 0", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH x AS (SELECT 1 AS [1]) SELECT TOP 0 * FROM (SELECT * FROM x UNION SELECT * FROM x) AS _l_0 ORDER BY 1");
  });
  it("SELECT * FROM a..b", () => {
    validateIdentity("SELECT * FROM a..b");
  });
  it("SELECT ATN2(x, y)", () => {
    validateIdentity("SELECT ATN2(x, y)");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it("SELECT SYSDATETIMEOFFSET()", () => {
    validateIdentity("SELECT SYSDATETIMEOFFSET()");
  });
  it("SELECT COMPRESS('Hello World')", () => {
    validateIdentity("SELECT COMPRESS('Hello World')");
  });
  it.todo("GO (assert_is check)");
  it.todo("CREATE view a.b.c (DDL/DML not supported)");
  it.todo("DROP view a.b.c (DDL/DML not supported)");
  it("ROUND(x, 1, 0)", () => {
    validateIdentity("ROUND(x, 1, 0)");
  });
  it("EXEC MyProc @id = 7, @name = 'Lochristi' -> EXECUTE MyProc @id = 7, @name = 'Lochristi'", () => {
    validateIdentity("EXEC MyProc @id = 7, @name = 'Lochristi'", "EXECUTE MyProc @id = 7, @name = 'Lochristi'");
  });
  it("SELECT TRIM('     test    ') AS Result", () => {
    validateIdentity("SELECT TRIM('     test    ') AS Result");
  });
  it.todo("SELECT TRIM('.,! ' FROM '     #     test    .') AS Result (unsupported syntax)");
  it.todo("SELECT * FROM t TABLESAMPLE (10 PERCENT) (unsupported clause)");
  it.todo("SELECT * FROM t TABLESAMPLE (20 ROWS) (unsupported clause)");
  it.todo("SELECT * FROM t TABLESAMPLE (10 PERCENT) REPEATABLE (123) (unsupported clause)");
  it("SELECT CONCAT(column1, column2)", () => {
    validateIdentity("SELECT CONCAT(column1, column2)");
  });
  it("SELECT TestSpecialChar.Test# FROM TestSpecialChar", () => {
    validateIdentity("SELECT TestSpecialChar.Test# FROM TestSpecialChar");
  });
  it("SELECT TestSpecialChar.Test@ FROM TestSpecialChar", () => {
    validateIdentity("SELECT TestSpecialChar.Test@ FROM TestSpecialChar");
  });
  it("SELECT TestSpecialChar.Test$ FROM TestSpecialChar", () => {
    validateIdentity("SELECT TestSpecialChar.Test$ FROM TestSpecialChar");
  });
  it("SELECT TestSpecialChar.Test_ FROM TestSpecialChar", () => {
    validateIdentity("SELECT TestSpecialChar.Test_ FROM TestSpecialChar");
  });
  it("SELECT TOP (2 + 1) 1", () => {
    validateIdentity("SELECT TOP (2 + 1) 1");
  });
  it("SELECT * FROM t WHERE NOT c -> SELECT * FROM t WHERE NOT c <> 0", () => {
    validateIdentity("SELECT * FROM t WHERE NOT c", "SELECT * FROM t WHERE NOT c <> 0");
  });
  it("1 AND true -> 1 <> 0 AND (1 = 1)", () => {
    validateIdentity("1 AND true", "1 <> 0 AND (1 = 1)");
  });
  it("CAST(x AS int) OR y -> CAST(x AS INTEGER) <> 0 OR y <> 0", () => {
    validateIdentity("CAST(x AS int) OR y", "CAST(x AS INTEGER) <> 0 OR y <> 0");
  });
  it.todo("TRUNCATE TABLE t1 WITH (PARTITIONS(1, 2 TO 5, 10 TO 20, 84)) (DDL/DML not supported)");
  it("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT TOP 10 a FROM t1 UNION ALL SEL...", () => {
    validateIdentity("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT TOP 10 a FROM t1 UNION ALL SELECT TOP 10 a FROM t2");
  });
  it("SELECT TOP 10 s.RECORDID, n.c.VALUE('(/*:FORM_ROOT/*:SOME_TAG)[1]', 'float') AS SOME_TA...", () => {
    validateIdentity("SELECT TOP 10 s.RECORDID, n.c.VALUE('(/*:FORM_ROOT/*:SOME_TAG)[1]', 'float') AS SOME_TAG_VALUE FROM source_table.dbo.source_data AS s(nolock) CROSS APPLY FormContent.nodes('/*:FORM_ROOT') AS N(C)");
  });
  it.todo("CREATE CLUSTERED INDEX [IX_OfficeTagDetail_TagDetailID] ON [dbo].[O... (DDL/DML not supported)");
  it.todo("CREATE INDEX [x] ON [y]([z] ASC) WITH (allow_page_locks=on) ON X([y]) (DDL/DML not supported)");
  it.todo("CREATE INDEX [x] ON [y]([z] ASC) WITH (allow_page_locks=on) ON PRIMARY (DDL/DML not supported)");
  it.todo("COPY INTO test_1 FROM 'path' WITH (FORMAT_NAME = test, FILE_TYPE = ... (command not supported)");
  it("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT TOP 10 a FROM t1 UNION ALL SEL... (2)", () => {
    validateIdentity("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT TOP 10 a FROM t1 UNION ALL SELECT TOP 10 a FROM t2 ORDER BY a DESC");
  });
  it("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT COUNT(*) FROM (SELECT TOP 10 a...", () => {
    validateIdentity("WITH t1 AS (SELECT 1 AS a), t2 AS (SELECT 1 AS a) SELECT COUNT(*) FROM (SELECT TOP 10 a FROM t1 UNION ALL SELECT TOP 10 a FROM t2 ORDER BY a DESC) AS t");
  });
  it('SELECT 1 AS "[x]" -> SELECT 1 AS [[x]]]', () => {
    validateIdentity('SELECT 1 AS "[x]"', "SELECT 1 AS [[x]]]");
  });
  it.todo("INSERT INTO foo.bar WITH cte AS (SELECT 1 AS one) SELECT * FROM cte (DDL/DML not supported)");
  it.todo("test_tsql: assertEqual call");
  it.todo("CREATE TABLE test_table([ID] [BIGINT] NOT NULL,[EffectiveFrom] [DAT... (DDL/DML not supported)");
  it.todo("SELECT CONVERT(DATETIME, '2006-04-25T15:50:59.997', 126) (unsupported syntax)");
  it.todo("WITH A AS (SELECT 2 AS value), C AS (SELECT * FROM A) SELECT * INTO... (DDL/DML in read/write)");
  it("spark -> tsql: SELECT IF(cond, 'True', 'False')", () => {
    const result = transpile("SELECT IF(cond, 'True', 'False')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT IIF(cond <> 0, 'True', 'False')");
  });
  it.todo("sqlite -> tsql: SELECT IIF(cond, 'True', 'False') (cross-dialect transform)");
  it("tsql -> tsql: SELECT IIF(cond <> 0, 'True', 'False')", () => {
    const result = transpile("SELECT IIF(cond <> 0, 'True', 'False')", { readDialect: "tsql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT IIF(cond <> 0, 'True', 'False')");
  });
  it.todo("SELECT TRIM(BOTH 'a' FROM a) (unsupported syntax)");
  it("duckdb -> tsql: SELECT MAKE_TIME(23, 59, 59)", () => {
    const result = transpile("SELECT MAKE_TIME(23, 59, 59)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)");
  });
  it("mysql -> tsql: SELECT MAKETIME(23, 59, 59)", () => {
    const result = transpile("SELECT MAKETIME(23, 59, 59)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)");
  });
  it("postgres -> tsql: SELECT MAKE_TIME(23, 59, 59)", () => {
    const result = transpile("SELECT MAKE_TIME(23, 59, 59)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)");
  });
  it.todo("snowflake -> tsql: SELECT TIME_FROM_PARTS(23, 59, 59) (cross-dialect transform)");
  it("tsql -> tsql: SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)", () => {
    const result = transpile("SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT TIMEFROMPARTS(23, 59, 59, 0, 0)");
  });
  it("snowflake -> tsql: SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321)", () => {
    const result = transpile("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0)");
  });
  it.todo("tsql -> duckdb: SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0) (cross-dialect transform)");
  it.todo("tsql -> snowflake: SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0)", () => {
    const result = transpile("SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATETIMEFROMPARTS(2013, 4, 5, 12, 00, 00, 0)");
  });
  it(" -> tsql: SELECT x FROM t1 UNION ALL SELECT x FROM t2 LIMIT 1", () => {
    const result = transpile("SELECT x FROM t1 UNION ALL SELECT x FROM t2 LIMIT 1", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TOP 1 * FROM (SELECT x FROM t1 UNION ALL SELECT x FROM t2) AS _l_0");
  });
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO foo FROM (SELECT c AS c FROM ... (DDL/DML in read/write)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO foo FROM (SELECT c AS c FROM ... (DDL/DML in read/write) (2)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO UNLOGGED #foo FROM (SELECT c ... (unsupported syntax)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT c INTO #foo FROM t (DDL/DML in read/write)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO UNLOGGED foo FROM (SELECT c A... (unsupported syntax)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO UNLOGGED foo FROM (SELECT c A... (unsupported syntax) (2)");
  it("tsql -> duckdb: WITH y AS (SELECT 2 AS c) INSERT INTO #t SELECT * FROM y", () => {
    const result = transpile("WITH y AS (SELECT 2 AS c) INSERT INTO #t SELECT * FROM y", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("WITH y AS (SELECT 2 AS c) INSERT INTO t SELECT * FROM y");
  });
  it("tsql -> postgres: WITH y AS (SELECT 2 AS c) INSERT INTO #t SELECT * FROM y", () => {
    const result = transpile("WITH y AS (SELECT 2 AS c) INSERT INTO #t SELECT * FROM y", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("WITH y AS (SELECT 2 AS c) INSERT INTO t SELECT * FROM y");
  });
  it("duckdb -> tsql: WITH y AS (SELECT 2 AS c) INSERT INTO t SELECT * FROM y", () => {
    const result = transpile("WITH y AS (SELECT 2 AS c) INSERT INTO t SELECT * FROM y", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH y AS (SELECT 2 AS c) INSERT INTO t SELECT * FROM y");
  });
  it("duckdb -> tsql: SELECT 1 AS c UNION (WITH t(c) AS (SELECT 1) SELECT c FROM t)", () => {
    const result = transpile("SELECT 1 AS c UNION (WITH t(c) AS (SELECT 1) SELECT c FROM t)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH t(c) AS (SELECT 1) SELECT 1 AS c UNION (SELECT c FROM t)");
  });
  it.todo("WITH t(c) AS (SELECT 1) MERGE INTO x AS z USING (SELECT c AS c FROM... (DDL/DML in read/write)");
  it.todo("duckdb -> tsql: SELECT * FROM (WITH RECURSIVE t(n) AS (SELECT 1 AS n UNION ALL SELECT n... (unsupported syntax)");
  it.todo("CREATE TABLE #mytemptable (a INTEGER) (DDL/DML not supported)");
  it.todo("CREATE TABLE #mytemp (a INTEGER, b CHAR(2), c TIME(4), d FLOAT(24)) (DDL/DML not supported)");
  it.todo("CREATE TABLE [dbo].[mytable](\n                [email] [varchar](255... (DDL/DML not supported)");
  it.todo("CREATE TABLE x ( A INTEGER NOT NULL, B INTEGER NULL ) (DDL/DML not supported)");
  it.todo('CREATE TABLE x (CONSTRAINT "pk_mytable" UNIQUE NONCLUSTERED (a DESC... (DDL/DML not supported)');
  it.todo("CREATE TABLE x ([zip_cd] VARCHAR(5) NULL NOT FOR REPLICATION, [zip_... (DDL/DML not supported)");
  it.todo("CREATE TABLE x (A INTEGER NOT NULL, B INTEGER NULL) (DDL/DML not supported)");
  it.todo("CREATE TABLE x ( A INTEGER NOT NULL, B INTEGER NULL ) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE tbl (a AS (x + 1) PERSISTED, b AS (y + 2), c AS (y / 3... (DDL/DML not supported)");
  it.todo("CREATE TABLE [db].[tbl]([a] [int]) (DDL/DML not supported)");
  it.todo("IF OBJECT_ID('tempdb.dbo.#TempTableName', 'U') IS NOT NULL BEGIN DR... (DDL/DML in read/write)");
  it.todo("IF OBJECT_ID('tempdb.dbo.#TempTableName') IS NOT NULL BEGIN DROP TA... (DDL/DML in read/write)");
  it.todo("MERGE INTO mytable WITH (HOLDLOCK) AS T USING mytable_merge AS S ON... (DDL/DML not supported)");
  it.todo("UPDATE STATISTICS x (check_command_warning)");
  it.todo("UPDATE x SET y = 1 OUTPUT x.a, x.b INTO @y FROM y (DDL/DML not supported)");
  it.todo("UPDATE x SET y = 1 OUTPUT x.a, x.b FROM y (DDL/DML not supported)");
  it.todo("INSERT INTO x (y) OUTPUT x.a, x.b INTO l SELECT * FROM z (DDL/DML not supported)");
  it.todo("INSERT INTO x (y) OUTPUT x.a, x.b SELECT * FROM z (DDL/DML not supported)");
  it.todo("DELETE x OUTPUT x.a FROM z (DDL/DML not supported)");
  it("SELECT * FROM t WITH (TABLOCK, INDEX(myindex))", () => {
    validateIdentity("SELECT * FROM t WITH (TABLOCK, INDEX(myindex))");
  });
  it("SELECT * FROM t WITH (NOWAIT)", () => {
    validateIdentity("SELECT * FROM t WITH (NOWAIT)");
  });
  it("SELECT CASE WHEN a > 1 THEN b END", () => {
    validateIdentity("SELECT CASE WHEN a > 1 THEN b END");
  });
  it.todo("SELECT * FROM taxi ORDER BY 1 OFFSET 0 ROWS FETCH NEXT 3 ROWS ONLY (unsupported clause)");
  it("END", () => {
    validateIdentity("END");
  });
  it("@x", () => {
    validateIdentity("@x");
  });
  it("#x", () => {
    validateIdentity("#x");
  });
  it.todo("PRINT @TestVariable (check_command_warning)");
  it("SELECT Employee_ID, Department_ID FROM @MyTableVar", () => {
    validateIdentity("SELECT Employee_ID, Department_ID FROM @MyTableVar");
  });
  it.todo("INSERT INTO @TestTable VALUES (1, 'Value1', 12, 20) (DDL/DML not supported)");
  it("SELECT * FROM #foo", () => {
    validateIdentity("SELECT * FROM #foo");
  });
  it("SELECT * FROM ##foo", () => {
    validateIdentity("SELECT * FROM ##foo");
  });
  it("SELECT a = 1 -> SELECT 1 AS a", () => {
    validateIdentity("SELECT a = 1", "SELECT 1 AS a");
  });
  it.todo("DECLARE @TestVariable AS VARCHAR(100) = 'Save Our Planet' (command not supported)");
  it("SELECT a = 1 UNION ALL SELECT a = b -> SELECT 1 AS a UNION ALL SELECT b AS a", () => {
    validateIdentity("SELECT a = 1 UNION ALL SELECT a = b", "SELECT 1 AS a UNION ALL SELECT b AS a");
  });
  it("SELECT x FROM @MyTableVar AS m JOIN Employee ON m.EmployeeID = Employee.EmployeeID", () => {
    validateIdentity("SELECT x FROM @MyTableVar AS m JOIN Employee ON m.EmployeeID = Employee.EmployeeID");
  });
  it.todo("SELECT DISTINCT DepartmentName, PERCENTILE_CONT(0.5) WITHIN GROUP (... (unsupported clause)");
  it('SELECT "x"."y" FROM foo -> SELECT [x].[y] FROM foo', () => {
    validateIdentity('SELECT "x"."y" FROM foo', "SELECT [x].[y] FROM foo");
  });
  it("postgres -> tsql: SELECT * FROM t OFFSET 2", () => {
    const result = transpile("SELECT * FROM t OFFSET 2", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 2 ROWS");
  });
  it.todo("tsql -> postgres: SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 2 ROWS (unsupported syntax)");
  it("tsql -> tsql: SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 2 ROWS", () => {
    const result = transpile("SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 2 ROWS", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 2 ROWS");
  });
  it.todo("SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 5 ROWS FETCH FIRST 10... (unsupported clause)");
  it("tsql -> tsql: SELECT CAST([a].[b] AS SMALLINT) FROM foo", () => {
    const result = transpile("SELECT CAST([a].[b] AS SMALLINT) FROM foo", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT CAST([a].[b] AS SMALLINT) FROM foo");
  });
  it("tsql -> spark: SELECT CAST([a].[b] AS SMALLINT) FROM foo", () => {
    const result = transpile("SELECT CAST([a].[b] AS SMALLINT) FROM foo", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST(`a`.`b` AS SMALLINT) FROM foo");
  });
  it.todo("CONVERT(INT, CONVERT(NUMERIC, '444.75')) (unsupported syntax)");
  it.todo("STRING_AGG(x, y) WITHIN GROUP (ORDER BY z DESC) (unsupported clause)");
  it.todo("STRING_AGG(x, '|') WITHIN GROUP (ORDER BY z ASC) (unsupported clause)");
  it.todo("STRING_AGG(x, '|') (unsupported syntax)");
  it.todo("snowflake -> tsql: SHA1(x) (cross-dialect transform)");
  it.todo("spark -> tsql: SHA(x) (cross-dialect transform)");
  it.todo("tsql -> snowflake: HASHBYTES('SHA1', x) (cross-dialect transform)");
  it.todo("tsql -> spark: HASHBYTES('SHA1', x) (cross-dialect transform)");
  it("tsql -> tsql: HASHBYTES('SHA1', x)", () => {
    const result = transpile("HASHBYTES('SHA1', x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("HASHBYTES('SHA1', x)");
  });
  it("spark -> tsql: SHA2(x, 256)", () => {
    const result = transpile("SHA2(x, 256)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("HASHBYTES('SHA2_256', x)");
  });
  it("tsql -> tsql: HASHBYTES('SHA2_256', x)", () => {
    const result = transpile("HASHBYTES('SHA2_256', x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("HASHBYTES('SHA2_256', x)");
  });
  it.todo("tsql -> spark: HASHBYTES('SHA2_256', x) (cross-dialect transform)");
  it("spark -> tsql: SHA2(x, 512)", () => {
    const result = transpile("SHA2(x, 512)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("HASHBYTES('SHA2_512', x)");
  });
  it("tsql -> tsql: HASHBYTES('SHA2_512', x)", () => {
    const result = transpile("HASHBYTES('SHA2_512', x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("HASHBYTES('SHA2_512', x)");
  });
  it.todo("tsql -> spark: HASHBYTES('SHA2_512', x) (cross-dialect transform)");
  it.todo("spark -> tsql: MD5('x') (cross-dialect transform)");
  it("tsql -> tsql: HASHBYTES('MD5', 'x')", () => {
    const result = transpile("HASHBYTES('MD5', 'x')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("HASHBYTES('MD5', 'x')");
  });
  it.todo("tsql -> spark: HASHBYTES('MD5', 'x') (cross-dialect transform)");
  it("HASHBYTES('MD2', 'x')", () => {
    validateIdentity("HASHBYTES('MD2', 'x')");
  });
  it("LOG(n)", () => {
    validateIdentity("LOG(n)");
  });
  it("LOG(n, b)", () => {
    validateIdentity("LOG(n, b)");
  });
  it.todo(" -> tsql: STDDEV(x) (cross-dialect transform)");
  it.todo("tsql -> : STDEV(x) (cross-dialect transform)");
  it("tsql -> tsql: STDEV(x)", () => {
    const result = transpile("STDEV(x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("STDEV(x)");
  });
  it.todo("SELECT val FROM (VALUES ((TRUE), (FALSE), (NULL))) AS t(val) (unsupported syntax)");
  it("'a' + 'b'", () => {
    validateIdentity("'a' + 'b'");
  });
  it.todo("'a' || 'b' (unsupported syntax)");
  it.todo("CREATE TABLE db.t1 (a INTEGER, b VARCHAR(50), CONSTRAINT c PRIMARY ... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.t1 (a INTEGER, b INTEGER, CONSTRAINT c PRIMARY KEY ... (DDL/DML not supported)");
  it.todo("tsql -> sqlite: SCHEMA_NAME(id) (unsupported syntax)");
  it.todo("tsql -> mysql: SCHEMA_NAME(id) (cross-dialect transform)");
  it.todo("tsql -> postgres: SCHEMA_NAME(id) (unsupported syntax)");
  it("tsql -> tsql: SCHEMA_NAME(id)", () => {
    const result = transpile("SCHEMA_NAME(id)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SCHEMA_NAME(id)");
  });
  it.todo("CREATE PROCEDURE test(@v1 INTEGER = 1, @v2 CHAR(1) = 'c') (DDL/DML not supported)");
  it.todo("DECLARE @v1 AS INTEGER = 1, @v2 AS CHAR(1) = 'c' (command not supported)");
  it.todo("CREATE PROCEDURE test(@v1 INTEGER = 1 OUT, @v2 CHAR(1) OUT) (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE test(@v1 INTEGER = 1 OUTPUT, @v2 CHAR(1) OUTPUT) (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE test(@v1 INTEGER = 1 READONLY, @v2 CHAR(1) READONLY) (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE test(@v1 AS INTEGER = 1, @v2 AS CHAR(1) = 'c') (DDL/DML not supported)");
  it("JSON_ARRAYAGG(c)", () => {
    validateIdentity("JSON_ARRAYAGG(c)");
  });
  it("JSON_ARRAYAGG(c NULL ON NULL)", () => {
    validateIdentity("JSON_ARRAYAGG(c NULL ON NULL)");
  });
  it("JSON_ARRAYAGG(c ABSENT ON NULL)", () => {
    validateIdentity("JSON_ARRAYAGG(c ABSENT ON NULL)");
  });
  it("JSON_ARRAYAGG(c ORDER BY c)", () => {
    validateIdentity("JSON_ARRAYAGG(c ORDER BY c)");
  });
  it("JSON_ARRAYAGG(c ORDER BY c NULL ON NULL)", () => {
    validateIdentity("JSON_ARRAYAGG(c ORDER BY c NULL ON NULL)");
  });
  it("JSON_ARRAYAGG(c ORDER BY c ABSENT ON NULL)", () => {
    validateIdentity("JSON_ARRAYAGG(c ORDER BY c ABSENT ON NULL)");
  });
  it("tsql -> tsql: JSON_ARRAYAGG(c1 ORDER BY c1)", () => {
    const result = transpile("JSON_ARRAYAGG(c1 ORDER BY c1)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("JSON_ARRAYAGG(c1 ORDER BY c1)");
  });
  it.todo("tsql -> postgres: JSON_ARRAYAGG(c1 ORDER BY c1) (unsupported syntax)");
  it("CEILING(2)", () => {
    validateIdentity("CEILING(2)");
  });
  it("OBJECT_ID('foo')", () => {
    validateIdentity("OBJECT_ID('foo')");
  });
  it("OBJECT_ID('foo', 'U')", () => {
    validateIdentity("OBJECT_ID('foo', 'U')");
  });
});

describe("Tsql: option", () => {
  it.todo("test_option: unresolvable for-loop iterable");
  it.todo("test_option: unresolvable for-loop iterable (2)");
  it.todo("SELECT col FROM t OPTION(LABEL = 'foo') (UnsupportedError in write)");
});

describe("Tsql: for_xml", () => {
  it.todo("test_for_xml: unresolvable for-loop iterable");
  it.todo("SELECT * FROM t FOR XML PATH, BINARY BASE64, ELEMENTS XSINIL (pretty=True not supported)");
});

describe("Tsql: types", () => {
  it("CAST(x AS XML)", () => {
    validateIdentity("CAST(x AS XML)");
  });
  it("CAST(x AS UNIQUEIDENTIFIER)", () => {
    validateIdentity("CAST(x AS UNIQUEIDENTIFIER)");
  });
  it("CAST(x AS MONEY)", () => {
    validateIdentity("CAST(x AS MONEY)");
  });
  it("CAST(x AS SMALLMONEY)", () => {
    validateIdentity("CAST(x AS SMALLMONEY)");
  });
  it("CAST(x AS IMAGE)", () => {
    validateIdentity("CAST(x AS IMAGE)");
  });
  it("CAST(x AS SQL_VARIANT)", () => {
    validateIdentity("CAST(x AS SQL_VARIANT)");
  });
  it("CAST(x AS BIT)", () => {
    validateIdentity("CAST(x AS BIT)");
  });
  it.todo("tsql -> hive: CAST(x AS DATETIME2(6)) (unsupported syntax)");
  it.todo("tsql -> tsql: CAST(x AS TIMESTAMP) (unsupported syntax)");
  it("tsql -> tsql: CAST(x AS ROWVERSION)", () => {
    const result = transpile("CAST(x AS ROWVERSION)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS ROWVERSION)");
  });
  it("tsql -> hive: CAST(x AS ROWVERSION)", () => {
    const result = transpile("CAST(x AS ROWVERSION)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(x AS BINARY)");
  });
  it(" -> tsql: CAST(x AS SMALLDATETIME)", () => {
    const result = transpile("CAST(x AS SMALLDATETIME)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS SMALLDATETIME)");
  });
  it("tsql -> mysql: CAST(x AS SMALLDATETIME)", () => {
    const result = transpile("CAST(x AS SMALLDATETIME)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS DATETIME)");
  });
  it.todo("tsql -> duckdb: CAST(x AS SMALLDATETIME) (unsupported syntax)");
  it("tsql -> tsql: CAST(x AS SMALLDATETIME)", () => {
    const result = transpile("CAST(x AS SMALLDATETIME)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS SMALLDATETIME)");
  });
  it(" -> tsql: CAST(x AS DATETIME)", () => {
    const result = transpile("CAST(x AS DATETIME)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS DATETIME)");
  });
  it("tsql -> mysql: CAST(x AS DATETIME)", () => {
    const result = transpile("CAST(x AS DATETIME)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS DATETIME)");
  });
  it.todo("tsql -> duckdb: CAST(x AS DATETIME) (unsupported syntax)");
  it("tsql -> tsql: CAST(x AS DATETIME)", () => {
    const result = transpile("CAST(x AS DATETIME)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATETIME)");
  });
  it(" -> tsql: CAST(x AS DATETIME2)", () => {
    const result = transpile("CAST(x AS DATETIME2)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS DATETIME2)");
  });
  it("tsql -> mysql: CAST(x AS DATETIME2)", () => {
    const result = transpile("CAST(x AS DATETIME2)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS DATETIME)");
  });
  it.todo("tsql -> duckdb: CAST(x AS DATETIME2) (unsupported syntax)");
  it("tsql -> tsql: CAST(x AS DATETIME2)", () => {
    const result = transpile("CAST(x AS DATETIME2)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATETIME2)");
  });
});

describe("Tsql: types_ints", () => {
  it("tsql -> hive: CAST(X AS INT)", () => {
    const result = transpile("CAST(X AS INT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(X AS INT)");
  });
  it("tsql -> spark2: CAST(X AS INT)", () => {
    const result = transpile("CAST(X AS INT)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("CAST(X AS INT)");
  });
  it("tsql -> spark: CAST(X AS INT)", () => {
    const result = transpile("CAST(X AS INT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(X AS INT)");
  });
  it("tsql -> tsql: CAST(X AS INT)", () => {
    const result = transpile("CAST(X AS INT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(X AS INTEGER)");
  });
  it("tsql -> hive: CAST(X AS BIGINT)", () => {
    const result = transpile("CAST(X AS BIGINT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(X AS BIGINT)");
  });
  it("tsql -> spark2: CAST(X AS BIGINT)", () => {
    const result = transpile("CAST(X AS BIGINT)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("CAST(X AS BIGINT)");
  });
  it("tsql -> spark: CAST(X AS BIGINT)", () => {
    const result = transpile("CAST(X AS BIGINT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(X AS BIGINT)");
  });
  it("tsql -> tsql: CAST(X AS BIGINT)", () => {
    const result = transpile("CAST(X AS BIGINT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(X AS BIGINT)");
  });
  it("tsql -> hive: CAST(X AS SMALLINT)", () => {
    const result = transpile("CAST(X AS SMALLINT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> spark2: CAST(X AS SMALLINT)", () => {
    const result = transpile("CAST(X AS SMALLINT)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> spark: CAST(X AS SMALLINT)", () => {
    const result = transpile("CAST(X AS SMALLINT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> tsql: CAST(X AS SMALLINT)", () => {
    const result = transpile("CAST(X AS SMALLINT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("duckdb -> tsql: CAST(X AS UTINYINT)", () => {
    const result = transpile("CAST(X AS UTINYINT)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(X AS TINYINT)");
  });
  it("tsql -> duckdb: CAST(X AS TINYINT)", () => {
    const result = transpile("CAST(X AS TINYINT)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(X AS UTINYINT)");
  });
  it("tsql -> hive: CAST(X AS TINYINT)", () => {
    const result = transpile("CAST(X AS TINYINT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> spark2: CAST(X AS TINYINT)", () => {
    const result = transpile("CAST(X AS TINYINT)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> spark: CAST(X AS TINYINT)", () => {
    const result = transpile("CAST(X AS TINYINT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(X AS SMALLINT)");
  });
  it("tsql -> tsql: CAST(X AS TINYINT)", () => {
    const result = transpile("CAST(X AS TINYINT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(X AS TINYINT)");
  });
});

describe("Tsql: types_decimals", () => {
  it("tsql -> spark: CAST(x as FLOAT)", () => {
    const result = transpile("CAST(x as FLOAT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS FLOAT)");
  });
  it("tsql -> tsql: CAST(x as FLOAT)", () => {
    const result = transpile("CAST(x as FLOAT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT)");
  });
  it("tsql -> tsql: CAST(x as FLOAT(32))", () => {
    const result = transpile("CAST(x as FLOAT(32))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT(32))");
  });
  it.todo("tsql -> hive: CAST(x as FLOAT(32)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as FLOAT(64))", () => {
    const result = transpile("CAST(x as FLOAT(64))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT(64))");
  });
  it.todo("tsql -> spark: CAST(x as FLOAT(64)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as FLOAT(6))", () => {
    const result = transpile("CAST(x as FLOAT(6))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT(6))");
  });
  it.todo("tsql -> hive: CAST(x as FLOAT(6)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as FLOAT(36))", () => {
    const result = transpile("CAST(x as FLOAT(36))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT(36))");
  });
  it.todo("tsql -> hive: CAST(x as FLOAT(36)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as FLOAT(99))", () => {
    const result = transpile("CAST(x as FLOAT(99))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT(99))");
  });
  it.todo("tsql -> hive: CAST(x as FLOAT(99)) (cross-dialect transform)");
  it("tsql -> spark: CAST(x as DOUBLE)", () => {
    const result = transpile("CAST(x as DOUBLE)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("tsql -> tsql: CAST(x as DOUBLE)", () => {
    const result = transpile("CAST(x as DOUBLE)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT)");
  });
  it("tsql -> spark: CAST(x as DECIMAL(15, 4))", () => {
    const result = transpile("CAST(x as DECIMAL(15, 4))", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(15, 4))");
  });
  it("tsql -> tsql: CAST(x as DECIMAL(15, 4))", () => {
    const result = transpile("CAST(x as DECIMAL(15, 4))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS NUMERIC(15, 4))");
  });
  it("tsql -> spark: CAST(x as NUMERIC(13,3))", () => {
    const result = transpile("CAST(x as NUMERIC(13,3))", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(13, 3))");
  });
  it("tsql -> tsql: CAST(x as NUMERIC(13,3))", () => {
    const result = transpile("CAST(x as NUMERIC(13,3))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS NUMERIC(13, 3))");
  });
  it("tsql -> spark: CAST(x as MONEY)", () => {
    const result = transpile("CAST(x as MONEY)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(15, 4))");
  });
  it("tsql -> tsql: CAST(x as MONEY)", () => {
    const result = transpile("CAST(x as MONEY)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS MONEY)");
  });
  it("tsql -> spark: CAST(x as SMALLMONEY)", () => {
    const result = transpile("CAST(x as SMALLMONEY)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(6, 4))");
  });
  it("tsql -> tsql: CAST(x as SMALLMONEY)", () => {
    const result = transpile("CAST(x as SMALLMONEY)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS SMALLMONEY)");
  });
  it("tsql -> spark: CAST(x as REAL)", () => {
    const result = transpile("CAST(x as REAL)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS FLOAT)");
  });
  it("tsql -> tsql: CAST(x as REAL)", () => {
    const result = transpile("CAST(x as REAL)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS FLOAT)");
  });
});

describe("Tsql: types_string", () => {
  it.todo("tsql -> spark: CAST(x as CHAR(1)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as CHAR(1))", () => {
    const result = transpile("CAST(x as CHAR(1))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS CHAR(1))");
  });
  it.todo("tsql -> spark: CAST(x as VARCHAR(2)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as VARCHAR(2))", () => {
    const result = transpile("CAST(x as VARCHAR(2))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS VARCHAR(2))");
  });
  it.todo("tsql -> spark: CAST(x as NCHAR(1)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as NCHAR(1))", () => {
    const result = transpile("CAST(x as NCHAR(1))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS NCHAR(1))");
  });
  it.todo("tsql -> spark: CAST(x as NVARCHAR(2)) (cross-dialect transform)");
  it("tsql -> tsql: CAST(x as NVARCHAR(2))", () => {
    const result = transpile("CAST(x as NVARCHAR(2))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS NVARCHAR(2))");
  });
  it("tsql -> spark: CAST(x as UNIQUEIDENTIFIER)", () => {
    const result = transpile("CAST(x as UNIQUEIDENTIFIER)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS STRING)");
  });
  it("tsql -> tsql: CAST(x as UNIQUEIDENTIFIER)", () => {
    const result = transpile("CAST(x as UNIQUEIDENTIFIER)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS UNIQUEIDENTIFIER)");
  });
});

describe("Tsql: types_date", () => {
  it("tsql -> spark: CAST(x as DATE)", () => {
    const result = transpile("CAST(x as DATE)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it("tsql -> tsql: CAST(x as DATE)", () => {
    const result = transpile("CAST(x as DATE)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it("tsql -> spark: CAST(x as DATE) (2)", () => {
    const result = transpile("CAST(x as DATE)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it("tsql -> tsql: CAST(x as DATE) (2)", () => {
    const result = transpile("CAST(x as DATE)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it.todo("tsql -> spark: CAST(x as TIME(4)) (unsupported syntax)");
  it("tsql -> tsql: CAST(x as TIME(4))", () => {
    const result = transpile("CAST(x as TIME(4))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS TIME(4))");
  });
  it.todo("tsql -> spark: CAST(x as DATETIME2) (unsupported syntax)");
  it("tsql -> tsql: CAST(x as DATETIME2)", () => {
    const result = transpile("CAST(x as DATETIME2)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATETIME2)");
  });
  it.todo("tsql -> spark: CAST(x as DATETIMEOFFSET) (unsupported syntax)");
  it("tsql -> tsql: CAST(x as DATETIMEOFFSET)", () => {
    const result = transpile("CAST(x as DATETIMEOFFSET)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS DATETIMEOFFSET)");
  });
  it.todo("CREATE TABLE t (col1 DATETIME2(2)) (DDL/DML not supported)");
});

describe("Tsql: types_bin", () => {
  it("tsql -> spark: CAST(x as BIT)", () => {
    const result = transpile("CAST(x as BIT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS BOOLEAN)");
  });
  it("tsql -> tsql: CAST(x as BIT)", () => {
    const result = transpile("CAST(x as BIT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it("tsql -> spark: CAST(x as VARBINARY)", () => {
    const result = transpile("CAST(x as VARBINARY)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS BINARY)");
  });
  it("tsql -> tsql: CAST(x as VARBINARY)", () => {
    const result = transpile("CAST(x as VARBINARY)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS VARBINARY)");
  });
  it("tsql -> tsql: CAST(x AS BOOLEAN)", () => {
    const result = transpile("CAST(x AS BOOLEAN)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it("tsql -> tsql: a = TRUE", () => {
    const result = transpile("a = TRUE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("a = 1");
  });
  it("tsql -> tsql: a != FALSE", () => {
    const result = transpile("a != FALSE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("a <> 0");
  });
  it("tsql -> tsql: a IS TRUE", () => {
    const result = transpile("a IS TRUE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("a = 1");
  });
  it("tsql -> tsql: a IS NOT FALSE", () => {
    const result = transpile("a IS NOT FALSE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("NOT a = 0");
  });
  it.todo("CASE WHEN a IN (TRUE) THEN 'y' ELSE 'n' END (unsupported syntax)");
  it.todo("CASE WHEN a NOT IN (FALSE) THEN 'y' ELSE 'n' END (unsupported syntax)");
  it("tsql -> tsql: SELECT TRUE, FALSE", () => {
    const result = transpile("SELECT TRUE, FALSE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT 1, 0");
  });
  it("tsql -> tsql: SELECT TRUE AS a, FALSE AS b", () => {
    const result = transpile("SELECT TRUE AS a, FALSE AS b", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT 1 AS a, 0 AS b");
  });
  it("tsql -> tsql: SELECT 1 FROM a WHERE TRUE", () => {
    const result = transpile("SELECT 1 FROM a WHERE TRUE", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT 1 FROM a WHERE (1 = 1)");
  });
  it.todo("CASE WHEN TRUE THEN 'y' WHEN FALSE THEN 'n' ELSE NULL END (unsupported syntax)");
});

describe("Tsql: ddl", () => {
  it.todo("CREATE NONCLUSTERED COLUMNSTORE INDEX index_name ON foo.bar (DDL/DML not supported)");
  it.todo("CREATE CLUSTERED COLUMNSTORE INDEX index_name ON foo.bar (DDL/DML not supported)");
  it.todo("CREATE VIEW a.b WITH ENCRYPTION AS SELECT * FROM x (DDL/DML not supported)");
  it.todo("CREATE VIEW a.b WITH SCHEMABINDING AS SELECT * FROM x (DDL/DML not supported)");
  it.todo("CREATE VIEW a.b WITH VIEW_METADATA AS SELECT * FROM x (DDL/DML not supported)");
  it.todo('CREATE TABLE "dbo"."benchmark" ("name" CHAR(7) NOT NULL, "internal_... (DDL/DML not supported)');
  it.todo('CREATE TABLE "dbo"."benchmark" ("name" CHAR(7) NOT NULL, "internal_... (DDL/DML not supported) (2)');
  it.todo("CREATE SCHEMA testSchema (DDL/DML not supported)");
  it.todo("CREATE VIEW t AS WITH cte AS (SELECT 1 AS c) SELECT c FROM cte (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (SYSTEM_VERSIONING=OFF) (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (FILESTREAM_ON = 'test') (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (DATA_DELETION=ON) (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (DATA_DELETION=OFF) (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 WITH CHECK ADD CONSTRAINT ctr FOREIGN KEY (c1) REFER... (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (SYSTEM_VERSIONING=ON(HISTORY_TABLE=db.tbl, DAT... (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (SYSTEM_VERSIONING=ON(HISTORY_TABLE=db.tbl, HIS... (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET (DATA_DELETION=ON(FILTER_COLUMN=col, RETENTION_... (DDL/DML not supported)");
  it.todo("ALTER VIEW v AS SELECT a, b, c, d FROM foo (DDL/DML not supported)");
  it.todo("ALTER VIEW v AS SELECT * FROM foo WHERE c > 100 (DDL/DML not supported)");
  it.todo("ALTER VIEW v WITH SCHEMABINDING AS SELECT * FROM foo WHERE c > 100 (check_command_warning)");
  it.todo("ALTER VIEW v WITH ENCRYPTION AS SELECT * FROM foo WHERE c > 100 (check_command_warning)");
  it.todo("ALTER VIEW v WITH VIEW_METADATA AS SELECT * FROM foo WHERE c > 100 (check_command_warning)");
  it.todo("CREATE COLUMNSTORE INDEX index_name ON foo.bar (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo AS BEGIN DELETE FROM bla WHERE foo < CURRENT_T... (DDL/DML not supported)");
  it.todo("INSERT INTO Production.UpdatedInventory SELECT ProductID, LocationI... (pretty=True not supported)");
  it.todo("CREATE TABLE [#temptest] (name INTEGER) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (id INTEGER IDENTITY PRIMARY KEY) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (id INTEGER NOT NULL IDENTITY(10, 1) PRIMARY KEY) (DDL/DML not supported)");
  it.todo("CREATE TABLE x (a UNIQUEIDENTIFIER, b VARBINARY) (DDL/DML not supported)");
  it.todo("SELECT * INTO foo.bar.baz FROM (SELECT * FROM a.b.c) AS temp (DDL/DML in read/write)");
  it.todo("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = object_i... (DDL/DML in read/write)");
  it.todo("IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHE... (DDL/DML in read/write)");
  it.todo("IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_... (DDL/DML in read/write)");
  it.todo("IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_... (unsupported syntax)");
  it.todo("IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_... (DDL/DML in read/write) (2)");
  it.todo("CREATE OR ALTER VIEW a.b AS SELECT 1 (DDL/DML not supported)");
  it.todo("ALTER TABLE a ADD b INTEGER, c INTEGER (DDL/DML not supported)");
  it.todo("ALTER TABLE a ALTER COLUMN b INTEGER (DDL/DML not supported)");
  it.todo("CREATE TABLE #mytemp (a INTEGER, b CHAR(2), c TIME(4), d FLOAT(24)) (DDL/DML not supported)");
  it.todo("test_ddl: assert statement");
  it.todo("test_ddl: assert statement (2)");
});

describe("Tsql: transaction", () => {
  it.todo("BEGIN TRANSACTION (command not supported)");
  it.todo("BEGIN TRAN (command not supported)");
  it.todo("BEGIN TRANSACTION transaction_name (command not supported)");
  it.todo("BEGIN TRANSACTION @tran_name_variable (command not supported)");
  it.todo("BEGIN TRANSACTION transaction_name WITH MARK 'description' (command not supported)");
});

describe("Tsql: commit", () => {
  it.todo("COMMIT (command not supported)");
  it.todo("COMMIT TRAN (command not supported)");
  it.todo("COMMIT TRANSACTION (command not supported)");
  it.todo("COMMIT TRANSACTION transaction_name (command not supported)");
  it.todo("COMMIT TRANSACTION @tran_name_variable (command not supported)");
  it.todo("COMMIT TRANSACTION @tran_name_variable WITH (DELAYED_DURABILITY = ON) (command not supported)");
  it.todo("COMMIT TRANSACTION transaction_name WITH (DELAYED_DURABILITY = OFF) (command not supported)");
});

describe("Tsql: rollback", () => {
  it.todo("ROLLBACK (command not supported)");
  it.todo("ROLLBACK TRAN (command not supported)");
  it.todo("ROLLBACK TRANSACTION (command not supported)");
  it.todo("ROLLBACK TRANSACTION transaction_name (command not supported)");
  it.todo("ROLLBACK TRANSACTION @tran_name_variable (command not supported)");
});

describe("Tsql: udf", () => {
  it.todo("DECLARE @DWH_DateCreated AS DATETIME2 = CONVERT(DATETIME2, GETDATE(... (command not supported)");
  it.todo("CREATE PROCEDURE foo @a INTEGER, @b INTEGER AS SELECT @a = SUM(bla)... (DDL/DML not supported)");
  it.todo("CREATE PROC foo @ID INTEGER, @AGE INTEGER AS SELECT DB_NAME(@ID) AS... (DDL/DML not supported)");
  it.todo("CREATE PROC foo AS SELECT BAR() AS baz (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo AS SELECT BAR() AS baz (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH ENCRYPTION AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH RECOMPILE AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH SCHEMABINDING AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH NATIVE_COMPILATION AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH EXECUTE AS OWNER AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH EXECUTE AS 'username' AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE PROCEDURE foo WITH EXECUTE AS OWNER, SCHEMABINDING, NATIVE_C... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(@bar INTEGER) RETURNS TABLE AS RETURN SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE FUNCTION dbo.ISOweek(@DATE DATETIME2) RETURNS INTEGER (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(@bar INTEGER) RETURNS @foo TABLE (x INTEGER, y ... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo() RETURNS @contacts TABLE (first_name VARCHAR(5... (DDL/DML not supported)");
  it.todo("\n            CREATE FUNCTION udfProductInYear (\n                @mo... (pretty=True not supported)");
});

describe("Tsql: procedure_keywords", () => {
  it.todo("BEGIN (command not supported)");
  it("END", () => {
    validateIdentity("END");
  });
  it.todo("SET XACT_ABORT ON (command not supported)");
});

describe("Tsql: charindex", () => {
  it.todo("SELECT CAST(SUBSTRING('ABCD~1234', CHARINDEX('~', 'ABCD~1234') + 1,... (unsupported syntax)");
  it.todo("spark -> tsql: LOCATE(x, y, 9) (cross-dialect transform)");
  it.todo("tsql -> spark: CHARINDEX(x, y, 9) (cross-dialect transform)");
  it("tsql -> tsql: CHARINDEX(x, y, 9)", () => {
    const result = transpile("CHARINDEX(x, y, 9)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CHARINDEX(x, y, 9)");
  });
  it.todo("spark -> tsql: LOCATE(x, y) (cross-dialect transform)");
  it.todo("tsql -> spark: CHARINDEX(x, y) (cross-dialect transform)");
  it("tsql -> tsql: CHARINDEX(x, y)", () => {
    const result = transpile("CHARINDEX(x, y)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CHARINDEX(x, y)");
  });
  it.todo("spark -> tsql: LOCATE('sub', 'testsubstring', 3) (cross-dialect transform)");
  it.todo("tsql -> spark: CHARINDEX('sub', 'testsubstring', 3) (cross-dialect transform)");
  it("tsql -> tsql: CHARINDEX('sub', 'testsubstring', 3)", () => {
    const result = transpile("CHARINDEX('sub', 'testsubstring', 3)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CHARINDEX('sub', 'testsubstring', 3)");
  });
  it.todo("spark -> tsql: LOCATE('sub', 'testsubstring') (cross-dialect transform)");
  it.todo("tsql -> spark: CHARINDEX('sub', 'testsubstring') (cross-dialect transform)");
  it("tsql -> tsql: CHARINDEX('sub', 'testsubstring')", () => {
    const result = transpile("CHARINDEX('sub', 'testsubstring')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CHARINDEX('sub', 'testsubstring')");
  });
});

describe("Tsql: len", () => {
  it(" -> tsql: LENGTH(x)", () => {
    const result = transpile("LENGTH(x)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("LEN(x)");
  });
  it.todo("tsql -> spark: LEN(x) (cross-dialect transform)");
  it.todo(" -> tsql: RIGHT(CAST(x AS STRING), 1) (cross-dialect transform)");
  it.todo("tsql -> spark: RIGHT(x, 1) (cross-dialect transform)");
  it.todo(" -> tsql: LEFT(CAST(x AS STRING), 1) (cross-dialect transform)");
  it.todo("tsql -> spark: LEFT(x, 1) (cross-dialect transform)");
  it("tsql -> tsql: LEN(1)", () => {
    const result = transpile("LEN(1)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("LEN(1)");
  });
  it.todo("tsql -> spark: LEN(1) (cross-dialect transform)");
  it("tsql -> tsql: LEN('x')", () => {
    const result = transpile("LEN('x')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("LEN('x')");
  });
  it("tsql -> spark: LEN('x')", () => {
    const result = transpile("LEN('x')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LENGTH('x')");
  });
});

describe("Tsql: replicate", () => {
  it.todo("tsql -> spark: REPLICATE('x', 2) (cross-dialect transform)");
  it("tsql -> tsql: REPLICATE('x', 2)", () => {
    const result = transpile("REPLICATE('x', 2)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("REPLICATE('x', 2)");
  });
});

describe("Tsql: isnull", () => {
  it.todo("ISNULL(x, y) (unsupported syntax)");
  it.todo("ISNULL(x, y) (unsupported syntax) (2)");
});

describe("Tsql: json", () => {
  it.todo(`JSON_QUERY(REPLACE(REPLACE(x , '''', '"'), '""', '"')) (unsupported syntax)`);
  it.todo("tsql -> spark: JSON_QUERY(r.JSON, '$.Attr_INT') (cross-dialect transform)");
  it.todo("tsql -> tsql: JSON_QUERY(r.JSON, '$.Attr_INT') (unsupported syntax)");
  it.todo("tsql -> spark: JSON_VALUE(r.JSON, '$.Attr_INT') (cross-dialect transform)");
  it.todo("tsql -> tsql: JSON_VALUE(r.JSON, '$.Attr_INT') (unsupported syntax)");
});

describe("Tsql: datefromparts", () => {
  it.todo("tsql -> spark: SELECT DATEFROMPARTS('2020', 10, 01) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATEFROMPARTS('2020', 10, 01)", () => {
    const result = transpile("SELECT DATEFROMPARTS('2020', 10, 01)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEFROMPARTS('2020', 10, 01)");
  });
});

describe("Tsql: datename", () => {
  it.todo("tsql -> spark: SELECT DATENAME(mm, '1970-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATENAME(mm, '1970-01-01')", () => {
    const result = transpile("SELECT DATENAME(mm, '1970-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(CAST('1970-01-01' AS DATETIME2), 'MMMM')");
  });
  it.todo("tsql -> spark: SELECT DATENAME(dw, '1970-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATENAME(dw, '1970-01-01')", () => {
    const result = transpile("SELECT DATENAME(dw, '1970-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(CAST('1970-01-01' AS DATETIME2), 'dddd')");
  });
});

describe("Tsql: datepart", () => {
  it.todo("tsql -> spark: SELECT DATEPART(month,'1970-01-01') (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATEPART(month,'1970-01-01')", () => {
    const result = transpile("SELECT DATEPART(month,'1970-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEPART(month, '1970-01-01')");
  });
  it.todo("postgres -> tsql: SELECT DATE_PART('YEAR', '2017-01-01'::DATE) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT DATEPART(YEAR, CAST('2017-01-01' AS DATE)) (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT DATEPART(YEAR, CAST('2017-01-01' AS DATE)) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATEPART(YEAR, CAST('2017-01-01' AS DATE))", () => {
    const result = transpile("SELECT DATEPART(YEAR, CAST('2017-01-01' AS DATE))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEPART(YEAR, CAST('2017-01-01' AS DATE))");
  });
  it.todo("postgres -> tsql: SELECT DATE_PART('month', '2017-03-01'::DATE) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT DATEPART(month, CAST('2017-03-01' AS DATE)) (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT DATEPART(month, CAST('2017-03-01' AS DATE)) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATEPART(month, CAST('2017-03-01' AS DATE))", () => {
    const result = transpile("SELECT DATEPART(month, CAST('2017-03-01' AS DATE))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEPART(month, CAST('2017-03-01' AS DATE))");
  });
  it.todo("postgres -> tsql: SELECT DATE_PART('day', '2017-01-02'::DATE) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT DATEPART(day, CAST('2017-01-02' AS DATE)) (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT DATEPART(day, CAST('2017-01-02' AS DATE)) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATEPART(day, CAST('2017-01-02' AS DATE))", () => {
    const result = transpile("SELECT DATEPART(day, CAST('2017-01-02' AS DATE))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEPART(day, CAST('2017-01-02' AS DATE))");
  });
  it('SELECT DATEPART("dd", x) -> SELECT DATEPART(DAY, x)', () => {
    validateIdentity('SELECT DATEPART("dd", x)', "SELECT DATEPART(DAY, x)");
  });
});

describe("Tsql: convert", () => {
  it.todo("CONVERT(NVARCHAR(200), x) (unsupported syntax)");
  it.todo("CONVERT(NVARCHAR, x) (unsupported syntax)");
  it.todo("CONVERT(NVARCHAR(MAX), x) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR(200), x) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR, x) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR(MAX), x) (unsupported syntax)");
  it.todo("CONVERT(CHAR(40), x) (unsupported syntax)");
  it.todo("CONVERT(CHAR, x) (unsupported syntax)");
  it.todo("CONVERT(NCHAR(40), x) (unsupported syntax)");
  it.todo("CONVERT(NCHAR, x) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR, x, 121) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR(40), x, 121) (unsupported syntax)");
  it.todo("CONVERT(VARCHAR(MAX), x, 121) (unsupported syntax)");
  it.todo("CONVERT(NVARCHAR, x, 121) (unsupported syntax)");
  it.todo("CONVERT(NVARCHAR(40), x, 121) (unsupported syntax)");
  it.todo("CONVERT(NVARCHAR(MAX), x, 121) (unsupported syntax)");
  it.todo("CONVERT(DATE, x, 121) (unsupported syntax)");
  it.todo("CONVERT(DATETIME, x, 121) (unsupported syntax)");
  it.todo("CONVERT(DATETIME2, x, 121) (unsupported syntax)");
  it.todo("CONVERT(INT, x) (unsupported syntax)");
  it.todo("CONVERT(INT, x, 121) (unsupported syntax)");
  it.todo("tsql -> spark: TRY_CONVERT(NVARCHAR, x, 121) (unsupported syntax)");
  it("tsql -> tsql: TRY_CONVERT(NVARCHAR, x, 121)", () => {
    const result = transpile("TRY_CONVERT(NVARCHAR, x, 121)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("TRY_CONVERT(NVARCHAR, x, 121)");
  });
  it.todo("tsql -> spark: TRY_CONVERT(INT, x) (cross-dialect transform)");
  it("tsql -> tsql: TRY_CONVERT(INT, x)", () => {
    const result = transpile("TRY_CONVERT(INT, x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("TRY_CONVERT(INTEGER, x)");
  });
  it("tsql -> spark: TRY_CAST(x AS INT)", () => {
    const result = transpile("TRY_CAST(x AS INT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRY_CAST(x AS INT)");
  });
  it("tsql -> tsql: TRY_CAST(x AS INT)", () => {
    const result = transpile("TRY_CAST(x AS INT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("TRY_CAST(x AS INTEGER)");
  });
  it.todo("SELECT CONVERT(VARCHAR(10), testdb.dbo.test.x, 120) y FROM testdb.d... (unsupported syntax)");
  it.todo("SELECT CONVERT(VARCHAR(10), y.x) z FROM testdb.dbo.test y (unsupported syntax)");
  it("tsql -> spark: SELECT CAST((SELECT x FROM y) AS VARCHAR) AS test", () => {
    const result = transpile("SELECT CAST((SELECT x FROM y) AS VARCHAR) AS test", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST((SELECT x FROM y) AS STRING) AS test");
  });
  it("tsql -> tsql: SELECT CAST((SELECT x FROM y) AS VARCHAR) AS test", () => {
    const result = transpile("SELECT CAST((SELECT x FROM y) AS VARCHAR) AS test", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT CAST((SELECT x FROM y) AS VARCHAR) AS test");
  });
});

describe("Tsql: add_date", () => {
  it("SELECT DATEADD(YEAR, 1, '2017/08/25')", () => {
    validateIdentity("SELECT DATEADD(YEAR, 1, '2017/08/25')");
  });
  it.todo("tsql -> bigquery: DATEADD(year, 50, '2006-07-31') (unsupported syntax)");
  it.todo("tsql -> spark: SELECT DATEADD(year, 1, '2017/08/25') (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT DATEADD(qq, 1, '2017/08/25') (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT DATEADD(wk, 1, '2017/08/25') (cross-dialect transform)");
  it.todo("tsql -> databricks: SELECT DATEADD(wk, 1, '2017/08/25') (cross-dialect transform)");
});

describe("Tsql: date_diff", () => {
  it("SELECT DATEDIFF(HOUR, 1.5, '2021-01-01')", () => {
    validateIdentity("SELECT DATEDIFF(HOUR, 1.5, '2021-01-01')");
  });
  it("SELECT DATEDIFF_BIG(HOUR, 1.5, '2021-01-01')", () => {
    validateIdentity("SELECT DATEDIFF_BIG(HOUR, 1.5, '2021-01-01')");
  });
  it("tsql -> tsql: SELECT DATEDIFF(quarter, 0, '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF(quarter, 0, '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(QUARTER, CAST('1900-01-01' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF(quarter, 0, '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> duckdb: SELECT DATEDIFF(quarter, 0, '2021-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF(day, 1, '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF(day, 1, '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(DAY, CAST('1900-01-02' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF(day, 1, '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> duckdb: SELECT DATEDIFF(day, 1, '2021-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF(year, '2020-01-01', '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF(year, '2020-01-01', '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(YEAR, CAST('2020-01-01' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF(year, '2020-01-01', '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF(year, '2020-01-01', '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> databricks: SELECT DATEDIFF(mm, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF(mm, 'start', 'end') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF(mm, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(mm, 'start', 'end')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(MONTH, CAST('start' AS DATETIME2), CAST('end' AS DATETIME2))");
  });
  it.todo("tsql -> databricks: SELECT DATEDIFF(quarter, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark: SELECT DATEDIFF(quarter, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF(quarter, 'start', 'end') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF(quarter, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(quarter, 'start', 'end')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(QUARTER, CAST('start' AS DATETIME2), CAST('end' AS DATETIME2))");
  });
  it("tsql -> tsql: SELECT DATEDIFF(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x FRO...", () => {
    const result = transpile("SELECT DATEDIFF(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x FROM foo", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x FROM foo");
  });
  it.todo("tsql -> clickhouse: SELECT DATEDIFF(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS... (cross-dialect transform)");
  it("SELECT DATEADD(DAY, DATEDIFF(DAY, -3, GETDATE()), '08:00:00') -> SELECT DATEADD(DAY, DA...", () => {
    validateIdentity("SELECT DATEADD(DAY, DATEDIFF(DAY, -3, GETDATE()), '08:00:00')", "SELECT DATEADD(DAY, DATEDIFF(DAY, CAST('1899-12-29' AS DATETIME2), CAST(GETDATE() AS DATETIME2)), '08:00:00')");
  });
  it("tsql -> tsql: SELECT DATEDIFF_BIG(quarter, 0, '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF_BIG(quarter, 0, '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(QUARTER, CAST('1900-01-01' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF_BIG(quarter, 0, '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> duckdb: SELECT DATEDIFF_BIG(quarter, 0, '2021-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF_BIG(day, 1, '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF_BIG(day, 1, '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(DAY, CAST('1900-01-02' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF_BIG(day, 1, '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> duckdb: SELECT DATEDIFF_BIG(day, 1, '2021-01-01') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF_BIG(year, '2020-01-01', '2021-01-01')", () => {
    const result = transpile("SELECT DATEDIFF_BIG(year, '2020-01-01', '2021-01-01')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(YEAR, CAST('2020-01-01' AS DATETIME2), CAST('2021-01-01' AS DATETIME2))");
  });
  it.todo("tsql -> spark: SELECT DATEDIFF_BIG(year, '2020-01-01', '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF_BIG(year, '2020-01-01', '2021-01-01') (unsupported syntax)");
  it.todo("tsql -> databricks: SELECT DATEDIFF_BIG(mm, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF_BIG(mm, 'start', 'end') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF_BIG(mm, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF_BIG(mm, 'start', 'end')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(MONTH, CAST('start' AS DATETIME2), CAST('end' AS DATETIME2))");
  });
  it.todo("tsql -> databricks: SELECT DATEDIFF_BIG(quarter, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark: SELECT DATEDIFF_BIG(quarter, 'start', 'end') (unsupported syntax)");
  it.todo("tsql -> spark2: SELECT DATEDIFF_BIG(quarter, 'start', 'end') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATEDIFF_BIG(quarter, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF_BIG(quarter, 'start', 'end')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(QUARTER, CAST('start' AS DATETIME2), CAST('end' AS DATETIME2))");
  });
  it("tsql -> tsql: SELECT DATEDIFF_BIG(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x...", () => {
    const result = transpile("SELECT DATEDIFF_BIG(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x FROM foo", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATEDIFF_BIG(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)) AS x FROM foo");
  });
  it.todo("tsql -> clickhouse: SELECT DATEDIFF_BIG(DAY, CAST(a AS DATETIME2), CAST(b AS DATETIME2)... (cross-dialect transform)");
  it("SELECT DATEADD(DAY, DATEDIFF_BIG(DAY, -3, GETDATE()), '08:00:00') -> SELECT DATEADD(DAY...", () => {
    validateIdentity("SELECT DATEADD(DAY, DATEDIFF_BIG(DAY, -3, GETDATE()), '08:00:00')", "SELECT DATEADD(DAY, DATEDIFF_BIG(DAY, CAST('1899-12-29' AS DATETIME2), CAST(GETDATE() AS DATETIME2)), '08:00:00')");
  });
});

describe("Tsql: lateral_subquery", () => {
  it.todo("tsql -> spark: SELECT x.a, x.b, t.v, t.y FROM x CROSS APPLY (SELECT v, y FROM t) t(v, y) (unsupported clause)");
  it.todo("tsql -> postgres: SELECT x.a, x.b, t.v, t.y FROM x CROSS APPLY (SELECT v, y FROM t) t(v... (unsupported clause)");
  it("tsql -> tsql: SELECT x.a, x.b, t.v, t.y FROM x CROSS APPLY (SELECT v, y FROM t) t(v, y)", () => {
    const result = transpile("SELECT x.a, x.b, t.v, t.y FROM x CROSS APPLY (SELECT v, y FROM t) t(v, y)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT x.a, x.b, t.v, t.y FROM x CROSS APPLY (SELECT v, y FROM t) AS t(v, y)");
  });
  it.todo("tsql -> spark: SELECT x.a, x.b, t.v, t.y FROM x OUTER APPLY (SELECT v, y FROM t) t(v, y) (unsupported clause)");
  it.todo("tsql -> postgres: SELECT x.a, x.b, t.v, t.y FROM x OUTER APPLY (SELECT v, y FROM t) t(v... (unsupported clause)");
  it("tsql -> tsql: SELECT x.a, x.b, t.v, t.y FROM x OUTER APPLY (SELECT v, y FROM t) t(v, y)", () => {
    const result = transpile("SELECT x.a, x.b, t.v, t.y FROM x OUTER APPLY (SELECT v, y FROM t) t(v, y)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT x.a, x.b, t.v, t.y FROM x OUTER APPLY (SELECT v, y FROM t) AS t(v, y)");
  });
  it.todo("tsql -> spark: SELECT x.a, x.b, t.v, t.y, s.v, s.y FROM x OUTER APPLY (SELECT v, y FROM... (unsupported clause)");
  it.todo("tsql -> postgres: SELECT x.a, x.b, t.v, t.y, s.v, s.y FROM x OUTER APPLY (SELECT v, y F... (unsupported clause)");
  it("tsql -> tsql: SELECT x.a, x.b, t.v, t.y, s.v, s.y FROM x OUTER APPLY (SELECT v, y FROM ...", () => {
    const result = transpile("SELECT x.a, x.b, t.v, t.y, s.v, s.y FROM x OUTER APPLY (SELECT v, y FROM t) t(v, y) OUTER APPLY (SELECT v, y FROM t) s(v, y) LEFT JOIN z ON z.id = s.id", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT x.a, x.b, t.v, t.y, s.v, s.y FROM x OUTER APPLY (SELECT v, y FROM t) AS t(v, y) OUTER APPLY (SELECT v, y FROM t) AS s(v, y) LEFT JOIN z ON z.id = s.id");
  });
});

describe("Tsql: lateral_table_valued_function", () => {
  it.todo("tsql -> spark: SELECT t.x, y.z FROM x CROSS APPLY tvfTest(t.x) y(z) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT t.x, y.z FROM x CROSS APPLY tvfTest(t.x) y(z) (unsupported syntax)");
  it("tsql -> tsql: SELECT t.x, y.z FROM x CROSS APPLY tvfTest(t.x) y(z)", () => {
    const result = transpile("SELECT t.x, y.z FROM x CROSS APPLY tvfTest(t.x) y(z)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT t.x, y.z FROM x CROSS APPLY TVFTEST(t.x) AS y(z)");
  });
  it.todo("tsql -> spark: SELECT t.x, y.z FROM x OUTER APPLY tvfTest(t.x)y(z) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT t.x, y.z FROM x OUTER APPLY tvfTest(t.x)y(z) (unsupported syntax)");
  it("tsql -> tsql: SELECT t.x, y.z FROM x OUTER APPLY tvfTest(t.x)y(z)", () => {
    const result = transpile("SELECT t.x, y.z FROM x OUTER APPLY tvfTest(t.x)y(z)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT t.x, y.z FROM x OUTER APPLY TVFTEST(t.x) AS y(z)");
  });
  it.todo("tsql -> spark: SELECT t.x, y.z FROM x OUTER APPLY a.b.tvfTest(t.x)y(z) (unsupported syntax)");
  it.todo("tsql -> postgres: SELECT t.x, y.z FROM x OUTER APPLY a.b.tvfTest(t.x)y(z) (unsupported syntax)");
  it("tsql -> tsql: SELECT t.x, y.z FROM x OUTER APPLY a.b.tvfTest(t.x)y(z)", () => {
    const result = transpile("SELECT t.x, y.z FROM x OUTER APPLY a.b.tvfTest(t.x)y(z)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT t.x, y.z FROM x OUTER APPLY a.b.tvfTest(t.x) AS y(z)");
  });
});

describe("Tsql: top", () => {
  it("spark -> tsql: SELECT DISTINCT * FROM A LIMIT 3", () => {
    const result = transpile("SELECT DISTINCT * FROM A LIMIT 3", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DISTINCT TOP 3 * FROM A");
  });
  it("tsql -> spark: SELECT DISTINCT TOP 3 * FROM A", () => {
    const result = transpile("SELECT DISTINCT TOP 3 * FROM A", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT DISTINCT * FROM A LIMIT 3");
  });
  it("tsql -> teradata: SELECT DISTINCT TOP 3 * FROM A", () => {
    const result = transpile("SELECT DISTINCT TOP 3 * FROM A", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("SELECT DISTINCT TOP 3 * FROM A");
  });
  it("tsql -> tsql: SELECT DISTINCT TOP 3 * FROM A", () => {
    const result = transpile("SELECT DISTINCT TOP 3 * FROM A", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DISTINCT TOP 3 * FROM A");
  });
  it("tsql -> spark: SELECT TOP (3) * FROM A", () => {
    const result = transpile("SELECT TOP (3) * FROM A", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM A LIMIT 3");
  });
  it.todo("CREATE TABLE schema.table AS SELECT a, id FROM (SELECT a, (SELECT i... (DDL/DML not supported)");
  it("SELECT TOP 10 PERCENT", () => {
    validateIdentity("SELECT TOP 10 PERCENT");
  });
  it("SELECT TOP 10 PERCENT WITH TIES", () => {
    validateIdentity("SELECT TOP 10 PERCENT WITH TIES");
  });
});

describe("Tsql: format", () => {
  it("SELECT FORMAT(foo, 'dddd', 'de-CH')", () => {
    validateIdentity("SELECT FORMAT(foo, 'dddd', 'de-CH')");
  });
  it.todo("SELECT FORMAT(EndOfDayRate, 'N', 'en-us') (unsupported syntax)");
  it("SELECT FORMAT('01-01-1991', 'd.mm.yyyy')", () => {
    validateIdentity("SELECT FORMAT('01-01-1991', 'd.mm.yyyy')");
  });
  it("SELECT FORMAT(12345, '###.###.###')", () => {
    validateIdentity("SELECT FORMAT(12345, '###.###.###')");
  });
  it("SELECT FORMAT(1234567, 'f')", () => {
    validateIdentity("SELECT FORMAT(1234567, 'f')");
  });
  it.todo("tsql -> spark: SELECT FORMAT(1000000.01,'###,###.###') (cross-dialect transform)");
  it("tsql -> tsql: SELECT FORMAT(1000000.01,'###,###.###')", () => {
    const result = transpile("SELECT FORMAT(1000000.01,'###,###.###')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(1000000.01, '###,###.###')");
  });
  it.todo("tsql -> spark: SELECT FORMAT(1234567, 'f') (cross-dialect transform)");
  it("tsql -> tsql: SELECT FORMAT(1234567, 'f')", () => {
    const result = transpile("SELECT FORMAT(1234567, 'f')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(1234567, 'f')");
  });
  it.todo("tsql -> spark: SELECT FORMAT('01-01-1991', 'dd.mm.yyyy') (unsupported syntax)");
  it("tsql -> tsql: SELECT FORMAT('01-01-1991', 'dd.mm.yyyy')", () => {
    const result = transpile("SELECT FORMAT('01-01-1991', 'dd.mm.yyyy')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT('01-01-1991', 'dd.mm.yyyy')");
  });
  it.todo("tsql -> spark: SELECT FORMAT(date_col, 'dd.mm.yyyy') (unsupported syntax)");
  it("tsql -> tsql: SELECT FORMAT(date_col, 'dd.mm.yyyy')", () => {
    const result = transpile("SELECT FORMAT(date_col, 'dd.mm.yyyy')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(date_col, 'dd.mm.yyyy')");
  });
  it.todo("tsql -> spark: SELECT FORMAT(date_col, 'm') (unsupported syntax)");
  it("tsql -> tsql: SELECT FORMAT(date_col, 'm')", () => {
    const result = transpile("SELECT FORMAT(date_col, 'm')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(date_col, 'MMMM d')");
  });
  it("tsql -> spark: SELECT FORMAT(num_col, 'c')", () => {
    const result = transpile("SELECT FORMAT(num_col, 'c')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT FORMAT_NUMBER(num_col, 'c')");
  });
  it("tsql -> tsql: SELECT FORMAT(num_col, 'c')", () => {
    const result = transpile("SELECT FORMAT(num_col, 'c')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT FORMAT(num_col, 'c')");
  });
});

describe("Tsql: string", () => {
  it.todo("SELECT N'test' (unsupported syntax)");
  it.todo("SELECT n'test' (unsupported syntax)");
  it.todo("SELECT '''test''' (unsupported syntax)");
});

describe("Tsql: eomonth", () => {
  it.todo("spark -> tsql: LAST_DAY(CURRENT_TIMESTAMP()) (cross-dialect transform)");
  it.todo("tsql -> bigquery: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> clickhouse: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> duckdb: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> mysql: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> postgres: EOMONTH(GETDATE()) (unsupported syntax)");
  it.todo("tsql -> presto: EOMONTH(GETDATE()) (unsupported syntax)");
  it.todo("tsql -> redshift: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> snowflake: EOMONTH(GETDATE()) (cross-dialect transform)");
  it.todo("tsql -> spark: EOMONTH(GETDATE()) (cross-dialect transform)");
  it("tsql -> tsql: EOMONTH(GETDATE())", () => {
    const result = transpile("EOMONTH(GETDATE())", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("EOMONTH(CAST(GETDATE() AS DATE))");
  });
  it.todo("tsql -> bigquery: EOMONTH(GETDATE(), -1) (unsupported syntax)");
  it.todo("tsql -> clickhouse: EOMONTH(GETDATE(), -1) (cross-dialect transform)");
  it.todo("tsql -> duckdb: EOMONTH(GETDATE(), -1) (cross-dialect transform)");
  it.todo("tsql -> mysql: EOMONTH(GETDATE(), -1) (unsupported syntax)");
  it.todo("tsql -> postgres: EOMONTH(GETDATE(), -1) (unsupported syntax)");
  it.todo("tsql -> presto: EOMONTH(GETDATE(), -1) (unsupported syntax)");
  it.todo("tsql -> redshift: EOMONTH(GETDATE(), -1) (cross-dialect transform)");
  it.todo("tsql -> snowflake: EOMONTH(GETDATE(), -1) (cross-dialect transform)");
  it.todo("tsql -> spark: EOMONTH(GETDATE(), -1) (cross-dialect transform)");
  it("tsql -> tsql: EOMONTH(GETDATE(), -1)", () => {
    const result = transpile("EOMONTH(GETDATE(), -1)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("EOMONTH(DATEADD(MONTH, -1, CAST(GETDATE() AS DATE)))");
  });
});

describe("Tsql: identifier_prefixes", () => {
  it.todo("test_identifier_prefixes: assertTrue call");
  it.todo("test_identifier_prefixes: assertTrue call (2)");
  it("tsql -> databricks: SELECT @x", () => {
    const result = transpile("SELECT @x", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT ${x}");
  });
  it("tsql -> hive: SELECT @x", () => {
    const result = transpile("SELECT @x", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT ${x}");
  });
  it("tsql -> spark: SELECT @x", () => {
    const result = transpile("SELECT @x", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT ${x}");
  });
  it("tsql -> tsql: SELECT @x", () => {
    const result = transpile("SELECT @x", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT @x");
  });
  it("tsql -> duckdb: SELECT * FROM #mytemptable", () => {
    const result = transpile("SELECT * FROM #mytemptable", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM mytemptable");
  });
  it("tsql -> spark: SELECT * FROM #mytemptable", () => {
    const result = transpile("SELECT * FROM #mytemptable", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM mytemptable");
  });
  it("tsql -> tsql: SELECT * FROM #mytemptable", () => {
    const result = transpile("SELECT * FROM #mytemptable", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT * FROM #mytemptable");
  });
  it("tsql -> duckdb: SELECT * FROM ##mytemptable", () => {
    const result = transpile("SELECT * FROM ##mytemptable", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM mytemptable");
  });
  it("tsql -> spark: SELECT * FROM ##mytemptable", () => {
    const result = transpile("SELECT * FROM ##mytemptable", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM mytemptable");
  });
  it("tsql -> tsql: SELECT * FROM ##mytemptable", () => {
    const result = transpile("SELECT * FROM ##mytemptable", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT * FROM ##mytemptable");
  });
});

describe("Tsql: temporal_table", () => {
  it.todo('CREATE TABLE test ("data" CHAR(7), "valid_from" DATETIME2(2) GENERA... (DDL/DML not supported)');
  it.todo("CREATE TABLE test ([data] CHAR(7), [valid_from] DATETIME2(2) GENERA... (DDL/DML not supported)");
  it.todo("CREATE TABLE test ([data] CHAR(7), [valid_from] DATETIME2(2) GENERA... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE test ([data] CHAR(7), [valid_from] DATETIME2(2) GENERA... (DDL/DML not supported) (3)");
  it.todo("CREATE TABLE test ([data] CHAR(7), [valid_from] DATETIME2(2) GENERA... (DDL/DML not supported) (4)");
  it.todo("CREATE TABLE test ([data] CHAR(7), [valid_from] DATETIME2(2) GENERA... (DDL/DML not supported) (5)");
});

describe("Tsql: system_time", () => {
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME AS OF 'foo'", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME AS OF 'foo'");
  });
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME AS OF 'foo' AS alias", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME AS OF 'foo' AS alias");
  });
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME FROM c TO d", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME FROM c TO d");
  });
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME BETWEEN c AND d", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME BETWEEN c AND d");
  });
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME CONTAINED IN (c, d)", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME CONTAINED IN (c, d)");
  });
  it("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME ALL AS alias", () => {
    validateIdentity("SELECT [x] FROM [a].[b] FOR SYSTEM_TIME ALL AS alias");
  });
});

describe("Tsql: current_user", () => {
  it.todo("tsql -> spark: SUSER_NAME() (cross-dialect transform)");
  it.todo("tsql -> spark: SUSER_SNAME() (cross-dialect transform)");
  it.todo("tsql -> spark: SYSTEM_USER() (cross-dialect transform)");
  it.todo("tsql -> spark: SYSTEM_USER (cross-dialect transform)");
});

describe("Tsql: hints", () => {
  it("tsql -> spark: SELECT x FROM a INNER HASH JOIN b ON b.id = a.id", () => {
    const result = transpile("SELECT x FROM a INNER HASH JOIN b ON b.id = a.id", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT x FROM a INNER JOIN b ON b.id = a.id");
  });
  it("tsql -> spark: SELECT x FROM a INNER LOOP JOIN b ON b.id = a.id", () => {
    const result = transpile("SELECT x FROM a INNER LOOP JOIN b ON b.id = a.id", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT x FROM a INNER JOIN b ON b.id = a.id");
  });
  it("tsql -> spark: SELECT x FROM a INNER REMOTE JOIN b ON b.id = a.id", () => {
    const result = transpile("SELECT x FROM a INNER REMOTE JOIN b ON b.id = a.id", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT x FROM a INNER JOIN b ON b.id = a.id");
  });
  it("tsql -> spark: SELECT x FROM a INNER MERGE JOIN b ON b.id = a.id", () => {
    const result = transpile("SELECT x FROM a INNER MERGE JOIN b ON b.id = a.id", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT x FROM a INNER JOIN b ON b.id = a.id");
  });
  it("tsql -> spark: SELECT x FROM a WITH (NOLOCK)", () => {
    const result = transpile("SELECT x FROM a WITH (NOLOCK)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT x FROM a");
  });
  it("tsql -> tsql: SELECT x FROM a WITH (NOLOCK)", () => {
    const result = transpile("SELECT x FROM a WITH (NOLOCK)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT x FROM a WITH (NOLOCK)");
  });
  it("tsql -> : SELECT x FROM a WITH (NOLOCK)", () => {
    const result = transpile("SELECT x FROM a WITH (NOLOCK)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT x FROM a WITH (NOLOCK)");
  });
  it("SELECT x FROM a INNER LOOP JOIN b ON b.id = a.id", () => {
    validateIdentity("SELECT x FROM a INNER LOOP JOIN b ON b.id = a.id");
  });
});

describe("Tsql: openjson", () => {
  it("SELECT * FROM OPENJSON(@json)", () => {
    validateIdentity("SELECT * FROM OPENJSON(@json)");
  });
  it(`tsql -> tsql: SELECT [key], value FROM OPENJSON(@json,'$.path.to."sub-object"')`, () => {
    const result = transpile(`SELECT [key], value FROM OPENJSON(@json,'$.path.to."sub-object"')`, { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe(`SELECT [key], value FROM OPENJSON(@json, '$.path.to."sub-object"')`);
  });
  it("tsql -> tsql: SELECT * FROM OPENJSON(@array) WITH (month VARCHAR(3), temp int, month_id...", () => {
    const result = transpile("SELECT * FROM OPENJSON(@array) WITH (month VARCHAR(3), temp int, month_id tinyint '$.sql:identity()') as months", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT * FROM OPENJSON(@array) WITH (month VARCHAR(3), temp INTEGER, month_id TINYINT '$.sql:identity()') AS months");
  });
  it.todo("\n            SELECT *\n            FROM OPENJSON ( @json )\n         ... (pretty=True not supported)");
});

describe("Tsql: set", () => {
  it.todo("SET KEY VALUE (command not supported)");
  it.todo("SET @count = (SELECT COUNT(1) FROM x) (command not supported)");
});

describe("Tsql: qualify_derived_table_outputs", () => {
  it("WITH t AS (SELECT 1) SELECT * FROM t -> WITH t AS (SELECT 1 AS [1]) SELECT * FROM t", () => {
    validateIdentity("WITH t AS (SELECT 1) SELECT * FROM t", "WITH t AS (SELECT 1 AS [1]) SELECT * FROM t");
  });
  it('WITH t AS (SELECT "c") SELECT * FROM t -> WITH t AS (SELECT [c] AS [c]) SELECT * FROM t', () => {
    validateIdentity('WITH t AS (SELECT "c") SELECT * FROM t', "WITH t AS (SELECT [c] AS [c]) SELECT * FROM t");
  });
  it("SELECT * FROM (SELECT 1) AS subq -> SELECT * FROM (SELECT 1 AS [1]) AS subq", () => {
    validateIdentity("SELECT * FROM (SELECT 1) AS subq", "SELECT * FROM (SELECT 1 AS [1]) AS subq");
  });
  it('SELECT * FROM (SELECT "c") AS subq -> SELECT * FROM (SELECT [c] AS [c]) AS subq', () => {
    validateIdentity('SELECT * FROM (SELECT "c") AS subq', "SELECT * FROM (SELECT [c] AS [c]) AS subq");
  });
  it("duckdb -> tsql: WITH t1(c) AS (SELECT 1), t2 AS (SELECT CAST(c AS INTEGER) FROM t1) SEL...", () => {
    const result = transpile("WITH t1(c) AS (SELECT 1), t2 AS (SELECT CAST(c AS INTEGER) FROM t1) SELECT * FROM t2", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH t1(c) AS (SELECT 1), t2 AS (SELECT CAST(c AS INTEGER) AS c FROM t1) SELECT * FROM t2");
  });
});

describe("Tsql: declare", () => {
  it.todo("DECLARE @X INT (command not supported)");
  it.todo("DECLARE @X INT = 1 (command not supported)");
  it.todo("DECLARE @X INT, @Y VARCHAR(10) (command not supported)");
  it.todo("declare @X int = (select col from table where id = 1) (command not supported)");
  it.todo("declare @X TABLE (Id INT NOT NULL, Name VARCHAR(100) NOT NULL) (command not supported)");
  it.todo("declare @X TABLE (Id INT NOT NULL, constraint PK_Id primary key (Id)) (command not supported)");
  it.todo("declare @X UserDefinedTableType (command not supported)");
  it.todo("DECLARE @MyTableVar TABLE (EmpID INT NOT NULL, PRIMARY KEY CLUSTERE... (check_command_warning)");
  it.todo("DECLARE vendor_cursor CURSOR FOR SELECT VendorID, Name FROM Purchas... (check_command_warning)");
});

describe("Tsql: scope_resolution_op", () => {
  it.todo("x::int (unsupported syntax)");
  it.todo("x::varchar (unsupported syntax)");
  it.todo("x::varchar(MAX) (unsupported syntax)");
});

describe("Tsql: count", () => {
  it.todo("test_count: assertEqual call");
  it.todo("test_count: assertEqual call (2)");
  it("duckdb -> tsql: SELECT COUNT(1) FROM x", () => {
    const result = transpile("SELECT COUNT(1) FROM x", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT COUNT_BIG(1) FROM x");
  });
  it("spark -> tsql: SELECT COUNT(1) FROM x", () => {
    const result = transpile("SELECT COUNT(1) FROM x", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT COUNT_BIG(1) FROM x");
  });
  it.todo("tsql -> duckdb: SELECT COUNT_BIG(1) FROM x (cross-dialect transform)");
  it.todo("tsql -> spark: SELECT COUNT_BIG(1) FROM x (cross-dialect transform)");
  it("tsql -> tsql: SELECT COUNT_BIG(1) FROM x", () => {
    const result = transpile("SELECT COUNT_BIG(1) FROM x", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT COUNT_BIG(1) FROM x");
  });
  it("tsql -> duckdb: SELECT COUNT(1) FROM x", () => {
    const result = transpile("SELECT COUNT(1) FROM x", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COUNT(1) FROM x");
  });
  it("tsql -> spark: SELECT COUNT(1) FROM x", () => {
    const result = transpile("SELECT COUNT(1) FROM x", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT COUNT(1) FROM x");
  });
  it("tsql -> tsql: SELECT COUNT(1) FROM x", () => {
    const result = transpile("SELECT COUNT(1) FROM x", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT COUNT(1) FROM x");
  });
});

describe("Tsql: grant", () => {
  it.todo("GRANT EXECUTE ON TestProc TO User2 (command not supported)");
  it.todo("GRANT EXECUTE ON TestProc TO TesterRole WITH GRANT OPTION (command not supported)");
  it.todo("GRANT EXECUTE ON TestProc TO User2 AS TesterRole (check_command_warning)");
});

describe("Tsql: revoke", () => {
  it.todo("REVOKE EXECUTE ON TestProc FROM User2 (command not supported)");
  it.todo("REVOKE EXECUTE ON TestProc FROM TesterRole (command not supported)");
});

describe("Tsql: parsename", () => {
  it.todo("test_parsename: unresolvable read dict");
  it.todo("test_parsename: unresolvable read dict (2)");
  it.todo("test_parsename: unresolvable read dict (3)");
  it.todo("test_parsename: unresolvable read dict (4)");
  it.todo("SELECT SPLIT_PART('1,2,3', ',', 1) (UnsupportedError in write)");
  it.todo("WITH t AS (SELECT 'a.b.c' AS value, 1 AS idx) SELECT SPLIT_PART(val... (UnsupportedError in write)");
});

describe("Tsql: next_value_for", () => {
  it("SELECT NEXT VALUE FOR db.schema.sequence_name OVER (ORDER BY foo), col", () => {
    validateIdentity("SELECT NEXT VALUE FOR db.schema.sequence_name OVER (ORDER BY foo), col");
  });
  it("oracle -> tsql: SELECT NEXT VALUE FOR db.schema.sequence_name", () => {
    const result = transpile("SELECT NEXT VALUE FOR db.schema.sequence_name", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT NEXT VALUE FOR db.schema.sequence_name");
  });
  it("tsql -> tsql: SELECT NEXT VALUE FOR db.schema.sequence_name", () => {
    const result = transpile("SELECT NEXT VALUE FOR db.schema.sequence_name", { readDialect: "tsql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT NEXT VALUE FOR db.schema.sequence_name");
  });
  it("tsql -> oracle: SELECT NEXT VALUE FOR db.schema.sequence_name", () => {
    const result = transpile("SELECT NEXT VALUE FOR db.schema.sequence_name", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT NEXT VALUE FOR db.schema.sequence_name");
  });
});

describe("Tsql: datetrunc", () => {
  it.todo("tsql -> duckdb: SELECT DATETRUNC(month, 'foo') (unsupported syntax)");
  it("tsql -> tsql: SELECT DATETRUNC(month, 'foo')", () => {
    const result = transpile("SELECT DATETRUNC(month, 'foo')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATETRUNC(MONTH, CAST('foo' AS DATETIME2))");
  });
  it.todo("tsql -> duckdb: SELECT DATETRUNC(month, foo) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATETRUNC(month, foo)", () => {
    const result = transpile("SELECT DATETRUNC(month, foo)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATETRUNC(MONTH, foo)");
  });
  it.todo("tsql -> duckdb: SELECT DATETRUNC(year, CAST('foo1' AS date)) (cross-dialect transform)");
  it("tsql -> tsql: SELECT DATETRUNC(year, CAST('foo1' AS date))", () => {
    const result = transpile("SELECT DATETRUNC(year, CAST('foo1' AS date))", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT DATETRUNC(YEAR, CAST('foo1' AS DATE))");
  });
});

describe("Tsql: numeric_trunc", () => {
  it.todo("ROUND(3.14159, 2, 1) (DDL/DML in read/write)");
});

describe("Tsql: procedures", () => {
  it.todo("SELECT 1; SELECT 2 (assert_is check)");
  it.todo("test_procedures: unresolvable for-loop iterable");
  it.todo("EXEC sp_executesql @payload (assert_is check)");
  it("IF ((@x = @y AND GETDATE() = GETDATE()) OR (GETDATE() = @t)) BEGIN SET @query_result = ...", () => {
    validateIdentity("IF ((@x = @y AND GETDATE() = GETDATE()) OR (GETDATE() = @t)) BEGIN SET @query_result = (SELECT MAX(id) + 1 FROM t); END", "IF (@x = @y AND GETDATE() = GETDATE()) OR (GETDATE() = @t) BEGIN SET @query_result = (SELECT MAX(id) + 1 FROM t); END");
  });
});
