// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "bigquery";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Bigquery: bigquery", () => {
  it.todo("test_bigquery: assertIsInstance call");
  it.todo("test_bigquery: assertTrue call");
  it.todo("test_bigquery: assertEqual call");
  it.todo("test_bigquery: assertIsInstance call (2)");
  it.todo("test_bigquery: assertTrue call (2)");
  it.todo("test_bigquery: assertEqual call (2)");
  it.todo("test_bigquery: assertIsInstance call (3)");
  it.todo("test_bigquery: assertTrue call (3)");
  it.todo("test_bigquery: assertEqual call (3)");
  it.todo("test_bigquery: assertEqual call (4)");
  it.todo("test_bigquery: assertEqual call (5)");
  it.todo("test_bigquery: assertEqual call (6)");
  it.todo("test_bigquery: assertEqual call (7)");
  it.todo("test_bigquery: assertEqual call (8)");
  it.todo("SAFE.SOME_RANDOM_FUNC(a, b, c) (assert_is check)");
  it.todo("TIMESTAMP(foo, zone) (assert_is check)");
  it("SELECT * FROM x-0.y", () => {
    validateIdentity("SELECT * FROM x-0.y");
  });
  it.todo("test_bigquery: assertEqual call (9)");
  it.todo("test_bigquery: assertEqual call (10)");
  it.todo("test_bigquery: assertEqual call (11)");
  it.todo("test_bigquery: assertEqual call (12)");
  it.todo("test_bigquery: assertEqual call (13)");
  it.todo("test_bigquery: assertEqual call (14)");
  it.todo("test_bigquery: assertEqual call (15)");
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it("ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x) LIMIT 2)", () => {
    validateIdentity("ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x) LIMIT 2)");
  });
  it("ARRAY_CONCAT_AGG(x LIMIT 2)", () => {
    validateIdentity("ARRAY_CONCAT_AGG(x LIMIT 2)");
  });
  it("ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x))", () => {
    validateIdentity("ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x))");
  });
  it("ARRAY_CONCAT_AGG(x)", () => {
    validateIdentity("ARRAY_CONCAT_AGG(x)");
  });
  it("PARSE_TIMESTAMP('%FT%H:%M:%E*S%z', x)", () => {
    validateIdentity("PARSE_TIMESTAMP('%FT%H:%M:%E*S%z', x)");
  });
  it("SELECT ARRAY_CONCAT([1])", () => {
    validateIdentity("SELECT ARRAY_CONCAT([1])");
  });
  it("SELECT * FROM READ_CSV('bla.csv')", () => {
    validateIdentity("SELECT * FROM READ_CSV('bla.csv')");
  });
  it("CAST(x AS STRUCT<list ARRAY<INT64>>)", () => {
    validateIdentity("CAST(x AS STRUCT<list ARRAY<INT64>>)");
  });
  it("assert.true(1 = 1)", () => {
    validateIdentity("assert.true(1 = 1)");
  });
  it("SELECT jsondoc['some_key']", () => {
    validateIdentity("SELECT jsondoc['some_key']");
  });
  it("SELECT `p.d.UdF`(data).* FROM `p.d.t`", () => {
    validateIdentity("SELECT `p.d.UdF`(data).* FROM `p.d.t`");
  });
  it("SELECT * FROM `my-project.my-dataset.my-table`", () => {
    validateIdentity("SELECT * FROM `my-project.my-dataset.my-table`");
  });
  it.todo("CREATE OR REPLACE TABLE `a.b.c` CLONE `a.b.d` (DDL/DML not supported)");
  it("SELECT x, 1 AS y GROUP BY 1 ORDER BY 1", () => {
    validateIdentity("SELECT x, 1 AS y GROUP BY 1 ORDER BY 1");
  });
  it("SELECT * FROM x.*", () => {
    validateIdentity("SELECT * FROM x.*");
  });
  it("SELECT * FROM x.y*", () => {
    validateIdentity("SELECT * FROM x.y*");
  });
  it.todo("CASE A WHEN 90 THEN 'red' WHEN 50 THEN 'blue' ELSE 'green' END (unsupported syntax)");
  it.todo("CREATE SCHEMA x DEFAULT COLLATE 'en' (DDL/DML not supported)");
  it.todo("CREATE TABLE x (y INT64) DEFAULT COLLATE 'en' (DDL/DML not supported)");
  it("PARSE_JSON('{}', wide_number_mode => 'exact')", () => {
    validateIdentity("PARSE_JSON('{}', wide_number_mode => 'exact')");
  });
  it("FOO(values)", () => {
    validateIdentity("FOO(values)");
  });
  it("STRUCT(values AS value)", () => {
    validateIdentity("STRUCT(values AS value)");
  });
  it("SELECT SEARCH(data_to_search, 'search_query')", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query')");
  });
  it("SELECT SEARCH(data_to_search, 'search_query', json_scope => 'JSON_KEYS_AND_VALUES')", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query', json_scope => 'JSON_KEYS_AND_VALUES')");
  });
  it("SELECT SEARCH(data_to_search, 'search_query', analyzer => 'PATTERN_ANALYZER')", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query', analyzer => 'PATTERN_ANALYZER')");
  });
  it("SELECT SEARCH(data_to_search, 'search_query', analyzer_options => 'analyzer_options_val...", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query', analyzer_options => 'analyzer_options_values')");
  });
  it("SELECT SEARCH(data_to_search, 'search_query', json_scope => 'JSON_VALUES', analyzer => ...", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query', json_scope => 'JSON_VALUES', analyzer => 'LOG_ANALYZER')");
  });
  it("SELECT SEARCH(data_to_search, 'search_query', analyzer => 'PATTERN_ANALYZER', analyzer_...", () => {
    validateIdentity("SELECT SEARCH(data_to_search, 'search_query', analyzer => 'PATTERN_ANALYZER', analyzer_options => 'options')");
  });
  it("ARRAY_AGG(x IGNORE NULLS LIMIT 1)", () => {
    validateIdentity("ARRAY_AGG(x IGNORE NULLS LIMIT 1)");
  });
  it("ARRAY_AGG(x IGNORE NULLS ORDER BY x LIMIT 1)", () => {
    validateIdentity("ARRAY_AGG(x IGNORE NULLS ORDER BY x LIMIT 1)");
  });
  it("ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY x LIMIT 1)", () => {
    validateIdentity("ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY x LIMIT 1)");
  });
  it("ARRAY_AGG(x IGNORE NULLS)", () => {
    validateIdentity("ARRAY_AGG(x IGNORE NULLS)");
  });
  it("ARRAY_AGG(DISTINCT x IGNORE NULLS HAVING MAX x ORDER BY x LIMIT 1)", () => {
    validateIdentity("ARRAY_AGG(DISTINCT x IGNORE NULLS HAVING MAX x ORDER BY x LIMIT 1)");
  });
  it.todo("SELECT * FROM dataset.my_table TABLESAMPLE SYSTEM (10 PERCENT) (unsupported clause)");
  it("TIME('2008-12-25 15:30:00+08')", () => {
    validateIdentity("TIME('2008-12-25 15:30:00+08')");
  });
  it("TIME('2008-12-25 15:30:00+08', 'America/Los_Angeles')", () => {
    validateIdentity("TIME('2008-12-25 15:30:00+08', 'America/Los_Angeles')");
  });
  it("SELECT '\\n\\r\\a\\v\\f\\t'", () => {
    validateIdentity("SELECT '\\n\\r\\a\\v\\f\\t'");
  });
  it("SELECT * FROM tbl FOR SYSTEM_TIME AS OF z", () => {
    validateIdentity("SELECT * FROM tbl FOR SYSTEM_TIME AS OF z");
  });
  it("SELECT PARSE_TIMESTAMP('%c', 'Thu Dec 25 07:30:00 2008', 'UTC')", () => {
    validateIdentity("SELECT PARSE_TIMESTAMP('%c', 'Thu Dec 25 07:30:00 2008', 'UTC')");
  });
  it("SELECT ANY_VALUE(fruit HAVING MAX sold) FROM fruits", () => {
    validateIdentity("SELECT ANY_VALUE(fruit HAVING MAX sold) FROM fruits");
  });
  it("SELECT ANY_VALUE(fruit HAVING MIN sold) FROM fruits", () => {
    validateIdentity("SELECT ANY_VALUE(fruit HAVING MIN sold) FROM fruits");
  });
  it("bigquery -> bigquery: SELECT ANY_VALUE(fruit HAVING MAX sold) FROM Store", () => {
    const result = transpile("SELECT ANY_VALUE(fruit HAVING MAX sold) FROM Store", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ANY_VALUE(fruit HAVING MAX sold) FROM Store");
  });
  it.todo("bigquery -> duckdb: SELECT ANY_VALUE(fruit HAVING MAX sold) FROM Store (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT ANY_VALUE(fruit HAVING MIN sold) FROM Store", () => {
    const result = transpile("SELECT ANY_VALUE(fruit HAVING MIN sold) FROM Store", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ANY_VALUE(fruit HAVING MIN sold) FROM Store");
  });
  it.todo("bigquery -> duckdb: SELECT ANY_VALUE(fruit HAVING MIN sold) FROM Store (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT category, ANY_VALUE(product HAVING MAX price), ANY_VALUE(p...", () => {
    const result = transpile("SELECT category, ANY_VALUE(product HAVING MAX price), ANY_VALUE(product HAVING MIN cost), ANY_VALUE(supplier) FROM products GROUP BY category", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT category, ANY_VALUE(product HAVING MAX price), ANY_VALUE(product HAVING MIN cost), ANY_VALUE(supplier) FROM products GROUP BY category");
  });
  it.todo("bigquery -> duckdb: SELECT category, ANY_VALUE(product HAVING MAX price), ANY_VALUE(pro... (cross-dialect transform)");
  it.todo('bigquery -> duckdb: WITH data AS (SELECT "A" AS fruit, 20 AS sold UNION ALL SELECT NULL... (cross-dialect transform)');
  it("SELECT `project-id`.udfs.func(call.dir)", () => {
    validateIdentity("SELECT `project-id`.udfs.func(call.dir)");
  });
  it("SELECT CAST(CURRENT_DATE AS STRING FORMAT 'DAY') AS current_day", () => {
    validateIdentity("SELECT CAST(CURRENT_DATE AS STRING FORMAT 'DAY') AS current_day");
  });
  it("SAFE_CAST(encrypted_value AS STRING FORMAT 'BASE64')", () => {
    validateIdentity("SAFE_CAST(encrypted_value AS STRING FORMAT 'BASE64')");
  });
  it("CAST(encrypted_value AS STRING FORMAT 'BASE64')", () => {
    validateIdentity("CAST(encrypted_value AS STRING FORMAT 'BASE64')");
  });
  it("DATE(2016, 12, 25)", () => {
    validateIdentity("DATE(2016, 12, 25)");
  });
  it("DATE(CAST('2016-12-25 23:59:59' AS DATETIME))", () => {
    validateIdentity("DATE(CAST('2016-12-25 23:59:59' AS DATETIME))");
  });
  it("SELECT foo IN UNNEST(bar) AS bla", () => {
    validateIdentity("SELECT foo IN UNNEST(bar) AS bla");
  });
  it("SELECT * FROM x-0.a", () => {
    validateIdentity("SELECT * FROM x-0.a");
  });
  it.todo("SELECT * FROM pivot CROSS JOIN foo (unsupported clause)");
  it("SAFE_CAST(x AS STRING)", () => {
    validateIdentity("SAFE_CAST(x AS STRING)");
  });
  it("SELECT * FROM a-b-c.mydataset.mytable", () => {
    validateIdentity("SELECT * FROM a-b-c.mydataset.mytable");
  });
  it("SELECT * FROM abc-def-ghi", () => {
    validateIdentity("SELECT * FROM abc-def-ghi");
  });
  it("SELECT * FROM a-b-c", () => {
    validateIdentity("SELECT * FROM a-b-c");
  });
  it("SELECT * FROM my-table", () => {
    validateIdentity("SELECT * FROM my-table");
  });
  it("SELECT * FROM my-project.mydataset.mytable", () => {
    validateIdentity("SELECT * FROM my-project.mydataset.mytable");
  });
  it("SELECT * FROM pro-ject_id.c.d CROSS JOIN foo-bar", () => {
    validateIdentity("SELECT * FROM pro-ject_id.c.d CROSS JOIN foo-bar");
  });
  it("SELECT * FROM foo.bar.25 -> SELECT * FROM foo.bar.`25`", () => {
    validateIdentity("SELECT * FROM foo.bar.25", "SELECT * FROM foo.bar.`25`");
  });
  it("SELECT * FROM foo.bar.25_ -> SELECT * FROM foo.bar.`25_`", () => {
    validateIdentity("SELECT * FROM foo.bar.25_", "SELECT * FROM foo.bar.`25_`");
  });
  it("SELECT * FROM foo.bar.25x a -> SELECT * FROM foo.bar.`25x` AS a", () => {
    validateIdentity("SELECT * FROM foo.bar.25x a", "SELECT * FROM foo.bar.`25x` AS a");
  });
  it("SELECT * FROM foo.bar.25ab c -> SELECT * FROM foo.bar.`25ab` AS c", () => {
    validateIdentity("SELECT * FROM foo.bar.25ab c", "SELECT * FROM foo.bar.`25ab` AS c");
  });
  it("x <> ''", () => {
    validateIdentity("x <> ''");
  });
  it("DATE_TRUNC(col, WEEK(MONDAY))", () => {
    validateIdentity("DATE_TRUNC(col, WEEK(MONDAY))");
  });
  it("DATE_TRUNC(col, MONTH, 'UTC+8')", () => {
    validateIdentity("DATE_TRUNC(col, MONTH, 'UTC+8')");
  });
  it("SELECT b'abc'", () => {
    validateIdentity("SELECT b'abc'");
  });
  it("SELECT AS STRUCT 1 AS a, 2 AS b", () => {
    validateIdentity("SELECT AS STRUCT 1 AS a, 2 AS b");
  });
  it("SELECT DISTINCT AS STRUCT 1 AS a, 2 AS b", () => {
    validateIdentity("SELECT DISTINCT AS STRUCT 1 AS a, 2 AS b");
  });
  it("SELECT AS VALUE STRUCT(1 AS a, 2 AS b)", () => {
    validateIdentity("SELECT AS VALUE STRUCT(1 AS a, 2 AS b)");
  });
  it.todo("SELECT * FROM q UNPIVOT(values FOR quarter IN (b, c)) (unsupported clause)");
  it.todo("CREATE TABLE x (a STRUCT<values ARRAY<INT64>>) (DDL/DML not supported)");
  it.todo("CREATE TABLE x (a STRUCT<b STRING OPTIONS (description='b')>) (DDL/DML not supported)");
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax)");
  it.todo("BEGIN DECLARE y INT64 (check_command_warning)");
  it.todo("LOOP SET x = x + 1 (check_command_warning)");
  it.todo("REPEAT SET x = x + 1 (check_command_warning)");
  it("SELECT MAKE_INTERVAL(100, 11, 1, 12, 30, 10)", () => {
    validateIdentity("SELECT MAKE_INTERVAL(100, 11, 1, 12, 30, 10)");
  });
  it.todo("WHILE i < ARRAY_LENGTH(batches) DO SET x = batches[OFFSET(i)] (check_command_warning)");
  it.todo("BEGIN TRANSACTION (command not supported)");
  it.todo("COMMIT TRANSACTION (command not supported)");
  it.todo("ROLLBACK TRANSACTION (command not supported)");
  it("CAST(x AS BIGNUMERIC)", () => {
    validateIdentity("CAST(x AS BIGNUMERIC)");
  });
  it("SELECT y + 1 FROM x GROUP BY y + 1 ORDER BY 1", () => {
    validateIdentity("SELECT y + 1 FROM x GROUP BY y + 1 ORDER BY 1");
  });
  it("SELECT TIMESTAMP_SECONDS(2) AS t", () => {
    validateIdentity("SELECT TIMESTAMP_SECONDS(2) AS t");
  });
  it("SELECT TIMESTAMP_MILLIS(2) AS t", () => {
    validateIdentity("SELECT TIMESTAMP_MILLIS(2) AS t");
  });
  it.todo("UPDATE x SET y = NULL (DDL/DML not supported)");
  it("LOG(n, b)", () => {
    validateIdentity("LOG(n, b)");
  });
  it("SELECT COUNT(x RESPECT NULLS)", () => {
    validateIdentity("SELECT COUNT(x RESPECT NULLS)");
  });
  it("SELECT LAST_VALUE(x IGNORE NULLS) OVER y AS x", () => {
    validateIdentity("SELECT LAST_VALUE(x IGNORE NULLS) OVER y AS x");
  });
  it.todo("SELECT ARRAY((SELECT AS STRUCT 1 AS a, 2 AS b)) (unsupported syntax)");
  it.todo("SELECT ARRAY((SELECT AS STRUCT 1 AS a, 2 AS b) LIMIT 10) (unsupported syntax)");
  it("CAST(x AS CHAR) -> CAST(x AS STRING)", () => {
    validateIdentity("CAST(x AS CHAR)", "CAST(x AS STRING)");
  });
  it("CAST(x AS NCHAR) -> CAST(x AS STRING)", () => {
    validateIdentity("CAST(x AS NCHAR)", "CAST(x AS STRING)");
  });
  it("CAST(x AS NVARCHAR) -> CAST(x AS STRING)", () => {
    validateIdentity("CAST(x AS NVARCHAR)", "CAST(x AS STRING)");
  });
  it.todo("CAST(x AS TIMESTAMPTZ) (unsupported syntax)");
  it("CAST(x AS RECORD) -> CAST(x AS STRUCT)", () => {
    validateIdentity("CAST(x AS RECORD)", "CAST(x AS STRUCT)");
  });
  it("SELECT * FROM x WHERE x.y >= (SELECT MAX(a) FROM b-c) - 20", () => {
    validateIdentity("SELECT * FROM x WHERE x.y >= (SELECT MAX(a) FROM b-c) - 20");
  });
  it.todo("SELECT FORMAT_TIMESTAMP('%F %T', CURRENT_TIMESTAMP(), 'Europe/Berli... (unsupported syntax)");
  it.todo("SELECT cars, apples FROM some_table PIVOT(SUM(total_counts) FOR pro... (unsupported clause)");
  it.todo("MERGE INTO dataset.NewArrivals USING (SELECT * FROM UNNEST([('micro... (DDL/DML not supported)");
  it.todo("SELECT * FROM test QUALIFY a IS DISTINCT FROM b WINDOW c AS (PARTIT... (unsupported clause)");
  it("FOR record IN (SELECT word, word_count FROM bigquery-public-data.samples.shakespeare LI...", () => {
    validateIdentity("FOR record IN (SELECT word, word_count FROM bigquery-public-data.samples.shakespeare LIMIT 5) DO SELECT record.word, record.word_count");
  });
  it("DATE(CAST('2016-12-25 05:30:00+07' AS DATETIME), 'America/Los_Angeles')", () => {
    validateIdentity("DATE(CAST('2016-12-25 05:30:00+07' AS DATETIME), 'America/Los_Angeles')");
  });
  it.todo("CREATE TABLE x (a STRING OPTIONS (description='x')) OPTIONS (table_... (DDL/DML not supported)");
  it.todo("SELECT * FROM (SELECT * FROM `t`) AS a UNPIVOT((c) FOR c_name IN (v... (unsupported clause)");
  it.todo("CREATE TABLE IF NOT EXISTS foo AS SELECT * FROM bla EXCEPT DISTINCT... (DDL/DML not supported)");
  it.todo("SELECT ROW() OVER (y ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM... (unsupported clause)");
  it.todo("SELECT item, purchases, LAST_VALUE(item) OVER (item_window ROWS BET... (unsupported clause)");
  it.todo("SELECT LAST_VALUE(a IGNORE NULLS) OVER y FROM x WINDOW y AS (PARTIT... (unsupported syntax)");
  it.todo("CREATE OR REPLACE VIEW test (tenant_id OPTIONS (description='Test d... (DDL/DML not supported)");
  it.todo(`SELECT b"\\x0a$'x'00" (unsupported syntax)`);
  it("--c\nARRAY_AGG(v IGNORE NULLS) -> ARRAY_AGG(v IGNORE NULLS) /* c */", () => {
    validateIdentity("--c\nARRAY_AGG(v IGNORE NULLS)", "ARRAY_AGG(v IGNORE NULLS) /* c */");
  });
  it("SELECT * FROM t1, t2 -> SELECT * FROM t1 CROSS JOIN t2", () => {
    validateIdentity("SELECT * FROM t1, t2", "SELECT * FROM t1 CROSS JOIN t2");
  });
  it(`SELECT r"\\t" -> SELECT '\\\\t'`, () => {
    validateIdentity('SELECT r"\\t"', "SELECT '\\\\t'");
  });
  it.todo("ARRAY(SELECT AS STRUCT e.x AS y, e.z AS bla FROM UNNEST(bob))::ARRA... (unsupported syntax)");
  it("SELECT * FROM `proj.dataset.INFORMATION_SCHEMA.SOME_VIEW` -> SELECT * FROM `proj.datase...", () => {
    validateIdentity("SELECT * FROM `proj.dataset.INFORMATION_SCHEMA.SOME_VIEW`", "SELECT * FROM `proj.dataset.INFORMATION_SCHEMA.SOME_VIEW` AS `proj.dataset.INFORMATION_SCHEMA.SOME_VIEW`");
  });
  it("SELECT * FROM region_or_dataset.INFORMATION_SCHEMA.TABLES -> SELECT * FROM region_or_da...", () => {
    validateIdentity("SELECT * FROM region_or_dataset.INFORMATION_SCHEMA.TABLES", "SELECT * FROM region_or_dataset.`INFORMATION_SCHEMA.TABLES` AS TABLES");
  });
  it("SELECT * FROM region_or_dataset.INFORMATION_SCHEMA.TABLES AS some_name -> SELECT * FROM...", () => {
    validateIdentity("SELECT * FROM region_or_dataset.INFORMATION_SCHEMA.TABLES AS some_name", "SELECT * FROM region_or_dataset.`INFORMATION_SCHEMA.TABLES` AS some_name");
  });
  it("SELECT * FROM proj.region_or_dataset.INFORMATION_SCHEMA.TABLES -> SELECT * FROM proj.re...", () => {
    validateIdentity("SELECT * FROM proj.region_or_dataset.INFORMATION_SCHEMA.TABLES", "SELECT * FROM proj.region_or_dataset.`INFORMATION_SCHEMA.TABLES` AS TABLES");
  });
  it.todo("CREATE VIEW `d.v` OPTIONS (expiration_timestamp=TIMESTAMP '2020-01-... (DDL/DML not supported)");
  it.todo("SELECT ARRAY(SELECT AS STRUCT 1 a, 2 b) (unsupported syntax)");
  it("select array_contains([1, 2, 3], 1) -> SELECT EXISTS(SELECT 1 FROM UNNEST([1, 2, 3]) AS...", () => {
    validateIdentity("select array_contains([1, 2, 3], 1)", "SELECT EXISTS(SELECT 1 FROM UNNEST([1, 2, 3]) AS _col WHERE _col = 1)");
  });
  it("SELECT SPLIT(foo) -> SELECT SPLIT(foo, ',')", () => {
    validateIdentity("SELECT SPLIT(foo)", "SELECT SPLIT(foo, ',')");
  });
  it("SELECT 1 AS hash -> SELECT 1 AS `hash`", () => {
    validateIdentity("SELECT 1 AS hash", "SELECT 1 AS `hash`");
  });
  it("SELECT 1 AS at -> SELECT 1 AS `at`", () => {
    validateIdentity("SELECT 1 AS at", "SELECT 1 AS `at`");
  });
  it(`x <> "" -> x <> ''`, () => {
    validateIdentity('x <> ""', "x <> ''");
  });
  it(`x <> """""" -> x <> ''`, () => {
    validateIdentity('x <> """"""', "x <> ''");
  });
  it.todo("x <> '''''' (unsupported syntax)");
  it.todo("SELECT a overlaps (unsupported syntax)");
  it("SELECT y + 1 z FROM x GROUP BY y + 1 ORDER BY z -> SELECT y + 1 AS z FROM x GROUP BY z ...", () => {
    validateIdentity("SELECT y + 1 z FROM x GROUP BY y + 1 ORDER BY z", "SELECT y + 1 AS z FROM x GROUP BY z ORDER BY z");
  });
  it("SELECT y + 1 z FROM x GROUP BY y + 1 -> SELECT y + 1 AS z FROM x GROUP BY y + 1", () => {
    validateIdentity("SELECT y + 1 z FROM x GROUP BY y + 1", "SELECT y + 1 AS z FROM x GROUP BY y + 1");
  });
  it(`SELECT JSON '"foo"' AS json_data -> SELECT PARSE_JSON('"foo"') AS json_data`, () => {
    validateIdentity(`SELECT JSON '"foo"' AS json_data`, `SELECT PARSE_JSON('"foo"') AS json_data`);
  });
  it.todo("SELECT * FROM (SELECT a, b, c FROM test) PIVOT(SUM(b) d, COUNT(*) e... (unsupported clause)");
  it("SELECT CAST(1 AS BYTEINT) -> SELECT CAST(1 AS INT64)", () => {
    validateIdentity("SELECT CAST(1 AS BYTEINT)", "SELECT CAST(1 AS INT64)");
  });
  it.todo("CREATE TEMPORARY FUNCTION FOO()\nRETURNS STRING\nLANGUAGE js AS\n'retu... (pretty=True not supported)");
  it.todo("[a, a(1, 2,3,4444444444444444, tttttaoeunthaoentuhaoentuheoantu, to... (pretty=True not supported)");
  it("bigquery -> bigquery: SELECT TRUE IS TRUE", () => {
    const result = transpile("SELECT TRUE IS TRUE", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TRUE IS TRUE");
  });
  it("bigquery -> snowflake: SELECT TRUE IS TRUE", () => {
    const result = transpile("SELECT TRUE IS TRUE", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRUE");
  });
  it("hive -> bigquery: SELECT SPACE(2)", () => {
    const result = transpile("SELECT SPACE(2)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REPEAT(' ', 2)");
  });
  it("spark -> bigquery: SELECT SPACE(2)", () => {
    const result = transpile("SELECT SPACE(2)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REPEAT(' ', 2)");
  });
  it("databricks -> bigquery: SELECT SPACE(2)", () => {
    const result = transpile("SELECT SPACE(2)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REPEAT(' ', 2)");
  });
  it("trino -> bigquery: SELECT REPEAT(' ', 2)", () => {
    const result = transpile("SELECT REPEAT(' ', 2)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REPEAT(' ', 2)");
  });
  it.todo("SELECT purchases, LAST_VALUE(item) OVER item_window AS most_popular... (unsupported clause)");
  it("bigquery -> bigquery: SELECT DATE(2024, 1, 15)", () => {
    const result = transpile("SELECT DATE(2024, 1, 15)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE(2024, 1, 15)");
  });
  it("bigquery -> duckdb: SELECT DATE(2024, 1, 15)", () => {
    const result = transpile("SELECT DATE(2024, 1, 15)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_DATE(2024, 1, 15)");
  });
  it("bigquery -> bigquery: EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", () => {
    const result = transpile("EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))");
  });
  it("bigquery -> duckdb: EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", () => {
    const result = transpile("EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EXTRACT(HOUR FROM MAKE_TIMESTAMP(2008, 12, 25, 15, 30, 00))");
  });
  it("bigquery -> snowflake: EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", () => {
    const result = transpile("EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_PART(HOUR, TIMESTAMP_FROM_PARTS(2008, 12, 25, 15, 30, 00))");
  });
  it("bigquery -> bigquery: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 AS a, 'abc' AS b), STRUCT(str_col AS abc)");
  });
  it("bigquery -> duckdb: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_co...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT {'_0': 1, '_1': 2, '_2': 3}, {}, {'_0': 'abc'}, {'_0': 1, 'str_col': t.str_col}, {'a': 1, 'b': 'abc'}, {'abc': str_col}");
  });
  it("bigquery -> hive: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col)...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1, 'abc'), STRUCT(str_col)");
  });
  it("bigquery -> spark2: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_co...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 AS a, 'abc' AS b), STRUCT(str_col AS abc)");
  });
  it("bigquery -> spark: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 AS a, 'abc' AS b), STRUCT(str_col AS abc)");
  });
  it("bigquery -> snowflake: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str...", () => {
    const result = transpile("SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 as a, 'abc' AS b), STRUCT(str_col AS abc)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT OBJECT_CONSTRUCT('_0', 1, '_1', 2, '_2', 3), OBJECT_CONSTRUCT(), OBJECT_CONSTRUCT('_0', 'abc'), OBJECT_CONSTRUCT('_0', 1, '_1', t.str_col), OBJECT_CONSTRUCT('a', 1, 'b', 'abc'), OBJECT_CONSTRUCT('abc', str_col)");
  });
  it.todo("bigquery -> trino: SELECT STRUCT(1, 2, 3), STRUCT(), STRUCT('abc'), STRUCT(1, t.str_col... (unsupported syntax)");
  it("bigquery -> bigquery: PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", () => {
    const result = transpile("PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_TIMESTAMP('%FT%H:%M:%E6S%z', x)");
  });
  it("bigquery -> duckdb: PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", () => {
    const result = transpile("PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRPTIME(x, '%Y-%m-%dT%H:%M:%S.%f%z')");
  });
  it.todo("SELECT DATE_SUB(CURRENT_DATE(), INTERVAL 2 DAY) (unsupported syntax)");
  it.todo("SELECT DATE_SUB(DATE '2008-12-25', INTERVAL 5 DAY) (unsupported syntax)");
  it.todo("EDIT_DISTANCE(col1, col2, max_distance => 3) (UnsupportedError in write)");
  it("bigquery -> bigquery: EDIT_DISTANCE(a, b)", () => {
    const result = transpile("EDIT_DISTANCE(a, b)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("EDIT_DISTANCE(a, b)");
  });
  it("bigquery -> duckdb: EDIT_DISTANCE(a, b)", () => {
    const result = transpile("EDIT_DISTANCE(a, b)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LEVENSHTEIN(a, b)");
  });
  it("bigquery -> bigquery: SAFE_CAST(some_date AS DATE FORMAT 'DD MONTH YYYY')", () => {
    const result = transpile("SAFE_CAST(some_date AS DATE FORMAT 'DD MONTH YYYY')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SAFE_CAST(some_date AS DATE FORMAT 'DD MONTH YYYY')");
  });
  it("bigquery -> duckdb: SAFE_CAST(some_date AS DATE FORMAT 'DD MONTH YYYY')", () => {
    const result = transpile("SAFE_CAST(some_date AS DATE FORMAT 'DD MONTH YYYY')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(TRY_STRPTIME(some_date, '%d %B %Y') AS DATE)");
  });
  it("bigquery -> bigquery: SAFE_CAST(some_date AS DATE FORMAT 'YYYY-MM-DD') AS some_date", () => {
    const result = transpile("SAFE_CAST(some_date AS DATE FORMAT 'YYYY-MM-DD') AS some_date", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SAFE_CAST(some_date AS DATE FORMAT 'YYYY-MM-DD') AS some_date");
  });
  it("bigquery -> duckdb: SAFE_CAST(some_date AS DATE FORMAT 'YYYY-MM-DD') AS some_date", () => {
    const result = transpile("SAFE_CAST(some_date AS DATE FORMAT 'YYYY-MM-DD') AS some_date", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(TRY_STRPTIME(some_date, '%Y-%m-%d') AS DATE) AS some_date");
  });
  it("bigquery -> bigquery: SAFE_CAST(x AS TIMESTAMP)", () => {
    const result = transpile("SAFE_CAST(x AS TIMESTAMP)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SAFE_CAST(x AS TIMESTAMP)");
  });
  it.todo("bigquery -> snowflake: SAFE_CAST(x AS TIMESTAMP) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT t.c1, h.c2, s.c3 FROM t1 AS t, UNNEST(t.t2) AS h, UNNEST(h...", () => {
    const result = transpile("SELECT t.c1, h.c2, s.c3 FROM t1 AS t, UNNEST(t.t2) AS h, UNNEST(h.t3) AS s", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT t.c1, h.c2, s.c3 FROM t1 AS t CROSS JOIN UNNEST(t.t2) AS h CROSS JOIN UNNEST(h.t3) AS s");
  });
  it.todo("bigquery -> duckdb: SELECT t.c1, h.c2, s.c3 FROM t1 AS t, UNNEST(t.t2) AS h, UNNEST(h.t... (cross-dialect transform)");
  it("bigquery -> bigquery: PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x) (2)", () => {
    const result = transpile("PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_TIMESTAMP('%FT%H:%M:%E6S%z', x)");
  });
  it("bigquery -> duckdb: PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x) (2)", () => {
    const result = transpile("PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E6S%z', x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRPTIME(x, '%Y-%m-%dT%H:%M:%S.%f%z')");
  });
  it("bigquery -> bigquery: SELECT results FROM Coordinates, Coordinates.position AS results", () => {
    const result = transpile("SELECT results FROM Coordinates, Coordinates.position AS results", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT results FROM Coordinates CROSS JOIN UNNEST(Coordinates.position) AS results");
  });
  it.todo("bigquery -> presto: SELECT results FROM Coordinates, Coordinates.position AS results (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT results FROM Coordinates, `Coordinates.position` AS results", () => {
    const result = transpile("SELECT results FROM Coordinates, `Coordinates.position` AS results", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT results FROM Coordinates CROSS JOIN `Coordinates.position` AS results");
  });
  it("bigquery -> presto: SELECT results FROM Coordinates, `Coordinates.position` AS results", () => {
    const result = transpile("SELECT results FROM Coordinates, `Coordinates.position` AS results", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe('SELECT results FROM Coordinates CROSS JOIN "Coordinates"."position" AS results');
  });
  it.todo("presto -> bigquery: SELECT results FROM Coordinates AS c, UNNEST(c.position) AS _t(resu... (cross-dialect transform)");
  it("redshift -> bigquery: SELECT results FROM Coordinates AS c, c.position AS results", () => {
    const result = transpile("SELECT results FROM Coordinates AS c, c.position AS results", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT results FROM Coordinates AS c, UNNEST(c.position) AS results");
  });
  it("bigquery -> bigquery: SELECT results FROM Coordinates AS c, UNNEST(c.position) AS results", () => {
    const result = transpile("SELECT results FROM Coordinates AS c, UNNEST(c.position) AS results", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT results FROM Coordinates AS c CROSS JOIN UNNEST(c.position) AS results");
  });
  it.todo("bigquery -> presto: SELECT results FROM Coordinates AS c, UNNEST(c.position) AS results (cross-dialect transform)");
  it.todo("bigquery -> redshift: SELECT results FROM Coordinates AS c, UNNEST(c.position) AS results (cross-dialect transform)");
  it("bigquery -> bigquery: TIMESTAMP(x)", () => {
    const result = transpile("TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TIMESTAMP(x)");
  });
  it.todo("bigquery -> duckdb: TIMESTAMP(x) (unsupported syntax)");
  it.todo("bigquery -> snowflake: TIMESTAMP(x) (unsupported syntax)");
  it("bigquery -> presto: TIMESTAMP(x)", () => {
    const result = transpile("TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS TIMESTAMP WITH TIME ZONE)");
  });
  it("bigquery -> bigquery: SELECT TIMESTAMP('2008-12-25 15:30:00', 'America/Los_Angeles')", () => {
    const result = transpile("SELECT TIMESTAMP('2008-12-25 15:30:00', 'America/Los_Angeles')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIMESTAMP('2008-12-25 15:30:00', 'America/Los_Angeles')");
  });
  it.todo("bigquery -> duckdb: SELECT TIMESTAMP('2008-12-25 15:30:00', 'America/Los_Angeles') (unsupported syntax)");
  it.todo("bigquery -> snowflake: SELECT TIMESTAMP('2008-12-25 15:30:00', 'America/Los_Angeles') (unsupported syntax)");
  it.todo("SELECT SUM(x IGNORE NULLS) AS x (UnsupportedError in write)");
  it.todo("SELECT SUM(x RESPECT NULLS) AS x (UnsupportedError in write)");
  it("bigquery -> bigquery: SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", () => {
    const result = transpile("SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()");
  });
  it("bigquery -> duckdb: SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", () => {
    const result = transpile("SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT QUANTILE_CONT(x, 0.5) OVER ()");
  });
  it("bigquery -> spark: SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", () => {
    const result = transpile("SELECT PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER ()", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT PERCENTILE_CONT(x, 0.5) RESPECT NULLS OVER ()");
  });
  it("bigquery -> bigquery: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT...", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 10) AS x", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 10) AS x");
  });
  it.todo("bigquery -> duckdb: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1... (unsupported syntax)");
  it("bigquery -> spark: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 10...", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 10) AS x", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT COLLECT_LIST(DISTINCT x ORDER BY a, b DESC LIMIT 10) IGNORE NULLS AS x");
  });
  it("bigquery -> bigquery: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT... (2)", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1, 10) AS x", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1, 10) AS x");
  });
  it.todo("bigquery -> duckdb: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1... (2) (unsupported syntax)");
  it("bigquery -> spark: SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1,...", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT x IGNORE NULLS ORDER BY a, b DESC LIMIT 1, 10) AS x", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT COLLECT_LIST(DISTINCT x ORDER BY a, b DESC LIMIT 1, 10) IGNORE NULLS AS x");
  });
  it.todo("SELECT * FROM Produce UNPIVOT((first_half_sales, second_half_sales)... (unsupported clause)");
  it.todo("SELECT * FROM Produce UNPIVOT((first_half_sales, second_half_sales)... (unsupported clause) (2)");
  it.todo("SELECT UNIX_DATE(DATE '2008-12-25') (unsupported syntax)");
  it("snowflake -> bigquery: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONS)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONS)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)");
  });
  it("bigquery -> bigquery: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)");
  });
  it("bigquery -> duckdb: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> clickhouse: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS Nullable(DATE)))");
  });
  it("bigquery -> mysql: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> oracle: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it.todo("bigquery -> postgres: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH) (unsupported syntax)");
  it("bigquery -> presto: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> redshift: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> snowflake: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)");
  });
  it("bigquery -> spark: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> tsql: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT EOMONTH(CAST('2008-11-25' AS DATE))");
  });
  it("snowflake -> bigquery: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)");
  });
  it("bigquery -> bigquery: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)");
  });
  it("bigquery -> snowflake: SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE), QUARTER)");
  });
  it.todo(" -> bigquery: x::timestamp (unsupported syntax)");
  it("duckdb -> bigquery: SELECT MAKE_TIME(15, 30, 00)", () => {
    const result = transpile("SELECT MAKE_TIME(15, 30, 00)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIME(15, 30, 00)");
  });
  it("mysql -> bigquery: SELECT MAKETIME(15, 30, 00)", () => {
    const result = transpile("SELECT MAKETIME(15, 30, 00)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIME(15, 30, 00)");
  });
  it("postgres -> bigquery: SELECT MAKE_TIME(15, 30, 00)", () => {
    const result = transpile("SELECT MAKE_TIME(15, 30, 00)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIME(15, 30, 00)");
  });
  it("snowflake -> bigquery: SELECT TIME_FROM_PARTS(15, 30, 00)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(15, 30, 00)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIME(15, 30, 00)");
  });
  it("bigquery -> bigquery: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIME(15, 30, 00)");
  });
  it("bigquery -> duckdb: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_TIME(15, 30, 00)");
  });
  it("bigquery -> mysql: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT MAKETIME(15, 30, 00)");
  });
  it("bigquery -> postgres: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT MAKE_TIME(15, 30, 00)");
  });
  it("bigquery -> snowflake: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIME_FROM_PARTS(15, 30, 00)");
  });
  it("bigquery -> tsql: SELECT TIME(15, 30, 00)", () => {
    const result = transpile("SELECT TIME(15, 30, 00)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT TIMEFROMPARTS(15, 30, 00, 0, 0)");
  });
  it("bigquery -> bigquery: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIME('2008-12-25 15:30:00')");
  });
  it("bigquery -> duckdb: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('2008-12-25 15:30:00' AS TIME)");
  });
  it("bigquery -> mysql: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT CAST('2008-12-25 15:30:00' AS TIME)");
  });
  it("bigquery -> postgres: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT CAST('2008-12-25 15:30:00' AS TIME)");
  });
  it("bigquery -> redshift: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT CAST('2008-12-25 15:30:00' AS TIME)");
  });
  it.todo("bigquery -> spark: SELECT TIME('2008-12-25 15:30:00') (unsupported syntax)");
  it("bigquery -> tsql: SELECT TIME('2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT TIME('2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT CAST('2008-12-25 15:30:00' AS TIME)");
  });
  it("clickhouse -> bigquery: SELECT countIf(x)", () => {
    const result = transpile("SELECT countIf(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT COUNTIF(x)");
  });
  it("duckdb -> bigquery: SELECT COUNT_IF(x)", () => {
    const result = transpile("SELECT COUNT_IF(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT COUNTIF(x)");
  });
  it("bigquery -> bigquery: SELECT COUNTIF(x)", () => {
    const result = transpile("SELECT COUNTIF(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT COUNTIF(x)");
  });
  it("bigquery -> clickhouse: SELECT COUNTIF(x)", () => {
    const result = transpile("SELECT COUNTIF(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT countIf(x)");
  });
  it("bigquery -> duckdb: SELECT COUNTIF(x)", () => {
    const result = transpile("SELECT COUNTIF(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COUNT_IF(x)");
  });
  it("bigquery -> bigquery: SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(0)...", () => {
    const result = transpile("SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(0), minute)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(0), MINUTE)");
  });
  it.todo("bigquery -> databricks: SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(... (cross-dialect transform)");
  it.todo("bigquery -> duckdb: SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(0), ... (cross-dialect transform)");
  it.todo("bigquery -> snowflake: SELECT TIMESTAMP_DIFF(TIMESTAMP_SECONDS(60), TIMESTAMP_SECONDS(0... (cross-dialect transform)");
  it("bigquery -> bigquery: TIMESTAMP_DIFF(a, b, month)", () => {
    const result = transpile("TIMESTAMP_DIFF(a, b, month)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("TIMESTAMP_DIFF(a, b, MONTH)");
  });
  it("databricks -> bigquery: TIMESTAMPDIFF(month, b, a)", () => {
    const result = transpile("TIMESTAMPDIFF(month, b, a)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("TIMESTAMP_DIFF(a, b, MONTH)");
  });
  it("mysql -> bigquery: TIMESTAMPDIFF(month, b, a)", () => {
    const result = transpile("TIMESTAMPDIFF(month, b, a)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("TIMESTAMP_DIFF(a, b, MONTH)");
  });
  it("bigquery -> databricks: TIMESTAMP_DIFF(a, b, MONTH)", () => {
    const result = transpile("TIMESTAMP_DIFF(a, b, MONTH)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TIMESTAMPDIFF(MONTH, b, a)");
  });
  it("bigquery -> mysql: TIMESTAMP_DIFF(a, b, MONTH)", () => {
    const result = transpile("TIMESTAMP_DIFF(a, b, MONTH)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("TIMESTAMPDIFF(MONTH, b, a)");
  });
  it("bigquery -> snowflake: TIMESTAMP_DIFF(a, b, MONTH)", () => {
    const result = transpile("TIMESTAMP_DIFF(a, b, MONTH)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TIMESTAMPDIFF(MONTH, b, a)");
  });
  it("duckdb -> bigquery: SELECT MAKE_TIMESTAMP(x)", () => {
    const result = transpile("SELECT MAKE_TIMESTAMP(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMP_MICROS(x)");
  });
  it("spark -> bigquery: SELECT TIMESTAMP_MICROS(x)", () => {
    const result = transpile("SELECT TIMESTAMP_MICROS(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMP_MICROS(x)");
  });
  it("bigquery -> bigquery: SELECT TIMESTAMP_MICROS(x)", () => {
    const result = transpile("SELECT TIMESTAMP_MICROS(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIMESTAMP_MICROS(x)");
  });
  it("bigquery -> duckdb: SELECT TIMESTAMP_MICROS(x)", () => {
    const result = transpile("SELECT TIMESTAMP_MICROS(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_TIMESTAMP(x)");
  });
  it.todo("bigquery -> snowflake: SELECT TIMESTAMP_MICROS(x) (cross-dialect transform)");
  it("bigquery -> spark: SELECT TIMESTAMP_MICROS(x)", () => {
    const result = transpile("SELECT TIMESTAMP_MICROS(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT TIMESTAMP_MICROS(x)");
  });
  it("bigquery -> bigquery: SELECT * FROM t WHERE EXISTS(SELECT * FROM unnest(nums) AS x WHER...", () => {
    const result = transpile("SELECT * FROM t WHERE EXISTS(SELECT * FROM unnest(nums) AS x WHERE x > 1)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM t WHERE EXISTS(SELECT * FROM UNNEST(nums) AS x WHERE x > 1)");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM t WHERE EXISTS(SELECT * FROM unnest(nums) AS x WHERE ... (cross-dialect transform)");
  it("duckdb -> bigquery: NULL = a", () => {
    const result = transpile("NULL = a", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("NULL");
  });
  it("postgres -> bigquery: a = NULL", () => {
    const result = transpile("a = NULL", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("NULL");
  });
  it.todo("SELECT '\\n' (unsupported syntax)");
  it("snowflake -> bigquery: TRIM(item, '*')", () => {
    const result = transpile("TRIM(item, '*')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("TRIM(item, '*')");
  });
  it("spark -> bigquery: TRIM('*', item)", () => {
    const result = transpile("TRIM('*', item)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("TRIM(item, '*')");
  });
  it("bigquery -> bigquery: TRIM(item, '*')", () => {
    const result = transpile("TRIM(item, '*')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TRIM(item, '*')");
  });
  it("bigquery -> snowflake: TRIM(item, '*')", () => {
    const result = transpile("TRIM(item, '*')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRIM(item, '*')");
  });
  it.todo("bigquery -> spark: TRIM(item, '*') (unsupported syntax)");
  it.todo("test_bigquery: assertEqual call (16)");
  it.todo("test_bigquery: assertEqual call (17)");
  it.todo("CREATE OR REPLACE TABLE `a.b.c` COPY `a.b.d` (DDL/DML not supported)");
  it("sqlite -> bigquery: MIN(x, y)", () => {
    const result = transpile("MIN(x, y)", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("LEAST(x, y)");
  });
  it.todo('bigquery -> bigquery: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL... (unsupported syntax)');
  it.todo('bigquery -> databricks: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERV... (unsupported syntax)');
  it.todo('bigquery -> duckdb: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 1... (unsupported syntax)');
  it.todo('bigquery -> mysql: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10... (unsupported syntax)');
  it.todo('bigquery -> spark: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10... (unsupported syntax)');
  it.todo('bigquery -> snowflake: SELECT TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVA... (unsupported syntax)');
  it.todo('bigquery -> bigquery: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL... (unsupported syntax)');
  it.todo('bigquery -> duckdb: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 1... (unsupported syntax)');
  it.todo('bigquery -> mysql: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10... (unsupported syntax)');
  it.todo('bigquery -> snowflake: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVA... (unsupported syntax)');
  it.todo('bigquery -> spark: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10... (unsupported syntax)');
  it.todo('bigquery -> bigquery: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL... (2) (unsupported syntax)');
  it.todo('bigquery -> snowflake: SELECT TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVA... (2) (unsupported syntax)');
  it.todo("bigquery -> bigquery: SELECT TIME_ADD(CAST('09:05:03' AS TIME), INTERVAL 2 HOUR) (unsupported syntax)");
  it.todo("bigquery -> duckdb: SELECT TIME_ADD(CAST('09:05:03' AS TIME), INTERVAL 2 HOUR) (unsupported syntax)");
  it.todo("bigquery -> bigquery: SELECT TIME_SUB(CAST('09:05:03' AS TIME), INTERVAL 2 HOUR) (unsupported syntax)");
  it.todo("bigquery -> duckdb: SELECT TIME_SUB(CAST('09:05:03' AS TIME), INTERVAL 2 HOUR) (unsupported syntax)");
  it.todo("test_bigquery: assertEqual call (18)");
  it.todo("test_bigquery: assertEqual call (19)");
  it("bigquery -> : LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> bigquery: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("bigquery -> clickhouse: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> duckdb: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> hive: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> mysql: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> spark: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> sqlite: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> presto: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("LOWER(TO_HEX(x))");
  });
  it("bigquery -> trino: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("LOWER(TO_HEX(x))");
  });
  it(" -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("clickhouse -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("duckdb -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("hive -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("mysql -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("spark -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("sqlite -> bigquery: LOWER(HEX(x))", () => {
    const result = transpile("LOWER(HEX(x))", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("presto -> bigquery: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("trino -> bigquery: LOWER(TO_HEX(x))", () => {
    const result = transpile("LOWER(TO_HEX(x))", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("bigquery -> : TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> bigquery: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("bigquery -> clickhouse: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> duckdb: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> hive: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> mysql: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> presto: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("LOWER(TO_HEX(x))");
  });
  it("bigquery -> spark: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> sqlite: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("LOWER(HEX(x))");
  });
  it("bigquery -> trino: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("LOWER(TO_HEX(x))");
  });
  it.todo("test_bigquery: assertEqual call (20)");
  it.todo("test_bigquery: assertEqual call (21)");
  it(" -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("clickhouse -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("duckdb -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("hive -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("mysql -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("presto -> bigquery: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("spark -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("sqlite -> bigquery: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("trino -> bigquery: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("bigquery -> : UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> bigquery: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("UPPER(TO_HEX(x))");
  });
  it("bigquery -> clickhouse: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> duckdb: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> hive: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> mysql: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> presto: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("bigquery -> spark: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> sqlite: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("bigquery -> trino: UPPER(TO_HEX(x))", () => {
    const result = transpile("UPPER(TO_HEX(x))", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("clickhouse -> bigquery: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("MD5(x)");
  });
  it("presto -> bigquery: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("MD5(x)");
  });
  it("trino -> bigquery: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("MD5(x)");
  });
  it("bigquery -> : MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("MD5_DIGEST(x)");
  });
  it("bigquery -> bigquery: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("MD5(x)");
  });
  it("bigquery -> clickhouse: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("MD5(x)");
  });
  it("bigquery -> hive: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("UNHEX(MD5(x))");
  });
  it("bigquery -> presto: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("MD5(x)");
  });
  it("bigquery -> spark: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UNHEX(MD5(x))");
  });
  it("bigquery -> trino: MD5(x)", () => {
    const result = transpile("MD5(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("MD5(x)");
  });
  it("duckdb -> bigquery: SELECT MD5(some_string)", () => {
    const result = transpile("SELECT MD5(some_string)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("spark -> bigquery: SELECT MD5(some_string)", () => {
    const result = transpile("SELECT MD5(some_string)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("clickhouse -> bigquery: SELECT LOWER(HEX(MD5(some_string)))", () => {
    const result = transpile("SELECT LOWER(HEX(MD5(some_string)))", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("presto -> bigquery: SELECT LOWER(TO_HEX(MD5(some_string)))", () => {
    const result = transpile("SELECT LOWER(TO_HEX(MD5(some_string)))", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("trino -> bigquery: SELECT LOWER(TO_HEX(MD5(some_string)))", () => {
    const result = transpile("SELECT LOWER(TO_HEX(MD5(some_string)))", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("bigquery -> : SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT MD5(some_string)");
  });
  it("bigquery -> bigquery: SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TO_HEX(MD5(some_string))");
  });
  it("bigquery -> duckdb: SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MD5(some_string)");
  });
  it("bigquery -> clickhouse: SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT LOWER(HEX(MD5(some_string)))");
  });
  it("bigquery -> presto: SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT LOWER(TO_HEX(MD5(some_string)))");
  });
  it("bigquery -> trino: SELECT TO_HEX(MD5(some_string))", () => {
    const result = transpile("SELECT TO_HEX(MD5(some_string))", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT LOWER(TO_HEX(MD5(some_string)))");
  });
  it("bigquery -> bigquery: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("clickhouse -> bigquery: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("presto -> bigquery: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("trino -> bigquery: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("bigquery -> clickhouse: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("bigquery -> bigquery: SHA1(x) (2)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("bigquery -> presto: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("bigquery -> trino: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("bigquery -> duckdb: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("UNHEX(SHA1(x))");
  });
  it("clickhouse -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("presto -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("trino -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("postgres -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("duckdb -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> bigquery: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> spark2: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SHA2(x, 256)");
  });
  it("bigquery -> clickhouse: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> postgres: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> presto: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> redshift: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SHA2(x, 256)");
  });
  it("bigquery -> trino: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("bigquery -> duckdb: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("UNHEX(SHA256(x))");
  });
  it("bigquery -> snowflake: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SHA2_BINARY(x, 256)");
  });
  it("clickhouse -> bigquery: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("presto -> bigquery: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("trino -> bigquery: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("bigquery -> clickhouse: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("bigquery -> bigquery: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("bigquery -> spark2: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SHA2(x, 512)");
  });
  it("bigquery -> presto: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("bigquery -> trino: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it.todo("SELECT CAST('20201225' AS TIMESTAMP FORMAT 'YYYYMMDD' AT TIME ZONE ... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT CAST('20201225' AS TIMESTAMP FORMAT 'YYYYMMDD')", () => {
    const result = transpile("SELECT CAST('20201225' AS TIMESTAMP FORMAT 'YYYYMMDD')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT PARSE_TIMESTAMP('%Y%m%d', '20201225')");
  });
  it.todo("SELECT CAST(TIMESTAMP '2008-12-25 00:00:00+00:00' AS STRING FORMAT ... (unsupported syntax)");
  it.todo("SELECT CAST(TIMESTAMP '2008-12-25 00:00:00+00:00' AS STRING FORMAT ... (unsupported syntax) (2)");
  it.todo("WITH cte AS (SELECT [1, 2, 3] AS arr) SELECT IF(pos = pos_2, col, N... (unsupported syntax)");
  it.todo("SELECT IF(pos = pos_2, col, NULL) AS col FROM UNNEST(GENERATE_ARRAY... (unsupported syntax)");
  it.todo("SELECT IF(pos = pos_2, col, NULL) AS col, IF(pos = pos_2, pos_2, NU... (unsupported syntax)");
  it.todo("SELECT AS STRUCT ARRAY(SELECT AS STRUCT 1 AS b FROM x) AS y FROM z (unsupported syntax)");
  it("bigquery -> bigquery: SELECT CAST(STRUCT(1) AS STRUCT<INT64>)", () => {
    const result = transpile("SELECT CAST(STRUCT(1) AS STRUCT<INT64>)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(STRUCT(1) AS STRUCT<INT64>)");
  });
  it("bigquery -> snowflake: SELECT CAST(STRUCT(1) AS STRUCT<INT64>)", () => {
    const result = transpile("SELECT CAST(STRUCT(1) AS STRUCT<INT64>)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST(OBJECT_CONSTRUCT('_0', 1) AS OBJECT)");
  });
  it("bigquery -> bigquery: cast(x as date format 'MM/DD/YYYY')", () => {
    const result = transpile("cast(x as date format 'MM/DD/YYYY')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_DATE('%m/%d/%Y', x)");
  });
  it("bigquery -> bigquery: cast(x as time format 'YYYY.MM.DD HH:MI:SSTZH')", () => {
    const result = transpile("cast(x as time format 'YYYY.MM.DD HH:MI:SSTZH')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_TIMESTAMP('%Y.%m.%d %I:%M:%S%z', x)");
  });
  it.todo("CREATE TEMP TABLE foo AS SELECT 1 (DDL/DML not supported)");
  it("bigquery -> bigquery: REGEXP_CONTAINS('foo', '.*')", () => {
    const result = transpile("REGEXP_CONTAINS('foo', '.*')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_CONTAINS('foo', '.*')");
  });
  it("mysql -> bigquery: REGEXP_LIKE('foo', '.*')", () => {
    const result = transpile("REGEXP_LIKE('foo', '.*')", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_CONTAINS('foo', '.*')");
  });
  it("starrocks -> bigquery: REGEXP('foo', '.*')", () => {
    const result = transpile("REGEXP('foo', '.*')", { readDialect: "starrocks", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_CONTAINS('foo', '.*')");
  });
  it("bigquery -> mysql: REGEXP_CONTAINS('foo', '.*')", () => {
    const result = transpile("REGEXP_CONTAINS('foo', '.*')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("REGEXP_LIKE('foo', '.*')");
  });
  it("bigquery -> starrocks: REGEXP_CONTAINS('foo', '.*')", () => {
    const result = transpile("REGEXP_CONTAINS('foo', '.*')", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("REGEXP('foo', '.*')");
  });
  it('bigquery -> bigquery: """x"""', () => {
    const result = transpile('"""x"""', { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'x'");
  });
  it('bigquery -> duckdb: """x"""', () => {
    const result = transpile('"""x"""', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'x'");
  });
  it('bigquery -> presto: """x"""', () => {
    const result = transpile('"""x"""', { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'x'");
  });
  it('bigquery -> hive: """x"""', () => {
    const result = transpile('"""x"""', { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'x'");
  });
  it('bigquery -> spark: """x"""', () => {
    const result = transpile('"""x"""', { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'x'");
  });
  it(`bigquery -> bigquery: """x'"""`, () => {
    const result = transpile(`"""x'"""`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'x\\''");
  });
  it.todo(`bigquery -> duckdb: """x'""" (unsupported syntax)`);
  it.todo(`bigquery -> presto: """x'""" (unsupported syntax)`);
  it(`bigquery -> hive: """x'"""`, () => {
    const result = transpile(`"""x'"""`, { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'x\\''");
  });
  it(`bigquery -> spark: """x'"""`, () => {
    const result = transpile(`"""x'"""`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'x\\''");
  });
  it("bigquery -> bigquery: r'x\\''", () => {
    const result = transpile("r'x\\''", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'x\\''");
  });
  it("bigquery -> hive: r'x\\''", () => {
    const result = transpile("r'x\\''", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'x\\''");
  });
  it("bigquery -> bigquery: r'x\\y'", () => {
    const result = transpile("r'x\\y'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'x\\\\y'");
  });
  it("bigquery -> hive: r'x\\y'", () => {
    const result = transpile("r'x\\y'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'x\\\\y'");
  });
  it("bigquery -> bigquery: '\\\\'", () => {
    const result = transpile("'\\\\'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'\\\\'");
  });
  it("bigquery -> duckdb: '\\\\'", () => {
    const result = transpile("'\\\\'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'\\'");
  });
  it("bigquery -> presto: '\\\\'", () => {
    const result = transpile("'\\\\'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'\\'");
  });
  it("bigquery -> hive: '\\\\'", () => {
    const result = transpile("'\\\\'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'\\\\'");
  });
  it('bigquery -> bigquery: r"""/\\*.*\\*/"""', () => {
    const result = transpile('r"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it('bigquery -> duckdb: r"""/\\*.*\\*/"""', () => {
    const result = transpile('r"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'/\\*.*\\*/'");
  });
  it('bigquery -> presto: r"""/\\*.*\\*/"""', () => {
    const result = transpile('r"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'/\\*.*\\*/'");
  });
  it('bigquery -> hive: r"""/\\*.*\\*/"""', () => {
    const result = transpile('r"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it('bigquery -> spark: r"""/\\*.*\\*/"""', () => {
    const result = transpile('r"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it('bigquery -> bigquery: R"""/\\*.*\\*/"""', () => {
    const result = transpile('R"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it('bigquery -> duckdb: R"""/\\*.*\\*/"""', () => {
    const result = transpile('R"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'/\\*.*\\*/'");
  });
  it('bigquery -> presto: R"""/\\*.*\\*/"""', () => {
    const result = transpile('R"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'/\\*.*\\*/'");
  });
  it('bigquery -> hive: R"""/\\*.*\\*/"""', () => {
    const result = transpile('R"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it('bigquery -> spark: R"""/\\*.*\\*/"""', () => {
    const result = transpile('R"""/\\*.*\\*/"""', { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'/\\\\*.*\\\\*/'");
  });
  it.todo('bigquery -> bigquery: r"""a\n""" (unsupported syntax)');
  it('bigquery -> duckdb: r"""a\n"""', () => {
    const result = transpile('r"""a\n"""', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'a\n'");
  });
  it.todo('bigquery -> bigquery: """a\n""" (unsupported syntax)');
  it('bigquery -> duckdb: """a\n"""', () => {
    const result = transpile('"""a\n"""', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'a\n'");
  });
  it("bigquery -> bigquery: CAST(a AS INT64)", () => {
    const result = transpile("CAST(a AS INT64)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(a AS INT64)");
  });
  it("bigquery -> duckdb: CAST(a AS INT64)", () => {
    const result = transpile("CAST(a AS INT64)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(a AS BIGINT)");
  });
  it("bigquery -> presto: CAST(a AS INT64)", () => {
    const result = transpile("CAST(a AS INT64)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(a AS BIGINT)");
  });
  it("bigquery -> hive: CAST(a AS INT64)", () => {
    const result = transpile("CAST(a AS INT64)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(a AS BIGINT)");
  });
  it("bigquery -> spark: CAST(a AS INT64)", () => {
    const result = transpile("CAST(a AS INT64)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(a AS BIGINT)");
  });
  it("bigquery -> bigquery: CAST(a AS BYTES)", () => {
    const result = transpile("CAST(a AS BYTES)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(a AS BYTES)");
  });
  it("bigquery -> duckdb: CAST(a AS BYTES)", () => {
    const result = transpile("CAST(a AS BYTES)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(a AS BLOB)");
  });
  it("bigquery -> presto: CAST(a AS BYTES)", () => {
    const result = transpile("CAST(a AS BYTES)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(a AS VARBINARY)");
  });
  it("bigquery -> hive: CAST(a AS BYTES)", () => {
    const result = transpile("CAST(a AS BYTES)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(a AS BINARY)");
  });
  it("bigquery -> spark: CAST(a AS BYTES)", () => {
    const result = transpile("CAST(a AS BYTES)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(a AS BINARY)");
  });
  it.todo("test_bigquery: assertEqual call (22)");
  it.todo("test_bigquery: assertEqual call (23)");
  it("bigquery -> bigquery: CAST(a AS NUMERIC)", () => {
    const result = transpile("CAST(a AS NUMERIC)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(a AS NUMERIC)");
  });
  it("bigquery -> duckdb: CAST(a AS NUMERIC)", () => {
    const result = transpile("CAST(a AS NUMERIC)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(a AS DECIMAL)");
  });
  it("bigquery -> presto: CAST(a AS NUMERIC)", () => {
    const result = transpile("CAST(a AS NUMERIC)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(a AS DECIMAL)");
  });
  it("bigquery -> hive: CAST(a AS NUMERIC)", () => {
    const result = transpile("CAST(a AS NUMERIC)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(a AS DECIMAL)");
  });
  it("bigquery -> spark: CAST(a AS NUMERIC)", () => {
    const result = transpile("CAST(a AS NUMERIC)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(a AS DECIMAL)");
  });
  it("duckdb -> bigquery: [1, 2, 3]", () => {
    const result = transpile("[1, 2, 3]", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("[1, 2, 3]");
  });
  it.todo("presto -> bigquery: ARRAY[1, 2, 3] (unsupported syntax)");
  it.todo("hive -> bigquery: ARRAY(1, 2, 3) (unsupported syntax)");
  it.todo("spark -> bigquery: ARRAY(1, 2, 3) (unsupported syntax)");
  it("bigquery -> bigquery: [1, 2, 3]", () => {
    const result = transpile("[1, 2, 3]", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("[1, 2, 3]");
  });
  it("bigquery -> duckdb: [1, 2, 3]", () => {
    const result = transpile("[1, 2, 3]", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("[1, 2, 3]");
  });
  it.todo("bigquery -> presto: [1, 2, 3] (unsupported syntax)");
  it.todo("bigquery -> hive: [1, 2, 3] (unsupported syntax)");
  it.todo("bigquery -> spark: [1, 2, 3] (unsupported syntax)");
  it.todo("spark -> bigquery: SELECT * FROM UNNEST(ARRAY('7', '14')) AS (x) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST(['7', '14']) AS x", () => {
    const result = transpile("SELECT * FROM UNNEST(['7', '14']) AS x", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST(['7', '14']) AS x");
  });
  it.todo("bigquery -> presto: SELECT * FROM UNNEST(['7', '14']) AS x (unsupported syntax)");
  it.todo("bigquery -> spark: SELECT * FROM UNNEST(['7', '14']) AS x (unsupported syntax)");
  it.todo("SELECT ARRAY(SELECT x FROM UNNEST([0, 1]) AS x) (unsupported syntax)");
  it.todo("SELECT ARRAY(SELECT DISTINCT x FROM UNNEST(some_numbers) AS x) AS u... (unsupported syntax)");
  it.todo("SELECT ARRAY(SELECT * FROM foo JOIN bla ON x = y) (unsupported syntax)");
  it.todo("tsql -> bigquery: GETDATE() (cross-dialect transform)");
  it.todo("bigquery -> tsql: CURRENT_TIMESTAMP() (cross-dialect transform)");
  it("bigquery -> bigquery: current_datetime", () => {
    const result = transpile("current_datetime", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CURRENT_DATETIME()");
  });
  it("bigquery -> presto: current_datetime", () => {
    const result = transpile("current_datetime", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CURRENT_DATETIME()");
  });
  it("bigquery -> hive: current_datetime", () => {
    const result = transpile("current_datetime", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CURRENT_DATETIME()");
  });
  it("bigquery -> spark: current_datetime", () => {
    const result = transpile("current_datetime", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CURRENT_DATETIME()");
  });
  it("bigquery -> bigquery: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CURRENT_TIME()");
  });
  it("bigquery -> duckdb: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CURRENT_TIME");
  });
  it("bigquery -> presto: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CURRENT_TIME");
  });
  it("bigquery -> trino: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("CURRENT_TIME");
  });
  it("bigquery -> hive: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CURRENT_TIME()");
  });
  it("bigquery -> spark: current_time", () => {
    const result = transpile("current_time", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CURRENT_TIME()");
  });
  it("bigquery -> bigquery: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> duckdb: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> postgres: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> presto: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> hive: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> spark: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> bigquery: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> duckdb: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> postgres: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> presto: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("bigquery -> hive: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> spark: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP()");
  });
  it("bigquery -> bigquery: DIV(x, y)", () => {
    const result = transpile("DIV(x, y)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DIV(x, y)");
  });
  it.todo("bigquery -> duckdb: DIV(x, y) (cross-dialect transform)");
  it.todo("CREATE TABLE db.example_table (col_a struct<struct_col_a:int, struc... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (col_a STRUCT<struct_col_a INT64, str... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (x int) PARTITION BY x cluster by x (DDL/DML not supported)");
  it.todo("DELETE db.example_table WHERE x = 1 (DDL/DML not supported)");
  it.todo("DELETE db.example_table tb WHERE tb.x = 1 (DDL/DML not supported)");
  it.todo("DELETE db.example_table AS tb WHERE tb.x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.example_table WHERE x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.example_table tb WHERE tb.x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.example_table AS tb WHERE tb.x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.example_table AS tb WHERE example_table.x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.example_table WHERE example_table.x = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM db.t1 AS t1 WHERE NOT t1.c IN (SELECT db.t2.c FROM db.t2) (DDL/DML not supported)");
  it("bigquery -> bigquery: SELECT * FROM a WHERE b IN UNNEST([1, 2, 3])", () => {
    const result = transpile("SELECT * FROM a WHERE b IN UNNEST([1, 2, 3])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM a WHERE b IN UNNEST([1, 2, 3])");
  });
  it.todo("bigquery -> presto: SELECT * FROM a WHERE b IN UNNEST([1, 2, 3]) (unsupported syntax)");
  it.todo("bigquery -> hive: SELECT * FROM a WHERE b IN UNNEST([1, 2, 3]) (unsupported syntax)");
  it.todo("bigquery -> spark: SELECT * FROM a WHERE b IN UNNEST([1, 2, 3]) (unsupported syntax)");
  it.todo("DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) (unsupported syntax)");
  it.todo("DATE_ADD(CURRENT_DATE(), INTERVAL -1 DAY) (unsupported syntax)");
  it.todo("DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', DAY) (unsupported syntax)");
  it.todo("mysql -> bigquery: DATEDIFF(CAST('2010-07-07' AS DATE), CAST('2008-12-25' AS DATE)) (cross-dialect transform)");
  it.todo("starrocks -> bigquery: DATEDIFF(CAST('2010-07-07' AS DATE), CAST('2008-12-25' AS DATE)) (cross-dialect transform)");
  it.todo("DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', MINUTE) (unsupported syntax)");
  it("bigquery -> bigquery: DATE_DIFF('2021-01-01', '2020-01-01', DAY)", () => {
    const result = transpile("DATE_DIFF('2021-01-01', '2020-01-01', DAY)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_DIFF('2021-01-01', '2020-01-01', DAY)");
  });
  it.todo("bigquery -> duckdb: DATE_DIFF('2021-01-01', '2020-01-01', DAY) (cross-dialect transform)");
  it("bigquery -> bigquery: CURRENT_DATE('UTC')", () => {
    const result = transpile("CURRENT_DATE('UTC')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CURRENT_DATE('UTC')");
  });
  it.todo("bigquery -> duckdb: CURRENT_DATE('UTC') (unsupported syntax)");
  it.todo("bigquery -> mysql: CURRENT_DATE('UTC') (unsupported syntax)");
  it.todo("bigquery -> postgres: CURRENT_DATE('UTC') (unsupported syntax)");
  it("bigquery -> snowflake: CURRENT_DATE('UTC')", () => {
    const result = transpile("CURRENT_DATE('UTC')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CAST(CONVERT_TIMEZONE('UTC', CURRENT_TIMESTAMP()) AS DATE)");
  });
  it.todo("SELECT a FROM test WHERE a = 1 GROUP BY a HAVING a = 2 QUALIFY z OR... (unsupported clause)");
  it("bigquery -> bigquery: SELECT cola, colb FROM UNNEST([STRUCT(1 AS cola, 'test' AS colb)]...", () => {
    const result = transpile("SELECT cola, colb FROM UNNEST([STRUCT(1 AS cola, 'test' AS colb)]) as tab", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT cola, colb FROM UNNEST([STRUCT(1 AS cola, 'test' AS colb)]) AS tab");
  });
  it.todo("snowflake -> bigquery: SELECT cola, colb FROM (VALUES (1, 'test')) AS tab(cola, colb) (unsupported syntax)");
  it.todo("spark -> bigquery: SELECT cola, colb FROM VALUES (1, 'test') AS tab(cola, colb) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST([STRUCT(1 AS _c0)]) AS t1", () => {
    const result = transpile("SELECT * FROM UNNEST([STRUCT(1 AS _c0)]) AS t1", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM UNNEST([STRUCT(1 AS _c0)]) AS t1");
  });
  it.todo("postgres -> bigquery: SELECT * FROM (VALUES (1)) AS t1 (unsupported syntax)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST([STRUCT(1 AS id)]) AS t1 CROSS JOIN UNNEST([...", () => {
    const result = transpile("SELECT * FROM UNNEST([STRUCT(1 AS id)]) AS t1 CROSS JOIN UNNEST([STRUCT(1 AS id)]) AS t2", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM UNNEST([STRUCT(1 AS id)]) AS t1 CROSS JOIN UNNEST([STRUCT(1 AS id)]) AS t2");
  });
  it.todo("postgres -> bigquery: SELECT * FROM (VALUES (1)) AS t1(id) CROSS JOIN (VALUES (1)) AS t... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST([1]) WITH OFFSET", () => {
    const result = transpile("SELECT * FROM UNNEST([1]) WITH OFFSET", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST([1]) WITH OFFSET AS offset");
  });
  it("bigquery -> bigquery: SELECT * FROM UNNEST([1]) WITH OFFSET y", () => {
    const result = transpile("SELECT * FROM UNNEST([1]) WITH OFFSET y", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST([1]) WITH OFFSET AS y");
  });
  it.todo("GENERATE_ARRAY(1, 4) (unsupported syntax)");
  it("bigquery -> bigquery: TO_JSON_STRING(x)", () => {
    const result = transpile("TO_JSON_STRING(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_JSON_STRING(x)");
  });
  it("bigquery -> bigquery: TO_JSON_STRING(x) (2)", () => {
    const result = transpile("TO_JSON_STRING(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TO_JSON_STRING(x)");
  });
  it("bigquery -> duckdb: TO_JSON_STRING(x)", () => {
    const result = transpile("TO_JSON_STRING(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(TO_JSON(x) AS TEXT)");
  });
  it("bigquery -> presto: TO_JSON_STRING(x)", () => {
    const result = transpile("TO_JSON_STRING(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("JSON_FORMAT(CAST(x AS JSON))");
  });
  it("bigquery -> spark: TO_JSON_STRING(x)", () => {
    const result = transpile("TO_JSON_STRING(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TO_JSON(x)");
  });
  it.todo("SELECT\n  `u`.`user_email` AS `user_email`,\n  `d`.`user_id` AS `user... (pretty=True not supported)");
  it("postgres -> bigquery: SELECT x % 10", () => {
    const result = transpile("SELECT x % 10", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MOD(x, 10)");
  });
  it("bigquery -> bigquery: SELECT MOD(x, 10)", () => {
    const result = transpile("SELECT MOD(x, 10)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT MOD(x, 10)");
  });
  it("bigquery -> postgres: SELECT MOD(x, 10)", () => {
    const result = transpile("SELECT MOD(x, 10)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT x % 10");
  });
  it.todo("bigquery -> : SELECT CAST(x AS DATETIME) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT CAST(x AS DATETIME)", () => {
    const result = transpile("SELECT CAST(x AS DATETIME)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(x AS DATETIME)");
  });
  it.todo("bigquery -> duckdb: SELECT TIME(foo, 'America/Los_Angeles') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT TIME(foo, 'America/Los_Angeles')", () => {
    const result = transpile("SELECT TIME(foo, 'America/Los_Angeles')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIME(foo, 'America/Los_Angeles')");
  });
  it.todo("bigquery -> duckdb: SELECT DATETIME('2020-01-01') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATETIME('2020-01-01')", () => {
    const result = transpile("SELECT DATETIME('2020-01-01')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATETIME('2020-01-01')");
  });
  it.todo("SELECT DATETIME('2020-01-01', TIME '23:59:59') (unsupported syntax)");
  it.todo("bigquery -> duckdb: SELECT DATETIME('2020-01-01', 'America/Los_Angeles') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATETIME('2020-01-01', 'America/Los_Angeles')", () => {
    const result = transpile("SELECT DATETIME('2020-01-01', 'America/Los_Angeles')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATETIME('2020-01-01', 'America/Los_Angeles')");
  });
  it("bigquery -> bigquery: SELECT LENGTH(foo)", () => {
    const result = transpile("SELECT LENGTH(foo)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LENGTH(foo)");
  });
  it("snowflake -> bigquery: SELECT LENGTH(foo)", () => {
    const result = transpile("SELECT LENGTH(foo)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LENGTH(foo)");
  });
  it.todo("bigquery -> duckdb: SELECT LENGTH(foo) (cross-dialect transform)");
  it("bigquery -> snowflake: SELECT LENGTH(foo)", () => {
    const result = transpile("SELECT LENGTH(foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LENGTH(foo)");
  });
  it("bigquery -> : SELECT LENGTH(foo)", () => {
    const result = transpile("SELECT LENGTH(foo)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT LENGTH(foo)");
  });
  it.todo("bigquery -> duckdb: SELECT TIME_DIFF('12:00:00', '12:30:00', MINUTE) (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT TIME_DIFF('12:00:00', '12:30:00', MINUTE)", () => {
    const result = transpile("SELECT TIME_DIFF('12:00:00', '12:30:00', MINUTE)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TIME_DIFF('12:00:00', '12:30:00', MINUTE)");
  });
  it("bigquery -> bigquery: ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", () => {
    const result = transpile("ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("ARRAY_CONCAT([1, 2], [3, 4], [5, 6])");
  });
  it("bigquery -> duckdb: ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", () => {
    const result = transpile("ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_CONCAT([1, 2], [3, 4], [5, 6])");
  });
  it.todo("bigquery -> postgres: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> redshift: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it("bigquery -> snowflake: ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", () => {
    const result = transpile("ARRAY_CONCAT([1, 2], [3, 4], [5, 6])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CAT([1, 2], ARRAY_CAT([3, 4], [5, 6]))");
  });
  it.todo("bigquery -> hive: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> spark2: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> spark: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> databricks: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> presto: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("bigquery -> trino: ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) (unsupported syntax)");
  it.todo("SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-07 ... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008')", () => {
    const result = transpile("SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008')");
  });
  it("bigquery -> duckdb: SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008')", () => {
    const result = transpile("SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRPTIME('Thursday Dec 25 2008', '%A %b %-d %Y') AS DATE)");
  });
  it("bigquery -> bigquery: SELECT PARSE_DATE('%Y%m%d', '20081225')", () => {
    const result = transpile("SELECT PARSE_DATE('%Y%m%d', '20081225')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT PARSE_DATE('%Y%m%d', '20081225')");
  });
  it("bigquery -> duckdb: SELECT PARSE_DATE('%Y%m%d', '20081225')", () => {
    const result = transpile("SELECT PARSE_DATE('%Y%m%d', '20081225')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRPTIME('20081225', '%Y%m%d') AS DATE)");
  });
  it("bigquery -> snowflake: SELECT PARSE_DATE('%Y%m%d', '20081225')", () => {
    const result = transpile("SELECT PARSE_DATE('%Y%m%d', '20081225')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE('20081225', 'yyyymmDD')");
  });
  it("bigquery -> bigquery: SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text", () => {
    const result = transpile("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text");
  });
  it("bigquery -> duckdb: SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text", () => {
    const result = transpile("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--') AS text");
  });
  it("bigquery -> bigquery: SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS...", () => {
    const result = transpile("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS text", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS text");
  });
  it("bigquery -> duckdb: SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS text", () => {
    const result = transpile("SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS text", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARRAY_TO_STRING(LIST_TRANSFORM(['cake', 'pie', NULL], x -> COALESCE(x, 'MISSING')), '--') AS text");
  });
  it("bigquery -> bigquery: STRING(a)", () => {
    const result = transpile("STRING(a)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("STRING(a)");
  });
  it("bigquery -> snowflake: STRING(a)", () => {
    const result = transpile("STRING(a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CAST(a AS VARCHAR)");
  });
  it.todo("bigquery -> duckdb: STRING(a) (cross-dialect transform)");
  it("bigquery -> bigquery: STRING('2008-12-25 15:30:00', 'America/New_York')", () => {
    const result = transpile("STRING('2008-12-25 15:30:00', 'America/New_York')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("STRING('2008-12-25 15:30:00', 'America/New_York')");
  });
  it("bigquery -> snowflake: STRING('2008-12-25 15:30:00', 'America/New_York')", () => {
    const result = transpile("STRING('2008-12-25 15:30:00', 'America/New_York')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CAST(CONVERT_TIMEZONE('UTC', 'America/New_York', '2008-12-25 15:30:00') AS VARCHAR)");
  });
  it.todo("bigquery -> duckdb: STRING('2008-12-25 15:30:00', 'America/New_York') (unsupported syntax)");
  it("SELECT * FROM a-b c -> SELECT * FROM a-b AS c", () => {
    validateIdentity("SELECT * FROM a-b c", "SELECT * FROM a-b AS c");
  });
  it("bigquery -> bigquery: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SAFE_DIVIDE(x, y)");
  });
  it("bigquery -> duckdb: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN y <> 0 THEN x / y ELSE NULL END");
  });
  it("bigquery -> presto: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(y <> 0, CAST(x AS DOUBLE) / y, NULL)");
  });
  it("bigquery -> trino: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("IF(y <> 0, CAST(x AS DOUBLE) / y, NULL)");
  });
  it("bigquery -> hive: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF(y <> 0, x / y, NULL)");
  });
  it("bigquery -> spark2: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("IF(y <> 0, x / y, NULL)");
  });
  it("bigquery -> spark: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF(y <> 0, x / y, NULL)");
  });
  it("bigquery -> databricks: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("IF(y <> 0, x / y, NULL)");
  });
  it("bigquery -> snowflake: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF(y <> 0, x / y, NULL)");
  });
  it("bigquery -> postgres: SAFE_DIVIDE(x, y)", () => {
    const result = transpile("SAFE_DIVIDE(x, y)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CASE WHEN y <> 0 THEN CAST(x AS DOUBLE PRECISION) / y ELSE NULL END");
  });
  it("bigquery -> bigquery: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SAFE_DIVIDE(x + 1, 2 * y)");
  });
  it("bigquery -> duckdb: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN (2 * y) <> 0 THEN (x + 1) / (2 * y) ELSE NULL END");
  });
  it("bigquery -> presto: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF((2 * y) <> 0, CAST((x + 1) AS DOUBLE) / (2 * y), NULL)");
  });
  it("bigquery -> trino: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("IF((2 * y) <> 0, CAST((x + 1) AS DOUBLE) / (2 * y), NULL)");
  });
  it("bigquery -> hive: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF((2 * y) <> 0, (x + 1) / (2 * y), NULL)");
  });
  it("bigquery -> spark2: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("IF((2 * y) <> 0, (x + 1) / (2 * y), NULL)");
  });
  it("bigquery -> spark: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF((2 * y) <> 0, (x + 1) / (2 * y), NULL)");
  });
  it("bigquery -> databricks: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("IF((2 * y) <> 0, (x + 1) / (2 * y), NULL)");
  });
  it("bigquery -> snowflake: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF((2 * y) <> 0, (x + 1) / (2 * y), NULL)");
  });
  it("bigquery -> postgres: SAFE_DIVIDE(x + 1, 2 * y)", () => {
    const result = transpile("SAFE_DIVIDE(x + 1, 2 * y)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CASE WHEN (2 * y) <> 0 THEN CAST((x + 1) AS DOUBLE PRECISION) / (2 * y) ELSE NULL END");
  });
  it.todo(`SELECT JSON_VALUE_ARRAY('{"arr": [1, "a"]}', '$.arr') (unsupported syntax)`);
  it.todo("SELECT INSTR('foo@example.com', '@') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", () => {
    const result = transpile("SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ts + MAKE_INTERVAL(1, 2, day => 3, minute => 5)");
  });
  it("bigquery -> duckdb: SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", () => {
    const result = transpile("SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ts + INTERVAL '1 year 2 month 5 minute 3 day'");
  });
  it("bigquery -> snowflake: SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", () => {
    const result = transpile("SELECT ts + MAKE_INTERVAL(1, 2, minute => 5, day => 3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ts + INTERVAL '1 year, 2 month, 5 minute, 3 day'");
  });
  it(`bigquery -> bigquery: SELECT INT64(JSON_QUERY(JSON '{"key": 2000}', '$.key'))`, () => {
    const result = transpile(`SELECT INT64(JSON_QUERY(JSON '{"key": 2000}', '$.key'))`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`SELECT INT64(JSON_QUERY(PARSE_JSON('{"key": 2000}'), '$.key'))`);
  });
  it.todo(`bigquery -> duckdb: SELECT INT64(JSON_QUERY(JSON '{"key": 2000}', '$.key')) (unsupported syntax)`);
  it(`bigquery -> snowflake: SELECT INT64(JSON_QUERY(JSON '{"key": 2000}', '$.key'))`, () => {
    const result = transpile(`SELECT INT64(JSON_QUERY(JSON '{"key": 2000}', '$.key'))`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT CAST(GET_PATH(PARSE_JSON('{"key": 2000}'), 'key') AS BIGINT)`);
  });
  it("CONTAINS_SUBSTR(a, b, json_scope => 'JSON_KEYS_AND_VALUES')", () => {
    validateIdentity("CONTAINS_SUBSTR(a, b, json_scope => 'JSON_KEYS_AND_VALUES')");
  });
  it(" -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("spark -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("databricks -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("snowflake -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("duckdb -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("oracle -> bigquery: CONTAINS(a, b)", () => {
    const result = transpile("CONTAINS(a, b)", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("bigquery -> : CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> spark: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> databricks: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> snowflake: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> duckdb: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> oracle: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("CONTAINS(LOWER(a), LOWER(b))");
  });
  it("bigquery -> bigquery: CONTAINS_SUBSTR(a, b)", () => {
    const result = transpile("CONTAINS_SUBSTR(a, b)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CONTAINS_SUBSTR(a, b)");
  });
  it("EXPORT DATA OPTIONS (URI='gs://path*.csv.gz', FORMAT='CSV') AS SELECT * FROM all_rows", () => {
    validateIdentity("EXPORT DATA OPTIONS (URI='gs://path*.csv.gz', FORMAT='CSV') AS SELECT * FROM all_rows");
  });
  it("EXPORT DATA WITH CONNECTION myproject.us.myconnection OPTIONS (URI='gs://path*.csv.gz',...", () => {
    validateIdentity("EXPORT DATA WITH CONNECTION myproject.us.myconnection OPTIONS (URI='gs://path*.csv.gz', FORMAT='CSV') AS SELECT * FROM all_rows");
  });
  it.todo('duckdb -> bigquery: SELECT * FROM t1, UNNEST("t1") "t1" ("col") (cross-dialect transform)');
  it("bigquery -> bigquery: SELECT * FROM t1, UNNEST(`t1`) AS `col`", () => {
    const result = transpile("SELECT * FROM t1, UNNEST(`t1`) AS `col`", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM t1 CROSS JOIN UNNEST(`t1`) AS `col`");
  });
  it.todo("bigquery -> redshift: SELECT * FROM t1, UNNEST(`t1`) AS `col` (cross-dialect transform)");
  it.todo('duckdb -> bigquery: SELECT * FROM t, UNNEST("t1"."t2"."t3") "t1" ("col") (cross-dialect transform)');
  it("bigquery -> bigquery: SELECT * FROM t, UNNEST(`t2`.`t3`) AS `col`", () => {
    const result = transpile("SELECT * FROM t, UNNEST(`t2`.`t3`) AS `col`", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM t CROSS JOIN UNNEST(`t2`.`t3`) AS `col`");
  });
  it.todo("bigquery -> redshift: SELECT * FROM t, UNNEST(`t2`.`t3`) AS `col` (cross-dialect transform)");
  it.todo('duckdb -> bigquery: SELECT * FROM t1, UNNEST("t1"."t2"."t3"."t4") "t3" ("col") (cross-dialect transform)');
  it("bigquery -> bigquery: SELECT * FROM t1, UNNEST(`t1`.`t2`.`t3`.`t4`) AS `col`", () => {
    const result = transpile("SELECT * FROM t1, UNNEST(`t1`.`t2`.`t3`.`t4`) AS `col`", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM t1 CROSS JOIN UNNEST(`t1`.`t2`.`t3`.`t4`) AS `col`");
  });
  it.todo("bigquery -> redshift: SELECT * FROM t1, UNNEST(`t1`.`t2`.`t3`.`t4`) AS `col` (cross-dialect transform)");
  it("ARRAY_FIRST(['a', 'b'])", () => {
    validateIdentity("ARRAY_FIRST(['a', 'b'])");
  });
  it("ARRAY_LAST(['a', 'b'])", () => {
    validateIdentity("ARRAY_LAST(['a', 'b'])");
  });
  it("JSON_TYPE(PARSE_JSON('1'))", () => {
    validateIdentity("JSON_TYPE(PARSE_JSON('1'))");
  });
  it("bigquery -> bigquery: SELECT CAST(col AS STRUCT<fld1 STRUCT<fld2 INT>>).fld1.fld2", () => {
    const result = transpile("SELECT CAST(col AS STRUCT<fld1 STRUCT<fld2 INT>>).fld1.fld2", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(col AS STRUCT<fld1 STRUCT<fld2 INT64>>).fld1.fld2");
  });
  it("bigquery -> snowflake: SELECT CAST(col AS STRUCT<fld1 STRUCT<fld2 INT>>).fld1.fld2", () => {
    const result = transpile("SELECT CAST(col AS STRUCT<fld1 STRUCT<fld2 INT>>).fld1.fld2", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST(col AS OBJECT(fld1 OBJECT(fld2 INT))):fld1.fld2");
  });
  it("SELECT PARSE_DATETIME('%a %b %e %I:%M:%S %Y', 'Thu Dec 25 07:30:00 2008')", () => {
    validateIdentity("SELECT PARSE_DATETIME('%a %b %e %I:%M:%S %Y', 'Thu Dec 25 07:30:00 2008')");
  });
  it("FORMAT_TIME('%R', CAST('15:30:00' AS TIME))", () => {
    validateIdentity("FORMAT_TIME('%R', CAST('15:30:00' AS TIME))");
  });
  it("PARSE_TIME('%I:%M:%S', '07:30:00')", () => {
    validateIdentity("PARSE_TIME('%I:%M:%S', '07:30:00')");
  });
  it("BYTE_LENGTH('foo')", () => {
    validateIdentity("BYTE_LENGTH('foo')");
  });
  it("BYTE_LENGTH(b'foo')", () => {
    validateIdentity("BYTE_LENGTH(b'foo')");
  });
  it("CODE_POINTS_TO_STRING([65, 255])", () => {
    validateIdentity("CODE_POINTS_TO_STRING([65, 255])");
  });
  it("APPROX_TOP_COUNT(col, 2)", () => {
    validateIdentity("APPROX_TOP_COUNT(col, 2)");
  });
  it("ARPOX_TOP_SUM(col, 1.5, 2)", () => {
    validateIdentity("ARPOX_TOP_SUM(col, 1.5, 2)");
  });
  it("SAFE_CONVERT_BYTES_TO_STRING(b'')", () => {
    validateIdentity("SAFE_CONVERT_BYTES_TO_STRING(b'')");
  });
  it("FROM_HEX('foo')", () => {
    validateIdentity("FROM_HEX('foo')");
  });
  it("TO_CODE_POINTS('foo')", () => {
    validateIdentity("TO_CODE_POINTS('foo')");
  });
  it("CODE_POINTS_TO_BYTES([65, 98])", () => {
    validateIdentity("CODE_POINTS_TO_BYTES([65, 98])");
  });
  it("PARSE_BIGNUMERIC('1.2')", () => {
    validateIdentity("PARSE_BIGNUMERIC('1.2')");
  });
  it("PARSE_NUMERIC('1.2')", () => {
    validateIdentity("PARSE_NUMERIC('1.2')");
  });
  it("BOOL(PARSE_JSON('true'))", () => {
    validateIdentity("BOOL(PARSE_JSON('true'))");
  });
  it("FLOAT64(PARSE_JSON('9.8'))", () => {
    validateIdentity("FLOAT64(PARSE_JSON('9.8'))");
  });
  it("FLOAT64(PARSE_JSON('9.8'), wide_number_mode => 'round')", () => {
    validateIdentity("FLOAT64(PARSE_JSON('9.8'), wide_number_mode => 'round')");
  });
  it("FLOAT64(PARSE_JSON('9.8'), wide_number_mode => 'exact')", () => {
    validateIdentity("FLOAT64(PARSE_JSON('9.8'), wide_number_mode => 'exact')");
  });
  it("NORMALIZE_AND_CASEFOLD('foo')", () => {
    validateIdentity("NORMALIZE_AND_CASEFOLD('foo')");
  });
  it("NORMALIZE_AND_CASEFOLD('foo', NFKC)", () => {
    validateIdentity("NORMALIZE_AND_CASEFOLD('foo', NFKC)");
  });
  it("OCTET_LENGTH('foo') -> BYTE_LENGTH('foo')", () => {
    validateIdentity("OCTET_LENGTH('foo')", "BYTE_LENGTH('foo')");
  });
  it("OCTET_LENGTH(b'foo') -> BYTE_LENGTH(b'foo')", () => {
    validateIdentity("OCTET_LENGTH(b'foo')", "BYTE_LENGTH(b'foo')");
  });
  it(`JSON_ARRAY_APPEND(PARSE_JSON('["a", "b", "c"]'), '$', [1, 2], append_each_element => FA...`, () => {
    validateIdentity(`JSON_ARRAY_APPEND(PARSE_JSON('["a", "b", "c"]'), '$', [1, 2], append_each_element => FALSE)`);
  });
  it(`JSON_ARRAY_INSERT(PARSE_JSON('["a", "b", "c"]'), '$[1]', [1, 2], insert_each_element =>...`, () => {
    validateIdentity(`JSON_ARRAY_INSERT(PARSE_JSON('["a", "b", "c"]'), '$[1]', [1, 2], insert_each_element => FALSE)`);
  });
  it(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}'))`, () => {
    validateIdentity(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}'))`);
  });
  it(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}', 1))`, () => {
    validateIdentity(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}', 1))`);
  });
  it(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}'), 1, mode => 'lax')`, () => {
    validateIdentity(`JSON_KEYS(PARSE_JSON('{"a": {"b":1}}'), 1, mode => 'lax')`);
  });
  it(`JSON_SET(PARSE_JSON('{"a": 1}'), '$.b', 999, create_if_missing => FALSE)`, () => {
    validateIdentity(`JSON_SET(PARSE_JSON('{"a": 1}'), '$.b', 999, create_if_missing => FALSE)`);
  });
  it("JSON_STRIP_NULLS(PARSE_JSON('[1, null, 2, null, [null]]'))", () => {
    validateIdentity("JSON_STRIP_NULLS(PARSE_JSON('[1, null, 2, null, [null]]'))");
  });
  it("JSON_STRIP_NULLS(PARSE_JSON('[1, null, 2, null]'), include_arrays => FALSE)", () => {
    validateIdentity("JSON_STRIP_NULLS(PARSE_JSON('[1, null, 2, null]'), include_arrays => FALSE)");
  });
  it(`JSON_STRIP_NULLS(PARSE_JSON('{"a": {"b": {"c": null}}, "d": [null], "e": [], "f": 1}'),...`, () => {
    validateIdentity(`JSON_STRIP_NULLS(PARSE_JSON('{"a": {"b": {"c": null}}, "d": [null], "e": [], "f": 1}'), include_arrays => FALSE, remove_empty => TRUE)`);
  });
  it.todo(`JSON_EXTRACT_STRING_ARRAY(PARSE_JSON('{"fruits": ["apples", "orange... (unsupported syntax)`);
  it("TO_JSON(STRUCT(1 AS id, [10, 20] AS cords))", () => {
    validateIdentity("TO_JSON(STRUCT(1 AS id, [10, 20] AS cords))");
  });
  it("TO_JSON(9999999999, stringify_wide_numbers => FALSE)", () => {
    validateIdentity("TO_JSON(9999999999, stringify_wide_numbers => FALSE)");
  });
  it("RANGE_BUCKET(20, [0, 10, 20, 30, 40])", () => {
    validateIdentity("RANGE_BUCKET(20, [0, 10, 20, 30, 40])");
  });
  it.todo("SELECT TRANSLATE(MODEL, 'in', 't') FROM (SELECT 'input' AS MODEL) (unsupported syntax)");
  it("SELECT GRANT FROM (SELECT 'input' AS GRANT)", () => {
    validateIdentity("SELECT GRANT FROM (SELECT 'input' AS GRANT)");
  });
  it("bigquery -> bigquery: SELECT 0xA", () => {
    const result = transpile("SELECT 0xA", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT 0xA");
  });
  it("bigquery -> duckdb: SELECT 0xA", () => {
    const result = transpile("SELECT 0xA", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT 10");
  });
  it("bigquery -> snowflake: SELECT ARRAY_CONCAT_AGG(1)", () => {
    const result = transpile("SELECT ARRAY_CONCAT_AGG(1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_FLATTEN(ARRAY_AGG(1))");
  });
  it("bigquery -> bigquery: SELECT ARRAY_CONCAT_AGG(1)", () => {
    const result = transpile("SELECT ARRAY_CONCAT_AGG(1)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_CONCAT_AGG(1)");
  });
  it("bigquery -> bigquery: SELECT b'a'", () => {
    const result = transpile("SELECT b'a'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT b'a'");
  });
  it.todo("bigquery -> duckdb: SELECT b'a' (unsupported syntax)");
  it.todo("bigquery -> postgres: SELECT b'a' (unsupported syntax)");
  it("bigquery -> bigquery: SELECT b'a' (2)", () => {
    const result = transpile("SELECT b'a'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT b'a'");
  });
  it.todo("bigquery -> duckdb: SELECT b'a' (2) (unsupported syntax)");
  it.todo("bigquery -> postgres: SELECT b'a' (2) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT GENERATE_UUID()");
  });
  it("bigquery -> duckdb: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(UUID() AS TEXT)");
  });
  it("bigquery -> spark2: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT CAST(UUID() AS STRING)");
  });
  it("bigquery -> spark: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST(UUID() AS STRING)");
  });
  it("bigquery -> presto: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT CAST(UUID() AS VARCHAR)");
  });
  it("bigquery -> trino: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT CAST(UUID() AS VARCHAR)");
  });
  it("bigquery -> snowflake: SELECT GENERATE_UUID()", () => {
    const result = transpile("SELECT GENERATE_UUID()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT UUID_STRING()");
  });
  it("bigquery -> bigquery: SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result", () => {
    const result = transpile("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result");
  });
  it("bigquery -> duckdb: SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result", () => {
    const result = transpile("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result");
  });
  it.todo("test_bigquery: assertEqual call (24)");
  it.todo("test_bigquery: assertEqual call (25)");
  it.todo("TIMESTAMP_TRUNC(TIMESTAMP '2024-03-15 14:35:47.123456', DAY, 'Ameri... (unsupported syntax)");
  it.todo("TIMESTAMP_TRUNC(TIMESTAMP '2024-03-15 14:35:00', MINUTE, 'America/N... (unsupported syntax)");
  it.todo("TIMESTAMP_TRUNC(TIMESTAMP '2024-03-15 14:35:47.123456', DAY) (unsupported syntax)");
  it.todo("TIMESTAMP_TRUNC(TIMESTAMP '2025-01-01 14:35:47.123456', MINUTE) (unsupported syntax)");
  it.todo("WITH sample AS (SELECT * FROM UNNEST([TIMESTAMP '2024-03-15 14:35:4... (unsupported clause)");
  it.todo("WITH sample AS (SELECT ts FROM UNNEST([TIMESTAMP '2024-03-15 14:35:... (unsupported clause)");
  it.todo("WITH sample AS (SELECT * FROM UNNEST([TIMESTAMP '2024-03-15 14:35:4... (unsupported clause) (2)");
  it.todo("WITH sample AS (SELECT * FROM UNNEST([TIMESTAMP '2024-03-15 14:35:4... (unsupported clause) (3)");
  it("bigquery -> duckdb: SELECT GREATEST(1, NULL, 3)", () => {
    const result = transpile("SELECT GREATEST(1, NULL, 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN 1 IS NULL OR NULL IS NULL OR 3 IS NULL THEN NULL ELSE GREATEST(1, NULL, 3) END");
  });
  it("bigquery -> bigquery: SELECT GREATEST(1, NULL, 3)", () => {
    const result = transpile("SELECT GREATEST(1, NULL, 3)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT GREATEST(1, NULL, 3)");
  });
  it("bigquery -> duckdb: SELECT LEAST(1, NULL, 3)", () => {
    const result = transpile("SELECT LEAST(1, NULL, 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN 1 IS NULL OR NULL IS NULL OR 3 IS NULL THEN NULL ELSE LEAST(1, NULL, 3) END");
  });
  it("bigquery -> bigquery: SELECT LEAST(1, NULL, 3)", () => {
    const result = transpile("SELECT LEAST(1, NULL, 3)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT LEAST(1, NULL, 3)");
  });
});

describe("Bigquery: errors", () => {
  it.todo("test_errors: parse_one call");
});

describe("Bigquery: warnings", () => {
  it("WITH cte(c) AS (SELECT * FROM t) SELECT * FROM cte -> WITH cte AS (SELECT * FROM t) SEL...", () => {
    validateIdentity("WITH cte(c) AS (SELECT * FROM t) SELECT * FROM cte", "WITH cte AS (SELECT * FROM t) SELECT * FROM cte");
  });
  it.todo("test_warnings: assertIn call");
  it.todo("test_warnings: assertIn call (2)");
  it("SELECT * FROM t AS t(c1, c2) -> SELECT * FROM t AS t", () => {
    validateIdentity("SELECT * FROM t AS t(c1, c2)", "SELECT * FROM t AS t");
  });
  it.todo("test_warnings: assertIn call (3)");
  it.todo("test_warnings: assertIn call (4)");
  it.todo("test_warnings: assertIn call (5)");
  it("SELECT * FROM t AS t(c1, c2) -> SELECT * FROM t AS t (2)", () => {
    validateIdentity("SELECT * FROM t AS t(c1, c2)", "SELECT * FROM t AS t");
  });
  it.todo("test_warnings: assertIn call (6)");
  it("bigquery -> duckdb: SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE...", () => {
    const result = transpile("SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE_ORDINAL(1)]", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT a[2], b[2], c[1], d[2], e[1]");
  });
  it("bigquery -> bigquery: SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SA...", () => {
    const result = transpile("SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE_ORDINAL(1)]", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE_ORDINAL(1)]");
  });
  it("bigquery -> presto: SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE...", () => {
    const result = transpile("SELECT a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE_ORDINAL(1)]", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT a[2], b[2], c[1], ELEMENT_AT(d, 2), ELEMENT_AT(e, 1)");
  });
  it("bigquery -> bigquery: a[0]", () => {
    const result = transpile("a[0]", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("a[0]");
  });
  it("duckdb -> bigquery: a[1]", () => {
    const result = transpile("a[1]", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("a[0]");
  });
  it("presto -> bigquery: a[1]", () => {
    const result = transpile("a[1]", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("a[0]");
  });
  it.todo("test_warnings: assertEqual call");
  it.todo("test_warnings: assertIn call (7)");
  it.todo("test_warnings: assertEqual call (2)");
  it.todo("test_warnings: assertIn call (8)");
  it.todo("test_warnings: assertIn call (9)");
  it.todo("test_warnings: assertIn call (10)");
});

describe("Bigquery: user_defined_functions", () => {
  it.todo("CREATE TEMPORARY FUNCTION a(x FLOAT64, y FLOAT64) RETURNS FLOAT64 N... (DDL/DML not supported)");
  it.todo("CREATE TEMPORARY FUNCTION udf(x ANY TYPE) AS (x) (DDL/DML not supported)");
  it.todo("CREATE TEMPORARY FUNCTION a(x FLOAT64, y FLOAT64) AS ((x + 4) / y) (DDL/DML not supported)");
  it.todo("CREATE TABLE FUNCTION a(x INT64) RETURNS TABLE <q STRING, r INT64> ... (DDL/DML not supported)");
  it.todo("CREATE TEMPORARY FUNCTION string_length_0(strings ARRAY<STRING>) RE... (DDL/DML not supported)");
});

describe("Bigquery: remove_precision_parameterized_types", () => {
  it.todo("CREATE TABLE test (a NUMERIC(10, 2)) (DDL/DML not supported)");
  it.todo("INSERT INTO test (cola, colb) VALUES (CAST(7 AS STRING(10)), CAST(1... (DDL/DML not supported)");
  it("SELECT CAST(1 AS NUMERIC(10, 2)) -> SELECT CAST(1 AS NUMERIC)", () => {
    validateIdentity("SELECT CAST(1 AS NUMERIC(10, 2))", "SELECT CAST(1 AS NUMERIC)");
  });
  it("SELECT CAST('1' AS STRING(10)) UNION ALL SELECT CAST('2' AS STRING(10)) -> SELECT CAST(...", () => {
    validateIdentity("SELECT CAST('1' AS STRING(10)) UNION ALL SELECT CAST('2' AS STRING(10))", "SELECT CAST('1' AS STRING) UNION ALL SELECT CAST('2' AS STRING)");
  });
  it("SELECT cola FROM (SELECT CAST('1' AS STRING(10)) AS cola UNION ALL SELECT CAST('2' AS S...", () => {
    validateIdentity("SELECT cola FROM (SELECT CAST('1' AS STRING(10)) AS cola UNION ALL SELECT CAST('2' AS STRING(10)) AS cola)", "SELECT cola FROM (SELECT CAST('1' AS STRING) AS cola UNION ALL SELECT CAST('2' AS STRING) AS cola)");
  });
});

describe("Bigquery: gap_fill", () => {
  it.todo("SELECT * FROM GAP_FILL(TABLE device_data, ts_column => 'time', buck... (unsupported syntax)");
  it.todo("SELECT a, b, c, d, e FROM GAP_FILL(TABLE foo, ts_column => 'b', par... (unsupported syntax)");
  it.todo("SELECT * FROM GAP_FILL(TABLE device_data, ts_column => 'time', buck... (unsupported syntax) (2)");
  it.todo("SELECT * FROM GAP_FILL(TABLE device_data, ts_column => 'time', buck... (unsupported syntax) (3)");
  it.todo("SELECT * FROM GAP_FILL(TABLE device_data, ts_column => 'time', buck... (unsupported syntax) (4)");
  it.todo("SELECT * FROM GAP_FILL(TABLE device_data, ts_column => 'time', buck... (unsupported syntax) (5)");
});

describe("Bigquery: models", () => {
  it.todo("CREATE OR REPLACE MODEL foo OPTIONS (model_type='linear_reg') AS SE... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE MODEL m\nTRANSFORM(\n  ML.FEATURE_CROSS(STRUCT(f1, ... (pretty=True not supported)");
  it.todo("CREATE MODEL project_id.mydataset.mymodel\nINPUT(\n  f1 INT64,\n  f2 F... (pretty=True not supported)");
});

describe("Bigquery: ml_functions", () => {
  it.todo("test_ml_functions: assert statement");
  it("SELECT label, predicted_label1, predicted_label AS predicted_label2 FROM ML.PREDICT(MOD...", () => {
    validateIdentity("SELECT label, predicted_label1, predicted_label AS predicted_label2 FROM ML.PREDICT(MODEL mydataset.mymodel2, (SELECT * EXCEPT (predicted_label), predicted_label AS predicted_label1 FROM ML.PREDICT(MODEL mydataset.mymodel1, TABLE mydataset.mytable)))");
  });
  it("SELECT * FROM ML.PREDICT(MODEL mydataset.mymodel, (SELECT custom_label, column1, column...", () => {
    validateIdentity("SELECT * FROM ML.PREDICT(MODEL mydataset.mymodel, (SELECT custom_label, column1, column2 FROM mydataset.mytable), STRUCT(0.55 AS threshold))");
  });
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it("SELECT * FROM ML.PREDICT(MODEL `my_project`.my_dataset.my_model, (SELECT * FROM input_d...", () => {
    validateIdentity("SELECT * FROM ML.PREDICT(MODEL `my_project`.my_dataset.my_model, (SELECT * FROM input_data))");
  });
  it("SELECT * FROM ML.PREDICT(MODEL my_dataset.vision_model, (SELECT uri, ML.RESIZE_IMAGE(ML...", () => {
    validateIdentity("SELECT * FROM ML.PREDICT(MODEL my_dataset.vision_model, (SELECT uri, ML.RESIZE_IMAGE(ML.DECODE_IMAGE(data), 480, 480, FALSE) AS input FROM my_dataset.object_table))");
  });
  it("SELECT * FROM ML.PREDICT(MODEL my_dataset.vision_model, (SELECT uri, ML.CONVERT_COLOR_S...", () => {
    validateIdentity("SELECT * FROM ML.PREDICT(MODEL my_dataset.vision_model, (SELECT uri, ML.CONVERT_COLOR_SPACE(ML.RESIZE_IMAGE(ML.DECODE_IMAGE(data), 224, 280, TRUE), 'YIQ') AS input FROM my_dataset.object_table WHERE content_type = 'image/jpeg'))");
  });
  it.todo("test_ml_functions: assert statement (2)");
  it("SELECT * FROM ML.FEATURES_AT_TIME(TABLE mydataset.feature_table, time => '2022-06-11 10...", () => {
    validateIdentity("SELECT * FROM ML.FEATURES_AT_TIME(TABLE mydataset.feature_table, time => '2022-06-11 10:00:00+00', num_rows => 1, ignore_feature_nulls => TRUE)");
  });
  it.todo("test_ml_functions: assert statement (3)");
  it("SELECT * FROM VECTOR_SEARCH(TABLE mydataset.base_table, 'column_to_search', TABLE mydat...", () => {
    validateIdentity(`SELECT * FROM VECTOR_SEARCH(TABLE mydataset.base_table, 'column_to_search', TABLE mydataset.query_table, query_column_to_search => 'query_column_to_search', top_k => 2, distance_type => 'cosine', options => '{"fraction_lists_to_search":0.15}')`);
  });
  it("SELECT * FROM VECTOR_SEARCH((SELECT * FROM mydataset.base_table), 'column_to_search', (...", () => {
    validateIdentity("SELECT * FROM VECTOR_SEARCH((SELECT * FROM mydataset.base_table), 'column_to_search', (SELECT * FROM mydataset.query_table), 'query_column_to_search')");
  });
  it("SELECT * FROM VECTOR_SEARCH(TABLE mydataset.base_table, 'column_to_search', TABLE mydat... (2)", () => {
    validateIdentity("SELECT * FROM VECTOR_SEARCH(TABLE mydataset.base_table, 'column_to_search', TABLE mydataset.query_table)");
  });
  it.todo("SELECT * FROM ML.TRANSLATE(MODEL `mydataset.mytranslatemodel`, TABL... (unsupported syntax)");
  it.todo("TRANSLATE(x, y, z) (assert_is check)");
  it.todo("test_ml_functions: assert statement (4)");
  it("SELECT * FROM ML.FORECAST(MODEL `mydataset.mymodel`, TABLE `mydataset.mybqtable`, STRUC...", () => {
    validateIdentity("SELECT * FROM ML.FORECAST(MODEL `mydataset.mymodel`, TABLE `mydataset.mybqtable`, STRUCT(2 AS horizon, 4 AS confidence_level))");
  });
  it("SELECT * FROM ML.FORECAST(MODEL `mydataset.mymodel`, (SELECT * FROM mydataset.query_tab...", () => {
    validateIdentity("SELECT * FROM ML.FORECAST(MODEL `mydataset.mymodel`, (SELECT * FROM mydataset.query_table), STRUCT())");
  });
  it("SELECT * FROM ML.GENERATE_EMBEDDING(MODEL mydataset.mymodel, TABLE mydataset.mytable, S...", () => {
    validateIdentity("SELECT * FROM ML.GENERATE_EMBEDDING(MODEL mydataset.mymodel, TABLE mydataset.mytable, STRUCT(TRUE AS flatten_json_output))");
  });
  it.todo("test_ml_functions: assert statement (5)");
  it("SELECT * FROM ML.GENERATE_TEXT_EMBEDDING(MODEL mydataset.mymodel, TABLE mydataset.mytab...", () => {
    validateIdentity("SELECT * FROM ML.GENERATE_TEXT_EMBEDDING(MODEL mydataset.mymodel, TABLE mydataset.mytable, STRUCT(TRUE AS flatten_json_output))");
  });
  it.todo("test_ml_functions: assert statement (6)");
});

describe("Bigquery: merge", () => {
  it.todo("\n            MERGE dataset.Inventory T\n            USING dataset.Ne... (DDL/DML not supported)");
});

describe("Bigquery: rename_table", () => {
  it.todo("ALTER TABLE db.t1 RENAME TO db.t2 (DDL/DML not supported)");
});

describe("Bigquery: pushdown_cte_column_names", () => {
  it("spark -> bigquery: WITH cte(foo) AS (SELECT 1) SELECT foo FROM cte", () => {
    const result = transpile("WITH cte(foo) AS (SELECT 1) SELECT foo FROM cte", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH cte AS (SELECT 1 AS foo) SELECT foo FROM cte");
  });
  it("spark -> bigquery: WITH cte(foo) AS (SELECT 1 AS bar) SELECT foo FROM cte", () => {
    const result = transpile("WITH cte(foo) AS (SELECT 1 AS bar) SELECT foo FROM cte", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH cte AS (SELECT 1 AS foo) SELECT foo FROM cte");
  });
  it("spark -> bigquery: WITH cte AS (SELECT 1 AS bar) SELECT bar FROM cte", () => {
    const result = transpile("WITH cte AS (SELECT 1 AS bar) SELECT bar FROM cte", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH cte AS (SELECT 1 AS bar) SELECT bar FROM cte");
  });
  it("postgres -> bigquery: WITH cte(foo) AS (SELECT 1, 2) SELECT foo FROM cte", () => {
    const result = transpile("WITH cte(foo) AS (SELECT 1, 2) SELECT foo FROM cte", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH cte AS (SELECT 1 AS foo, 2) SELECT foo FROM cte");
  });
  it("postgres -> bigquery: WITH cte(foo) AS (SELECT 1 UNION ALL SELECT 2) SELECT foo FROM cte", () => {
    const result = transpile("WITH cte(foo) AS (SELECT 1 UNION ALL SELECT 2) SELECT foo FROM cte", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH cte AS (SELECT 1 AS foo UNION ALL SELECT 2) SELECT foo FROM cte");
  });
});

describe("Bigquery: json_object", () => {
  it("SELECT JSON_OBJECT() AS json_data", () => {
    validateIdentity("SELECT JSON_OBJECT() AS json_data");
  });
  it("SELECT JSON_OBJECT('foo', 10, 'bar', TRUE) AS json_data", () => {
    validateIdentity("SELECT JSON_OBJECT('foo', 10, 'bar', TRUE) AS json_data");
  });
  it("SELECT JSON_OBJECT('foo', 10, 'bar', ['a', 'b']) AS json_data", () => {
    validateIdentity("SELECT JSON_OBJECT('foo', 10, 'bar', ['a', 'b']) AS json_data");
  });
  it("SELECT JSON_OBJECT('a', 10, 'a', 'foo') AS json_data", () => {
    validateIdentity("SELECT JSON_OBJECT('a', 10, 'a', 'foo') AS json_data");
  });
  it("SELECT JSON_OBJECT(['a', 'b'], [10, NULL]) AS json_data -> SELECT JSON_OBJECT('a', 10, ...", () => {
    validateIdentity("SELECT JSON_OBJECT(['a', 'b'], [10, NULL]) AS json_data", "SELECT JSON_OBJECT('a', 10, 'b', NULL) AS json_data");
  });
  it(`SELECT JSON_OBJECT(['a', 'b'], [JSON '10', JSON '"foo"']) AS json_data -> SELECT JSON_O...`, () => {
    validateIdentity(`SELECT JSON_OBJECT(['a', 'b'], [JSON '10', JSON '"foo"']) AS json_data`, `SELECT JSON_OBJECT('a', PARSE_JSON('10'), 'b', PARSE_JSON('"foo"')) AS json_data`);
  });
  it("SELECT JSON_OBJECT(['a', 'b'], [STRUCT(10 AS id, 'Red' AS color), STRUCT(20 AS id, 'Blu...", () => {
    validateIdentity("SELECT JSON_OBJECT(['a', 'b'], [STRUCT(10 AS id, 'Red' AS color), STRUCT(20 AS id, 'Blue' AS color)]) AS json_data", "SELECT JSON_OBJECT('a', STRUCT(10 AS id, 'Red' AS color), 'b', STRUCT(20 AS id, 'Blue' AS color)) AS json_data");
  });
  it("SELECT JSON_OBJECT(['a', 'b'], [TO_JSON(10), TO_JSON(['foo', 'bar'])]) AS json_data -> ...", () => {
    validateIdentity("SELECT JSON_OBJECT(['a', 'b'], [TO_JSON(10), TO_JSON(['foo', 'bar'])]) AS json_data", "SELECT JSON_OBJECT('a', TO_JSON(10), 'b', TO_JSON(['foo', 'bar'])) AS json_data");
  });
});

describe("Bigquery: mod", () => {
  it("MOD(a, b)", () => {
    validateIdentity("MOD(a, b)");
  });
  it("MOD('a', b)", () => {
    validateIdentity("MOD('a', b)");
  });
  it("MOD(5, 2)", () => {
    validateIdentity("MOD(5, 2)");
  });
  it("MOD((a + 1) * 8, 5 - 1)", () => {
    validateIdentity("MOD((a + 1) * 8, 5 - 1)");
  });
  it("SELECT MOD((SELECT 1), 2)", () => {
    validateIdentity("SELECT MOD((SELECT 1), 2)");
  });
  it("MOD((a + 1), b) -> MOD(a + 1, b)", () => {
    validateIdentity("MOD((a + 1), b)", "MOD(a + 1, b)");
  });
});

describe("Bigquery: inline_constructor", () => {
  it(`SELECT STRUCT<ARRAY<STRING>>(["2023-01-17"]) -> SELECT CAST(STRUCT(['2023-01-17']) AS S...`, () => {
    validateIdentity('SELECT STRUCT<ARRAY<STRING>>(["2023-01-17"])', "SELECT CAST(STRUCT(['2023-01-17']) AS STRUCT<ARRAY<STRING>>)");
  });
  it("SELECT STRUCT<STRING>((SELECT 'foo')).* -> SELECT CAST(STRUCT((SELECT 'foo')) AS STRUCT...", () => {
    validateIdentity("SELECT STRUCT<STRING>((SELECT 'foo')).*", "SELECT CAST(STRUCT((SELECT 'foo')) AS STRUCT<STRING>).*");
  });
  it("bigquery -> bigquery: SELECT ARRAY<FLOAT64>[1, 2, 3]", () => {
    const result = transpile("SELECT ARRAY<FLOAT64>[1, 2, 3]", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY<FLOAT64>[1, 2, 3]");
  });
  it("bigquery -> duckdb: SELECT ARRAY<FLOAT64>[1, 2, 3]", () => {
    const result = transpile("SELECT ARRAY<FLOAT64>[1, 2, 3]", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST([1, 2, 3] AS DOUBLE[])");
  });
  it("bigquery -> bigquery: CAST(STRUCT<a INT64>(1) AS STRUCT<a INT64>)", () => {
    const result = transpile("CAST(STRUCT<a INT64>(1) AS STRUCT<a INT64>)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(CAST(STRUCT(1) AS STRUCT<a INT64>) AS STRUCT<a INT64>)");
  });
  it("bigquery -> duckdb: CAST(STRUCT<a INT64>(1) AS STRUCT<a INT64>)", () => {
    const result = transpile("CAST(STRUCT<a INT64>(1) AS STRUCT<a INT64>)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(CAST(ROW(1) AS STRUCT(a BIGINT)) AS STRUCT(a BIGINT))");
  });
  it("bigquery -> bigquery: SELECT * FROM UNNEST(ARRAY<STRUCT<x INT64>>[])", () => {
    const result = transpile("SELECT * FROM UNNEST(ARRAY<STRUCT<x INT64>>[])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST(ARRAY<STRUCT<x INT64>>[])");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM UNNEST(ARRAY<STRUCT<x INT64>>[]) (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST(ARRAY<STRUCT<device_id INT64, time DATETIME,...", () => {
    const result = transpile("SELECT * FROM UNNEST(ARRAY<STRUCT<device_id INT64, time DATETIME, signal INT64, state STRING>>[STRUCT(1, DATETIME '2023-11-01 09:34:01', 74, 'INACTIVE'),STRUCT(4, DATETIME '2023-11-01 09:38:01', 80, 'ACTIVE')])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST(ARRAY<STRUCT<device_id INT64, time DATETIME, signal INT64, state STRING>>[STRUCT(1, CAST('2023-11-01 09:34:01' AS DATETIME), 74, 'INACTIVE'), STRUCT(4, CAST('2023-11-01 09:38:01' AS DATETIME), 80, 'ACTIVE')])");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM UNNEST(ARRAY<STRUCT<device_id INT64, time DATETIME, s... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT STRUCT<a INT64, b STRUCT<c STRING>>(1, STRUCT('c_str'))", () => {
    const result = transpile("SELECT STRUCT<a INT64, b STRUCT<c STRING>>(1, STRUCT('c_str'))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(STRUCT(1, STRUCT('c_str')) AS STRUCT<a INT64, b STRUCT<c STRING>>)");
  });
  it("bigquery -> duckdb: SELECT STRUCT<a INT64, b STRUCT<c STRING>>(1, STRUCT('c_str'))", () => {
    const result = transpile("SELECT STRUCT<a INT64, b STRUCT<c STRING>>(1, STRUCT('c_str'))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(ROW(1, ROW('c_str')) AS STRUCT(a BIGINT, b STRUCT(c TEXT)))");
  });
  it("bigquery -> bigquery: SELECT MAX_BY(name, score) FROM table1", () => {
    const result = transpile("SELECT MAX_BY(name, score) FROM table1", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT MAX_BY(name, score) FROM table1");
  });
  it("bigquery -> duckdb: SELECT MAX_BY(name, score) FROM table1", () => {
    const result = transpile("SELECT MAX_BY(name, score) FROM table1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MAX(name, score) FROM table1");
  });
  it("bigquery -> bigquery: SELECT MIN_BY(product, price) FROM table1", () => {
    const result = transpile("SELECT MIN_BY(product, price) FROM table1", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT MIN_BY(product, price) FROM table1");
  });
  it("bigquery -> duckdb: SELECT MIN_BY(product, price) FROM table1", () => {
    const result = transpile("SELECT MIN_BY(product, price) FROM table1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MIN(product, price) FROM table1");
  });
});

describe("Bigquery: unnest", () => {
  it("bigquery -> bigquery: SELECT name, laps FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 2...", () => {
    const result = transpile("SELECT name, laps FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps), STRUCT('Makhloufi' AS name, [24.5, 25.4, 26.6, 26.1] AS laps)])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT name, laps FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps), STRUCT('Makhloufi' AS name, [24.5, 25.4, 26.6, 26.1] AS laps)])");
  });
  it.todo("bigquery -> duckdb: SELECT name, laps FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.... (cross-dialect transform)");
  it("bigquery -> bigquery: WITH Races AS (SELECT '800M' AS race) SELECT race, name, laps FRO...", () => {
    const result = transpile("WITH Races AS (SELECT '800M' AS race) SELECT race, name, laps FROM Races AS r CROSS JOIN UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("WITH Races AS (SELECT '800M' AS race) SELECT race, name, laps FROM Races AS r CROSS JOIN UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)])");
  });
  it.todo("bigquery -> duckdb: WITH Races AS (SELECT '800M' AS race) SELECT race, name, laps FROM ... (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT participant FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, ...", () => {
    const result = transpile("SELECT participant FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)]) AS participant", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT participant FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)]) AS participant");
  });
  it.todo("bigquery -> duckdb: SELECT participant FROM UNNEST([STRUCT('Rudisha' AS name, [23.4, 26... (cross-dialect transform)");
  it("bigquery -> bigquery: WITH Races AS (SELECT '800M' AS race) SELECT race, participant FR...", () => {
    const result = transpile("WITH Races AS (SELECT '800M' AS race) SELECT race, participant FROM Races AS r CROSS JOIN UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)]) AS participant", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("WITH Races AS (SELECT '800M' AS race) SELECT race, participant FROM Races AS r CROSS JOIN UNNEST([STRUCT('Rudisha' AS name, [23.4, 26.3, 26.4, 26.1] AS laps)]) AS participant");
  });
  it.todo("bigquery -> duckdb: WITH Races AS (SELECT '800M' AS race) SELECT race, participant FROM... (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, ...", () => {
    const result = transpile("SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90 AS english) AS scores), STRUCT('Bob' AS name, STRUCT(92 AS math, 88 AS english) AS scores)])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90 AS english) AS scores), STRUCT('Bob' AS name, STRUCT(92 AS math, 88 AS english) AS scores)])");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90... (cross-dialect transform)");
  it.todo("bigquery -> snowflake: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math,... (cross-dialect transform)");
  it.todo("bigquery -> presto: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90... (unsupported syntax)");
  it.todo("bigquery -> trino: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90 ... (unsupported syntax)");
  it.todo("bigquery -> spark2: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90... (unsupported syntax)");
  it.todo("bigquery -> databricks: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math... (unsupported syntax)");
  it.todo("bigquery -> hive: SELECT * FROM UNNEST([STRUCT('Alice' AS name, STRUCT(85 AS math, 90 A... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUC...", () => {
    const result = transpile("SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT('Bob', 92), STRUCT('Diana', 95)])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT('Bob', 92), STRUCT('Diana', 95)])");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT(... (cross-dialect transform)");
  it.todo("bigquery -> snowflake: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRU... (cross-dialect transform)");
  it.todo("bigquery -> presto: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT(... (unsupported syntax)");
  it.todo("bigquery -> trino: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT('... (unsupported syntax)");
  it.todo("bigquery -> spark2: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT(... (unsupported syntax)");
  it.todo("bigquery -> databricks: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STR... (unsupported syntax)");
  it.todo("bigquery -> hive: SELECT * FROM UNNEST([STRUCT('Alice' AS name, 85 AS score), STRUCT('B... (unsupported syntax)");
});

describe("Bigquery: range_type", () => {
  it("SELECT RANGE(CAST('2022-12-01' AS DATE), CAST('2022-12-31' AS DATE))", () => {
    validateIdentity("SELECT RANGE(CAST('2022-12-01' AS DATE), CAST('2022-12-31' AS DATE))");
  });
  it("SELECT RANGE(NULL, CAST('2022-12-31' AS DATE))", () => {
    validateIdentity("SELECT RANGE(NULL, CAST('2022-12-31' AS DATE))");
  });
  it("SELECT RANGE(CAST('2022-10-01 14:53:27' AS DATETIME), CAST('2022-10-01 16:00:00' AS DAT...", () => {
    validateIdentity("SELECT RANGE(CAST('2022-10-01 14:53:27' AS DATETIME), CAST('2022-10-01 16:00:00' AS DATETIME))");
  });
  it.todo("SELECT RANGE(CAST('2022-10-01 14:53:27 America/Los_Angeles' AS TIME... (unsupported syntax)");
});

describe("Bigquery: json_extract", () => {
  it(`bigquery -> bigquery: SELECT JSON_QUERY('{"class": {"students": []}}', '$.class')`, () => {
    const result = transpile(`SELECT JSON_QUERY('{"class": {"students": []}}', '$.class')`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`SELECT JSON_QUERY('{"class": {"students": []}}', '$.class')`);
  });
  it.todo(`bigquery -> duckdb: SELECT JSON_QUERY('{"class": {"students": []}}', '$.class') (unsupported syntax)`);
  it(`bigquery -> snowflake: SELECT JSON_QUERY('{"class": {"students": []}}', '$.class')`, () => {
    const result = transpile(`SELECT JSON_QUERY('{"class": {"students": []}}', '$.class')`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT GET_PATH(PARSE_JSON('{"class": {"students": []}}'), 'class')`);
  });
  it("bigquery -> bigquery: SELECT JSON_QUERY(foo, '$.class')", () => {
    const result = transpile("SELECT JSON_QUERY(foo, '$.class')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT JSON_QUERY(foo, '$.class')");
  });
  it("bigquery -> snowflake: SELECT JSON_QUERY(foo, '$.class')", () => {
    const result = transpile("SELECT JSON_QUERY(foo, '$.class')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GET_PATH(PARSE_JSON(foo), 'class')");
  });
  it("bigquery -> bigquery: SELECT JSON_EXTRACT_SCALAR('5')", () => {
    const result = transpile("SELECT JSON_EXTRACT_SCALAR('5')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR('5', '$')");
  });
  it.todo("bigquery -> duckdb: SELECT JSON_EXTRACT_SCALAR('5') (unsupported syntax)");
  it.todo("test_json_extract: unresolvable SQL string");
  it("bigquery -> bigquery: SELECT JSON_VALUE('5')", () => {
    const result = transpile("SELECT JSON_VALUE('5')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT JSON_VALUE('5', '$')");
  });
  it.todo("bigquery -> duckdb: SELECT JSON_VALUE('5') (unsupported syntax)");
  it.todo("test_json_extract: unresolvable SQL string (2)");
  it.todo("test_json_extract: assertEqual call");
  it(`JSON_VALUE(doc, '$. a b c .d') -> JSON_VALUE(doc, '$." a b c ".d')`, () => {
    validateIdentity("JSON_VALUE(doc, '$. a b c .d')", `JSON_VALUE(doc, '$." a b c ".d')`);
  });
  it(`JSON_QUERY(doc, '$. a b c .d') -> JSON_QUERY(doc, '$." a b c ".d')`, () => {
    validateIdentity("JSON_QUERY(doc, '$. a b c .d')", `JSON_QUERY(doc, '$." a b c ".d')`);
  });
  it.todo("JSON_QUERY_ARRAY(doc, '$. a b c .d') (unsupported syntax)");
  it("JSON_EXTRACT(doc, '$. a b c .d') -> JSON_EXTRACT(doc, '$[\\' a b c \\'].d')", () => {
    validateIdentity("JSON_EXTRACT(doc, '$. a b c .d')", "JSON_EXTRACT(doc, '$[\\' a b c \\'].d')");
  });
  it("JSON_EXTRACT_SCALAR(doc, '$. a b c .d') -> JSON_EXTRACT_SCALAR(doc, '$[\\' a b c \\'].d')", () => {
    validateIdentity("JSON_EXTRACT_SCALAR(doc, '$. a b c .d')", "JSON_EXTRACT_SCALAR(doc, '$[\\' a b c \\'].d')");
  });
  it.todo("JSON_EXTRACT_ARRAY(doc, '$. a b c .d') (unsupported syntax)");
});

describe("Bigquery: json_extract_array", () => {
  it.todo("test_json_extract_array: unresolvable SQL string");
  it.todo("test_json_extract_array: assertEqual call");
  it.todo("test_json_extract_array: unresolvable SQL string (2)");
  it.todo("test_json_extract_array: assertEqual call (2)");
});

describe("Bigquery: unix_seconds", () => {
  it("bigquery -> bigquery: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')");
  });
  it("spark -> bigquery: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')");
  });
  it("databricks -> bigquery: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')");
  });
  it("bigquery -> spark: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')");
  });
  it("bigquery -> databricks: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT UNIX_SECONDS('2008-12-25 15:30:00+00')");
  });
  it.todo("bigquery -> duckdb: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00') (unsupported syntax)");
  it.todo("bigquery -> snowflake: SELECT UNIX_SECONDS('2008-12-25 15:30:00+00') (unsupported syntax)");
});

describe("Bigquery: unix_micros", () => {
  it("bigquery -> bigquery: SELECT UNIX_MICROS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_MICROS('2008-12-25 15:30:00+00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT UNIX_MICROS('2008-12-25 15:30:00+00')");
  });
  it.todo("bigquery -> duckdb: SELECT UNIX_MICROS('2008-12-25 15:30:00+00') (unsupported syntax)");
  it.todo("SELECT UNIX_MICROS(TIMESTAMP '2008-12-25 15:30:00+00') (unsupported syntax)");
});

describe("Bigquery: unix_millis", () => {
  it("bigquery -> bigquery: SELECT UNIX_MILLIS('2008-12-25 15:30:00+00')", () => {
    const result = transpile("SELECT UNIX_MILLIS('2008-12-25 15:30:00+00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT UNIX_MILLIS('2008-12-25 15:30:00+00')");
  });
  it.todo("bigquery -> duckdb: SELECT UNIX_MILLIS('2008-12-25 15:30:00+00') (unsupported syntax)");
  it.todo("SELECT UNIX_MILLIS(TIMESTAMP '2008-12-25 15:30:00+00') (unsupported syntax)");
});

describe("Bigquery: regexp_extract", () => {
  it("REGEXP_EXTRACT(x, '(?<)')", () => {
    validateIdentity("REGEXP_EXTRACT(x, '(?<)')");
  });
  it("REGEXP_EXTRACT(`foo`, 'bar: (.+?)', 1, 1)", () => {
    validateIdentity("REGEXP_EXTRACT(`foo`, 'bar: (.+?)', 1, 1)");
  });
  it("REGEXP_EXTRACT(svc_plugin_output, r'\\\\\\((.*)') -> REGEXP_EXTRACT(svc_plugin_output, '\\\\...", () => {
    validateIdentity("REGEXP_EXTRACT(svc_plugin_output, r'\\\\\\((.*)')", "REGEXP_EXTRACT(svc_plugin_output, '\\\\\\\\\\\\((.*)')");
  });
  it("REGEXP_SUBSTR(value, pattern, position, occurrence) -> REGEXP_EXTRACT(value, pattern, p...", () => {
    validateIdentity("REGEXP_SUBSTR(value, pattern, position, occurrence)", "REGEXP_EXTRACT(value, pattern, position, occurrence)");
  });
  it("bigquery -> bigquery: SELECT REGEXP_EXTRACT(abc, 'pattern(group)') FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)') FROM table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(abc, 'pattern(group)') FROM table");
  });
  it("bigquery -> duckdb: SELECT REGEXP_EXTRACT(abc, 'pattern(group)') FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)') FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM "table"`);
  });
  it("bigquery -> bigquery: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM table");
  });
  it("bigquery -> duckdb: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM "table"`);
  });
  it("bigquery -> bigquery: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2) FROM table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2) FROM table");
  });
  it("bigquery -> duckdb: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2) FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(NULLIF(SUBSTRING(abc, 2), ''), 'pattern(group)', 1) FROM "table"`);
  });
  it("bigquery -> bigquery: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1, 1) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1, 1) FROM table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1, 1) FROM table");
  });
  it("bigquery -> duckdb: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1, 1) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1, 1) FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 1) FROM "table"`);
  });
  it("bigquery -> bigquery: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2, 3) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2, 3) FROM table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2, 3) FROM table");
  });
  it("bigquery -> duckdb: SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2, 3) FROM table", () => {
    const result = transpile("SELECT REGEXP_EXTRACT(abc, 'pattern(group)', 2, 3) FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT ARRAY_EXTRACT(REGEXP_EXTRACT_ALL(NULLIF(SUBSTRING(abc, 2), ''), 'pattern(group)', 1), 3) FROM "table"`);
  });
  it("bigquery -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("trino -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("presto -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("snowflake -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("duckdb -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("spark -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("databricks -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("bigquery -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]') (2)", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("bigquery -> trino: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("bigquery -> presto: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("bigquery -> snowflake: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')");
  });
  it("bigquery -> duckdb: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)");
  });
  it("bigquery -> spark: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)");
  });
  it("bigquery -> databricks: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', 'a[0-9]', 0)");
  });
  it("bigquery -> bigquery: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')");
  });
  it("bigquery -> trino: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]', 1)");
  });
  it("bigquery -> presto: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]', 1)");
  });
  it("bigquery -> snowflake: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]', 1, 1, 'c', 1)");
  });
  it("bigquery -> duckdb: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]', 1)");
  });
  it("bigquery -> spark: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')");
  });
  it("bigquery -> databricks: REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", () => {
    const result = transpile("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("REGEXP_EXTRACT_ALL('a1_a2a3_a4A5a6', '(a)[0-9]')");
  });
});

describe("Bigquery: format_temporal", () => {
  it("bigquery -> bigquery: SELECT FORMAT_DATE('%Y%m%d', '2023-12-25')", () => {
    const result = transpile("SELECT FORMAT_DATE('%Y%m%d', '2023-12-25')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FORMAT_DATE('%Y%m%d', '2023-12-25')");
  });
  it("bigquery -> duckdb: SELECT FORMAT_DATE('%Y%m%d', '2023-12-25')", () => {
    const result = transpile("SELECT FORMAT_DATE('%Y%m%d', '2023-12-25')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT STRFTIME(CAST('2023-12-25' AS DATE), '%Y%m%d')");
  });
  it("bigquery -> bigquery: SELECT FORMAT_DATETIME('%Y%m%d %H:%M:%S', DATETIME '2023-12-25 15...", () => {
    const result = transpile("SELECT FORMAT_DATETIME('%Y%m%d %H:%M:%S', DATETIME '2023-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FORMAT_DATETIME('%Y%m%d %T', CAST('2023-12-25 15:30:00' AS DATETIME))");
  });
  it.todo("bigquery -> duckdb: SELECT FORMAT_DATETIME('%Y%m%d %H:%M:%S', DATETIME '2023-12-25 15:3... (unsupported syntax)");
  it("bigquery -> bigquery: SELECT FORMAT_DATETIME('%x', '2023-12-25 15:30:00')", () => {
    const result = transpile("SELECT FORMAT_DATETIME('%x', '2023-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FORMAT_DATETIME('%D', '2023-12-25 15:30:00')");
  });
  it.todo("bigquery -> duckdb: SELECT FORMAT_DATETIME('%x', '2023-12-25 15:30:00') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT FORMAT_DATETIME('%F %T', DATETIME '2023-10-15 14:30:45')", () => {
    const result = transpile("SELECT FORMAT_DATETIME('%F %T', DATETIME '2023-10-15 14:30:45')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FORMAT_DATETIME('%F %T', CAST('2023-10-15 14:30:45' AS DATETIME))");
  });
  it.todo("bigquery -> duckdb: SELECT FORMAT_DATETIME('%F %T', DATETIME '2023-10-15 14:30:45') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT FORMAT_DATETIME('%c', DATETIME '2008-12-25 15:30:00')", () => {
    const result = transpile("SELECT FORMAT_DATETIME('%c', DATETIME '2008-12-25 15:30:00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FORMAT_DATETIME('%c', CAST('2008-12-25 15:30:00' AS DATETIME))");
  });
  it.todo("bigquery -> duckdb: SELECT FORMAT_DATETIME('%c', DATETIME '2008-12-25 15:30:00') (unsupported syntax)");
  it.todo("SELECT FORMAT_DATETIME('%Y-%m-%e', DATETIME '2020-09-09 10:15:30') (unsupported syntax)");
  it.todo('bigquery -> bigquery: SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2050-12-25 15:30:5... (unsupported syntax)');
  it.todo('bigquery -> duckdb: SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2050-12-25 15:30:55+... (unsupported syntax)');
  it.todo('bigquery -> snowflake: SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2050-12-25 15:30:... (unsupported syntax)');
});

describe("Bigquery: string_agg", () => {
  it.todo("STRING_AGG(a, ' & ') (unsupported syntax)");
  it.todo("STRING_AGG(DISTINCT a, ' & ') (unsupported syntax)");
  it.todo("STRING_AGG(a, ' & ' ORDER BY LENGTH(a)) (unsupported syntax)");
  it.todo("STRING_AGG(foo, b'|' ORDER BY bar) (unsupported syntax)");
  it.todo("STRING_AGG(a) (unsupported syntax)");
  it.todo("STRING_AGG(DISTINCT v, sep LIMIT 3) (unsupported syntax)");
  it.todo("STRING_AGG(DISTINCT a ORDER BY b DESC, c DESC LIMIT 10) (unsupported syntax)");
  it.todo("SELECT a, GROUP_CONCAT(b) FROM table GROUP BY a (unsupported syntax)");
});

describe("Bigquery: annotate_timestamps", () => {
  it.todo("test_annotate_timestamps: unresolvable for-loop iterable");
});

describe("Bigquery: set_operations", () => {
  it("SELECT 1 AS foo INNER UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo INNER UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo OUTER UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo OUTER UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT OUTER UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT OUTER UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo LEFT OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo LEFT OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL OUTER UNION ALL SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL OUTER UNION ALL SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL OUTER UNION ALL BY NAME SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS foo FULL OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar", () => {
    validateIdentity("SELECT 1 AS foo FULL OUTER UNION ALL BY NAME ON (foo, bar) SELECT 3 AS foo, 4 AS bar");
  });
  it("SELECT 1 AS x UNION ALL CORRESPONDING SELECT 2 AS x -> SELECT 1 AS x INNER UNION ALL BY...", () => {
    validateIdentity("SELECT 1 AS x UNION ALL CORRESPONDING SELECT 2 AS x", "SELECT 1 AS x INNER UNION ALL BY NAME SELECT 2 AS x");
  });
  it("SELECT 1 AS x UNION ALL CORRESPONDING BY (foo, bar) SELECT 2 AS x -> SELECT 1 AS x INNE...", () => {
    validateIdentity("SELECT 1 AS x UNION ALL CORRESPONDING BY (foo, bar) SELECT 2 AS x", "SELECT 1 AS x INNER UNION ALL BY NAME ON (foo, bar) SELECT 2 AS x");
  });
  it("SELECT 1 AS x LEFT UNION ALL CORRESPONDING SELECT 2 AS x -> SELECT 1 AS x LEFT UNION AL...", () => {
    validateIdentity("SELECT 1 AS x LEFT UNION ALL CORRESPONDING SELECT 2 AS x", "SELECT 1 AS x LEFT UNION ALL BY NAME SELECT 2 AS x");
  });
  it("SELECT 1 AS x UNION ALL STRICT CORRESPONDING SELECT 2 AS x -> SELECT 1 AS x UNION ALL B...", () => {
    validateIdentity("SELECT 1 AS x UNION ALL STRICT CORRESPONDING SELECT 2 AS x", "SELECT 1 AS x UNION ALL BY NAME SELECT 2 AS x");
  });
  it("SELECT 1 AS x UNION ALL STRICT CORRESPONDING BY (foo, bar) SELECT 2 AS x -> SELECT 1 AS...", () => {
    validateIdentity("SELECT 1 AS x UNION ALL STRICT CORRESPONDING BY (foo, bar) SELECT 2 AS x", "SELECT 1 AS x UNION ALL BY NAME ON (foo, bar) SELECT 2 AS x");
  });
});

describe("Bigquery: with_offset", () => {
  it("SELECT * FROM UNNEST(x) WITH OFFSET EXCEPT DISTINCT SELECT * FROM UNNEST(y) WITH OFFSET...", () => {
    validateIdentity("SELECT * FROM UNNEST(x) WITH OFFSET EXCEPT DISTINCT SELECT * FROM UNNEST(y) WITH OFFSET", "SELECT * FROM UNNEST(x) WITH OFFSET AS offset EXCEPT DISTINCT SELECT * FROM UNNEST(y) WITH OFFSET AS offset");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET LEFT JOIN foo -> SELECT * FROM t1 C...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET LEFT JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset LEFT JOIN foo");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET RIGHT JOIN foo -> SELECT * FROM t1 ...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET RIGHT JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset RIGHT JOIN foo");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET FULL JOIN foo -> SELECT * FROM t1 C...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET FULL JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset FULL JOIN foo");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET NATURAL JOIN foo -> SELECT * FROM t...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET NATURAL JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset NATURAL JOIN foo");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET SEMI JOIN foo -> SELECT * FROM t1 C...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET SEMI JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset SEMI JOIN foo");
  });
  it("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET ANTI JOIN foo -> SELECT * FROM t1 C...", () => {
    validateIdentity("SELECT * FROM t1, UNNEST([1, 2]) AS hit WITH OFFSET ANTI JOIN foo", "SELECT * FROM t1 CROSS JOIN UNNEST([1, 2]) AS hit WITH OFFSET AS offset ANTI JOIN foo");
  });
});

describe("Bigquery: identifier_meta", () => {
  it.todo("test_identifier_meta: unresolvable for-loop iterable");
  it.todo("test_identifier_meta: assertEqual call");
  it.todo("test_identifier_meta: assertEqual call (2)");
  it.todo("test_identifier_meta: assertEqual call (3)");
  it.todo("test_identifier_meta: assertEqual call (4)");
  it.todo("test_identifier_meta: assertEqual call (5)");
  it.todo("test_identifier_meta: assertEqual call (6)");
  it.todo("test_identifier_meta: assert statement");
});

describe("Bigquery: quoted_identifier_meta", () => {
  it.todo("test_quoted_identifier_meta: assertEqual call");
  it.todo("test_quoted_identifier_meta: assertEqual call (2)");
  it.todo("test_quoted_identifier_meta: assert statement");
});

describe("Bigquery: override_normalization_strategy", () => {
  it.todo("test_override_normalization_strategy: assertEqual call");
});

describe("Bigquery: array_agg", () => {
  it("bigquery -> bigquery: SELECT ARRAY_AGG(x ORDER BY x)", () => {
    const result = transpile("SELECT ARRAY_AGG(x ORDER BY x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(x ORDER BY x)");
  });
  it.todo("bigquery -> snowflake: SELECT ARRAY_AGG(x ORDER BY x) (unsupported clause)");
  it("bigquery -> bigquery: SELECT ARRAY_AGG(DISTINCT x ORDER BY x)", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT x ORDER BY x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(DISTINCT x ORDER BY x)");
  });
  it.todo("bigquery -> snowflake: SELECT ARRAY_AGG(DISTINCT x ORDER BY x) (unsupported clause)");
  it("bigquery -> bigquery: SELECT ARRAY_AGG(x ORDER BY col1 ASC, col2 DESC)", () => {
    const result = transpile("SELECT ARRAY_AGG(x ORDER BY col1 ASC, col2 DESC)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(x ORDER BY col1 ASC, col2 DESC)");
  });
  it.todo("bigquery -> snowflake: SELECT ARRAY_AGG(x ORDER BY col1 ASC, col2 DESC) (unsupported clause)");
  it("bigquery -> bigquery: SELECT ARRAY_AGG(x IGNORE NULLS ORDER BY col1 ASC, col2 DESC)", () => {
    const result = transpile("SELECT ARRAY_AGG(x IGNORE NULLS ORDER BY col1 ASC, col2 DESC)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(x IGNORE NULLS ORDER BY col1 ASC, col2 DESC)");
  });
  it.todo("bigquery -> snowflake: SELECT ARRAY_AGG(x IGNORE NULLS ORDER BY col1 ASC, col2 DESC) (unsupported clause)");
  it("bigquery -> bigquery: SELECT ARRAY_AGG(x RESPECT NULLS ORDER BY col1 ASC, col2 DESC)", () => {
    const result = transpile("SELECT ARRAY_AGG(x RESPECT NULLS ORDER BY col1 ASC, col2 DESC)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(x RESPECT NULLS ORDER BY col1 ASC, col2 DESC)");
  });
  it.todo("bigquery -> snowflake: SELECT ARRAY_AGG(x RESPECT NULLS ORDER BY col1 ASC, col2 DESC) (unsupported clause)");
});

describe("Bigquery: array_concat", () => {
  it("bigquery -> snowflake: WITH x AS ( SELECT 1 AS id), test_cte AS ( SELECT ARRAY_CONCAT((...", () => {
    const result = transpile("WITH x AS ( SELECT 1 AS id), test_cte AS ( SELECT ARRAY_CONCAT(( SELECT id FROM x WHERE FALSE)) AS result ) SELECT * FROM test_cte;", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("WITH x AS (SELECT 1 AS id), test_cte AS (SELECT ARRAY_CAT((SELECT id FROM x WHERE FALSE), []) AS result) SELECT * FROM test_cte");
  });
});

describe("Bigquery: select_as_struct", () => {
  it.todo("SELECT ARRAY(SELECT AS STRUCT x1 AS x1, x2 AS x2 FROM t) AS array_col (unsupported syntax)");
  it.todo("WITH t1 AS (SELECT ARRAY(SELECT AS STRUCT x1 AS alias_x1, x2 /* tes... (unsupported syntax)");
  it.todo("WITH t1 AS (SELECT ARRAY(SELECT AS STRUCT 1 AS a, 2 AS b) AS array_... (unsupported syntax)");
  it.todo("WITH t1 AS (SELECT ARRAY(SELECT AS STRUCT x1 AS alias_x1, x2 /* tes... (unsupported syntax) (2)");
});

describe("Bigquery: avoid_generating_nested_comment", () => {
  it.todo("test_avoid_generating_nested_comment: assertEqual call");
});

describe("Bigquery: generate_date_array", () => {
  it.todo("SELECT GENERATE_DATE_ARRAY('2016-10-05', '2016-10-08') (unsupported syntax)");
  it.todo("SELECT GENERATE_DATE_ARRAY('2016-10-05', '2016-10-08', INTERVAL '1'... (unsupported syntax)");
  it.todo("SELECT id, mnth FROM t CROSS JOIN UNNEST(GENERATE_DATE_ARRAY(start_... (unsupported syntax)");
  it.todo("SELECT id, mnth AS a_mnth FROM t CROSS JOIN UNNEST(GENERATE_DATE_AR... (unsupported syntax)");
  it.todo("SELECT id, mnth + 1 AS a_mnth FROM t CROSS JOIN UNNEST(GENERATE_DAT... (unsupported syntax)");
});

describe("Bigquery: json_array", () => {
  it.todo("JSON_ARRAY() (unsupported syntax)");
  it.todo("JSON_ARRAY(10) (unsupported syntax)");
  it.todo("JSON_ARRAY([]) (unsupported syntax)");
  it.todo("JSON_ARRAY(STRUCT(10 AS a, 'foo' AS b)) (unsupported syntax)");
  it.todo("JSON_ARRAY(10, ['foo', 'bar'], [20, 30]) (unsupported syntax)");
});

describe("Bigquery: declare", () => {
  it.todo("DECLARE X INT64 (command not supported)");
  it.todo("DECLARE X INT64 DEFAULT 1 (command not supported)");
  it.todo("DECLARE X FLOAT64 DEFAULT 0.9 (command not supported)");
  it.todo("DECLARE X INT64 DEFAULT (SELECT MAX(col) FROM foo) (command not supported)");
  it.todo("DECLARE X, Y, Z INT64 (command not supported)");
  it.todo("DECLARE X, Y, Z INT64 DEFAULT 42 (command not supported)");
  it.todo("DECLARE X, Y, Z INT64 DEFAULT (SELECT 42) (command not supported)");
  it.todo("DECLARE START_DATE DATE DEFAULT CURRENT_DATE - 1 (command not supported)");
  it.todo("DECLARE TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP() - INTERVAL '1' HOUR (command not supported)");
});

describe("Bigquery: week", () => {
  it("DATE_TRUNC(date, WEEK(MONDAY))", () => {
    validateIdentity("DATE_TRUNC(date, WEEK(MONDAY))");
  });
  it("LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(SUNDAY)) -> LAST_DAY(CAST('2008-11-10 15:...", () => {
    validateIdentity("LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(SUNDAY))", "LAST_DAY(CAST('2008-11-10 15:30:00' AS DATETIME), WEEK)");
  });
  it("DATE_DIFF('2017-12-18', '2017-12-17', WEEK(SATURDAY))", () => {
    validateIdentity("DATE_DIFF('2017-12-18', '2017-12-17', WEEK(SATURDAY))");
  });
  it("DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY))", () => {
    validateIdentity("DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY))");
  });
  it.todo("EXTRACT(WEEK(THURSDAY) FROM DATE '2013-12-25') (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2024-06-15', '2024-01-08', WEEK(MONDAY))", () => {
    const result = transpile("SELECT DATE_DIFF('2024-06-15', '2024-01-08', WEEK(MONDAY))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2024-06-15', '2024-01-08', WEEK(MONDAY))");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2024-06-15', '2024-01-08', WEEK(MONDAY)) (cross-dialect transform)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2026-01-15', '2024-01-08', WEEK(SUNDAY))", () => {
    const result = transpile("SELECT DATE_DIFF('2026-01-15', '2024-01-08', WEEK(SUNDAY))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2026-01-15', '2024-01-08', WEEK)");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2026-01-15', '2024-01-08', WEEK(SUNDAY)) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2024-01-15', '2022-04-28', WEEK(SATURDAY))", () => {
    const result = transpile("SELECT DATE_DIFF('2024-01-15', '2022-04-28', WEEK(SATURDAY))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2024-01-15', '2022-04-28', WEEK(SATURDAY))");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2024-01-15', '2022-04-28', WEEK(SATURDAY)) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2024-01-15', '2024-01-08', WEEK)", () => {
    const result = transpile("SELECT DATE_DIFF('2024-01-15', '2024-01-08', WEEK)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2024-01-15', '2024-01-08', WEEK)");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2024-01-15', '2024-01-08', WEEK) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2024-01-07', '2024-01-06', WEEK)", () => {
    const result = transpile("SELECT DATE_DIFF('2024-01-07', '2024-01-06', WEEK)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2024-01-07', '2024-01-06', WEEK)");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2024-01-07', '2024-01-06', WEEK) (unsupported syntax)");
  it("bigquery -> bigquery: SELECT DATE_DIFF('2024-01-15', '2024-01-08', ISOWEEK)", () => {
    const result = transpile("SELECT DATE_DIFF('2024-01-15', '2024-01-08', ISOWEEK)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE_DIFF('2024-01-15', '2024-01-08', ISOWEEK)");
  });
  it.todo("bigquery -> duckdb: SELECT DATE_DIFF('2024-01-15', '2024-01-08', ISOWEEK) (cross-dialect transform)");
  it.todo("SELECT DATE_DIFF(DATE '2024-09-15', DATE '2024-01-08', WEEK(MONDAY)) (unsupported syntax)");
  it.todo("SELECT DATE_DIFF(DATE '2024-01-01', DATE '2024-01-15', WEEK(SUNDAY)) (unsupported syntax)");
  it.todo("SELECT DATE_DIFF(DATE '2023-05-01', DATE '2024-01-15', ISOWEEK) (unsupported syntax)");
  it.todo("SELECT DATE_DIFF(DATE '2024-01-01', DATE '2024-01-15', DAY) (unsupported syntax)");
});

describe("Bigquery: approx_qunatiles", () => {
  it("APPROX_QUANTILES(foo, 2)", () => {
    validateIdentity("APPROX_QUANTILES(foo, 2)");
  });
  it("APPROX_QUANTILES(DISTINCT foo, 2 RESPECT NULLS)", () => {
    validateIdentity("APPROX_QUANTILES(DISTINCT foo, 2 RESPECT NULLS)");
  });
  it("APPROX_QUANTILES(DISTINCT foo, 2 IGNORE NULLS)", () => {
    validateIdentity("APPROX_QUANTILES(DISTINCT foo, 2 IGNORE NULLS)");
  });
});

describe("Bigquery: json_lax", () => {
  it("LAX_BOOL(PARSE_JSON('true'))", () => {
    validateIdentity("LAX_BOOL(PARSE_JSON('true'))");
  });
  it("LAX_FLOAT64(PARSE_JSON('9.8'))", () => {
    validateIdentity("LAX_FLOAT64(PARSE_JSON('9.8'))");
  });
  it("LAX_INT64(PARSE_JSON('10'))", () => {
    validateIdentity("LAX_INT64(PARSE_JSON('10'))");
  });
  it(`LAX_STRING(PARSE_JSON('"str"'))`, () => {
    validateIdentity(`LAX_STRING(PARSE_JSON('"str"'))`);
  });
});

describe("Bigquery: safe_math_funcs", () => {
  it("SAFE_NEGATE(x)", () => {
    validateIdentity("SAFE_NEGATE(x)");
  });
  it("bigquery -> bigquery: SAFE_ADD(x, y)", () => {
    const result = transpile("SAFE_ADD(x, y)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_ADD(x, y)");
  });
  it("spark -> bigquery: TRY_ADD(x, y)", () => {
    const result = transpile("TRY_ADD(x, y)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_ADD(x, y)");
  });
  it("databricks -> bigquery: TRY_ADD(x, y)", () => {
    const result = transpile("TRY_ADD(x, y)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_ADD(x, y)");
  });
  it("bigquery -> spark: SAFE_ADD(x, y)", () => {
    const result = transpile("SAFE_ADD(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRY_ADD(x, y)");
  });
  it("bigquery -> databricks: SAFE_ADD(x, y)", () => {
    const result = transpile("SAFE_ADD(x, y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TRY_ADD(x, y)");
  });
  it("bigquery -> bigquery: SAFE_MULTIPLY(x, y)", () => {
    const result = transpile("SAFE_MULTIPLY(x, y)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_MULTIPLY(x, y)");
  });
  it("spark -> bigquery: TRY_MULTIPLY(x, y)", () => {
    const result = transpile("TRY_MULTIPLY(x, y)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_MULTIPLY(x, y)");
  });
  it("databricks -> bigquery: TRY_MULTIPLY(x, y)", () => {
    const result = transpile("TRY_MULTIPLY(x, y)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_MULTIPLY(x, y)");
  });
  it("bigquery -> spark: SAFE_MULTIPLY(x, y)", () => {
    const result = transpile("SAFE_MULTIPLY(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRY_MULTIPLY(x, y)");
  });
  it("bigquery -> databricks: SAFE_MULTIPLY(x, y)", () => {
    const result = transpile("SAFE_MULTIPLY(x, y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TRY_MULTIPLY(x, y)");
  });
  it("bigquery -> bigquery: SAFE_SUBTRACT(x, y)", () => {
    const result = transpile("SAFE_SUBTRACT(x, y)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_SUBTRACT(x, y)");
  });
  it("spark -> bigquery: TRY_SUBTRACT(x, y)", () => {
    const result = transpile("TRY_SUBTRACT(x, y)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_SUBTRACT(x, y)");
  });
  it("databricks -> bigquery: TRY_SUBTRACT(x, y)", () => {
    const result = transpile("TRY_SUBTRACT(x, y)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SAFE_SUBTRACT(x, y)");
  });
  it("bigquery -> spark: SAFE_SUBTRACT(x, y)", () => {
    const result = transpile("SAFE_SUBTRACT(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRY_SUBTRACT(x, y)");
  });
  it("bigquery -> databricks: SAFE_SUBTRACT(x, y)", () => {
    const result = transpile("SAFE_SUBTRACT(x, y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TRY_SUBTRACT(x, y)");
  });
});

describe("Bigquery: bitwise_and", () => {
  it("bigquery -> bigquery: SELECT 1 & 1", () => {
    const result = transpile("SELECT 1 & 1", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT 1 & 1");
  });
  it("bigquery -> snowflake: SELECT 1 & 1", () => {
    const result = transpile("SELECT 1 & 1", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITAND(1, 1)");
  });
});

describe("Bigquery: bitwise_not", () => {
  it.todo("SELECT ~1 (unsupported syntax)");
});

describe("Bigquery: bit_aggs", () => {
  it("bigquery -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("databricks -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("dremio -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "dremio", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("duckdb -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("mysql -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("postgres -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("spark -> bigquery: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> databricks: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> dremio: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "dremio" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> duckdb: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> mysql: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> postgres: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> spark: BIT_AND(x)", () => {
    const result = transpile("BIT_AND(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("BIT_AND(x)");
  });
  it("bigquery -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("databricks -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("dremio -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "dremio", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("duckdb -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("mysql -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("postgres -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("spark -> bigquery: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> databricks: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> dremio: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "dremio" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> duckdb: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> mysql: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> postgres: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> spark: BIT_OR(x)", () => {
    const result = transpile("BIT_OR(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("BIT_OR(x)");
  });
  it("bigquery -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("databricks -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("duckdb -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("mysql -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("postgres -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("spark -> bigquery: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> databricks: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> duckdb: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> mysql: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> postgres: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> spark: BIT_XOR(x)", () => {
    const result = transpile("BIT_XOR(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("BIT_XOR(x)");
  });
  it("bigquery -> bigquery: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("spark -> bigquery: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("databricks -> bigquery: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("mysql -> bigquery: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("bigquery -> spark: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("bigquery -> databricks: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
  it("bigquery -> mysql: BIT_COUNT(x)", () => {
    const result = transpile("BIT_COUNT(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("BIT_COUNT(x)");
  });
});

describe("Bigquery: to_hex", () => {
  it("bigquery -> bigquery: SELECT TO_HEX(SHA1('abc'))", () => {
    const result = transpile("SELECT TO_HEX(SHA1('abc'))", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TO_HEX(SHA1('abc'))");
  });
  it("bigquery -> snowflake: SELECT TO_HEX(SHA1('abc'))", () => {
    const result = transpile("SELECT TO_HEX(SHA1('abc'))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_CHAR(SHA1_BINARY('abc'))");
  });
});

describe("Bigquery: md5", () => {
  it("bigquery -> bigquery: SELECT MD5('abc')", () => {
    const result = transpile("SELECT MD5('abc')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT MD5('abc')");
  });
  it("bigquery -> snowflake: SELECT MD5('abc')", () => {
    const result = transpile("SELECT MD5('abc')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MD5_BINARY('abc')");
  });
});

describe("Bigquery: to_json_string", () => {
  it("bigquery -> bigquery: SELECT TO_JSON_STRING(STRUCT('Alice' AS name)) AS json_data", () => {
    const result = transpile("SELECT TO_JSON_STRING(STRUCT('Alice' AS name)) AS json_data", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT TO_JSON_STRING(STRUCT('Alice' AS name)) AS json_data");
  });
  it("bigquery -> snowflake: SELECT TO_JSON_STRING(STRUCT('Alice' AS name)) AS json_data", () => {
    const result = transpile("SELECT TO_JSON_STRING(STRUCT('Alice' AS name)) AS json_data", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_JSON(OBJECT_CONSTRUCT('name', 'Alice')) AS json_data");
  });
});

describe("Bigquery: concat", () => {
  it.todo("SELECT CONCAT('T.P.', ' ', 'Bar') AS author (unsupported syntax)");
});

describe("Bigquery: pseudocolumns", () => {
  it.todo("test_pseudocolumns: assertIsNone call");
  it.todo("test_pseudocolumns: assertIsNotNone call");
  it.todo("test_pseudocolumns: assertEqual call");
  it.todo("test_pseudocolumns: assertIsNone call (2)");
  it.todo("test_pseudocolumns: assertIsNotNone call (2)");
});

describe("Bigquery: round", () => {
  it("bigquery -> bigquery: SELECT ROUND(2.25) AS value", () => {
    const result = transpile("SELECT ROUND(2.25) AS value", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ROUND(2.25) AS value");
  });
  it("bigquery -> duckdb: SELECT ROUND(2.25) AS value", () => {
    const result = transpile("SELECT ROUND(2.25) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25) AS value");
  });
  it("bigquery -> bigquery: SELECT ROUND(2.25, 1) AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1) AS value", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("bigquery -> duckdb: SELECT ROUND(2.25, 1) AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("bigquery -> bigquery: SELECT ROUND(NUMERIC '2.25', 1, 'ROUND_HALF_AWAY_FROM_ZERO') AS v...", () => {
    const result = transpile("SELECT ROUND(NUMERIC '2.25', 1, 'ROUND_HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT ROUND(CAST('2.25' AS NUMERIC), 1, 'ROUND_HALF_AWAY_FROM_ZERO') AS value");
  });
  it("bigquery -> duckdb: SELECT ROUND(NUMERIC '2.25', 1, 'ROUND_HALF_AWAY_FROM_ZERO') AS value", () => {
    const result = transpile("SELECT ROUND(NUMERIC '2.25', 1, 'ROUND_HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(CAST('2.25' AS DECIMAL), 1) AS value");
  });
  it.todo("SELECT ROUND(NUMERIC '2.25', 1, 'ROUND_HALF_EVEN') AS value (unsupported syntax)");
});

describe("Bigquery: approx_quantiles", () => {
  it("APPROX_QUANTILES(x, 2)", () => {
    validateIdentity("APPROX_QUANTILES(x, 2)");
  });
  it("APPROX_QUANTILES(FALSE OR TRUE, 2)", () => {
    validateIdentity("APPROX_QUANTILES(FALSE OR TRUE, 2)");
  });
  it("APPROX_QUANTILES((SELECT 1 AS val), CAST(2.1 AS INT64))", () => {
    validateIdentity("APPROX_QUANTILES((SELECT 1 AS val), CAST(2.1 AS INT64))");
  });
  it("APPROX_QUANTILES(DISTINCT x, 2)", () => {
    validateIdentity("APPROX_QUANTILES(DISTINCT x, 2)");
  });
  it("APPROX_QUANTILES(x, 2 RESPECT NULLS)", () => {
    validateIdentity("APPROX_QUANTILES(x, 2 RESPECT NULLS)");
  });
  it("APPROX_QUANTILES(x, 2 IGNORE NULLS)", () => {
    validateIdentity("APPROX_QUANTILES(x, 2 IGNORE NULLS)");
  });
  it("APPROX_QUANTILES(DISTINCT x, 2 RESPECT NULLS)", () => {
    validateIdentity("APPROX_QUANTILES(DISTINCT x, 2 RESPECT NULLS)");
  });
});

describe("Bigquery: approx_quantiles_to_duckdb", () => {
  it("bigquery -> duckdb: APPROX_QUANTILES(x, 1)", () => {
    const result = transpile("APPROX_QUANTILES(x, 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x, [0, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(x, 2)", () => {
    const result = transpile("APPROX_QUANTILES(x, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x, [0, 0.5, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(x, 4)", () => {
    const result = transpile("APPROX_QUANTILES(x, 4)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x, [0, 0.25, 0.5, 0.75, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(DISTINCT x, 2)", () => {
    const result = transpile("APPROX_QUANTILES(DISTINCT x, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(DISTINCT x, [0, 0.5, 1])");
  });
  it.todo("test_approx_quantiles_to_duckdb: assertEqual call");
  it.todo("test_approx_quantiles_to_duckdb: assertIn call");
  it.todo("test_approx_quantiles_to_duckdb: assertIn call (2)");
  it("bigquery -> duckdb: APPROX_QUANTILES(x + y, 2)", () => {
    const result = transpile("APPROX_QUANTILES(x + y, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x + y, [0, 0.5, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(CASE WHEN x > 0 THEN x ELSE 0 END, 2)", () => {
    const result = transpile("APPROX_QUANTILES(CASE WHEN x > 0 THEN x ELSE 0 END, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(CASE WHEN x > 0 THEN x ELSE 0 END, [0, 0.5, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(ABS(x), 2)", () => {
    const result = transpile("APPROX_QUANTILES(ABS(x), 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(ABS(x), [0, 0.5, 1])");
  });
  it("bigquery -> duckdb: APPROX_QUANTILES(x, 2 IGNORE NULLS)", () => {
    const result = transpile("APPROX_QUANTILES(x, 2 IGNORE NULLS)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x, [0, 0.5, 1])");
  });
});

describe("Bigquery: bignumeric", () => {
  it("bigquery -> bigquery: SELECT BIGNUMERIC '1'", () => {
    const result = transpile("SELECT BIGNUMERIC '1'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST('1' AS BIGNUMERIC)");
  });
  it("bigquery -> duckdb: SELECT BIGNUMERIC '1'", () => {
    const result = transpile("SELECT BIGNUMERIC '1'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('1' AS DECIMAL(38, 5))");
  });
  it("bigquery -> bigquery: SELECT CAST(1 AS BIGNUMERIC)", () => {
    const result = transpile("SELECT CAST(1 AS BIGNUMERIC)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(1 AS BIGNUMERIC)");
  });
  it("bigquery -> duckdb: SELECT CAST(1 AS BIGNUMERIC)", () => {
    const result = transpile("SELECT CAST(1 AS BIGNUMERIC)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(1 AS DECIMAL(38, 5))");
  });
  it("bigquery -> bigquery: SELECT BIGDECIMAL '1'", () => {
    const result = transpile("SELECT BIGDECIMAL '1'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST('1' AS BIGNUMERIC)");
  });
  it("bigquery -> duckdb: SELECT BIGDECIMAL '1'", () => {
    const result = transpile("SELECT BIGDECIMAL '1'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('1' AS DECIMAL(38, 5))");
  });
  it("bigquery -> bigquery: SELECT CAST(1 AS BIGDECIMAL)", () => {
    const result = transpile("SELECT CAST(1 AS BIGDECIMAL)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST(1 AS BIGNUMERIC)");
  });
  it("bigquery -> duckdb: SELECT CAST(1 AS BIGDECIMAL)", () => {
    const result = transpile("SELECT CAST(1 AS BIGDECIMAL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(1 AS DECIMAL(38, 5))");
  });
});
