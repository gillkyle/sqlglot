// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "exasol";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Exasol: exasol", () => {
  it('SELECT 1 AS [x] -> SELECT 1 AS "x"', () => {
    validateIdentity("SELECT 1 AS [x]", 'SELECT 1 AS "x"');
  });
  it("SYSTIMESTAMP -> SYSTIMESTAMP()", () => {
    validateIdentity("SYSTIMESTAMP", "SYSTIMESTAMP()");
  });
  it("SELECT SYSTIMESTAMP()", () => {
    validateIdentity("SELECT SYSTIMESTAMP()");
  });
  it("SELECT SYSTIMESTAMP(6)", () => {
    validateIdentity("SELECT SYSTIMESTAMP(6)");
  });
  it.todo("SELECT CURDATE() (unsupported syntax)");
  it("SELECT USER -> SELECT CURRENT_USER", () => {
    validateIdentity("SELECT USER", "SELECT CURRENT_USER");
  });
  it("SELECT USER() -> SELECT CURRENT_USER", () => {
    validateIdentity("SELECT USER()", "SELECT CURRENT_USER");
  });
  it("SELECT CURRENT_USER -> SELECT CURRENT_USER", () => {
    validateIdentity("SELECT CURRENT_USER", "SELECT CURRENT_USER");
  });
  it.todo("CURRENT_SCHEMA (assert_is check)");
  it.todo("SELECT NOW() (unsupported syntax)");
});

describe("Exasol: qualify_unscoped_star", () => {
  it(" -> exasol: SELECT *, 1 FROM TEST", () => {
    const result = transpile("SELECT *, 1 FROM TEST", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TEST.*, 1 FROM TEST");
  });
  it("SELECT t.*, 1 FROM t", () => {
    validateIdentity("SELECT t.*, 1 FROM t");
  });
  it("SELECT t.* FROM t", () => {
    validateIdentity("SELECT t.* FROM t");
  });
  it("SELECT * FROM t", () => {
    validateIdentity("SELECT * FROM t");
  });
  it("WITH t AS (SELECT 1 AS x) SELECT t.*, 3 FROM t", () => {
    validateIdentity("WITH t AS (SELECT 1 AS x) SELECT t.*, 3 FROM t");
  });
  it(" -> exasol: WITH t1 AS (SELECT 1 AS c1), t2 AS (SELECT 2 AS c2) SELECT *, 3 FROM t1, t2", () => {
    const result = transpile("WITH t1 AS (SELECT 1 AS c1), t2 AS (SELECT 2 AS c2) SELECT *, 3 FROM t1, t2", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("WITH t1 AS (SELECT 1 AS c1), t2 AS (SELECT 2 AS c2) SELECT t1.*, t2.*, 3 FROM t1, t2");
  });
  it(' -> exasol: SELECT *, 3 FROM "A" JOIN "B" ON 1=1', () => {
    const result = transpile('SELECT *, 3 FROM "A" JOIN "B" ON 1=1', { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe('SELECT "A".*, "B".*, 3 FROM "A" JOIN "B" ON 1 = 1');
  });
  it(" -> exasol: SELECT *, 7 FROM (SELECT 1 AS x) s CROSS JOIN (SELECT 2 AS y) q", () => {
    const result = transpile("SELECT *, 7 FROM (SELECT 1 AS x) s CROSS JOIN (SELECT 2 AS y) q", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT s.*, q.*, 7 FROM (SELECT 1 AS x) AS s CROSS JOIN (SELECT 2 AS y) AS q");
  });
});

describe("Exasol: type_mappings", () => {
  it("CAST(x AS BLOB) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS BLOB)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS LONGBLOB) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS LONGBLOB)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS LONGTEXT) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS LONGTEXT)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS MEDIUMBLOB) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS MEDIUMBLOB)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS MEDIUMTEXT) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS MEDIUMTEXT)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS TINYBLOB) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS TINYBLOB)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS TINYTEXT) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS TINYTEXT)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS TEXT) -> CAST(x AS LONG VARCHAR)", () => {
    validateIdentity("CAST(x AS TEXT)", "CAST(x AS LONG VARCHAR)");
  });
  it("SELECT CAST((CAST(202305 AS INT) - 100) AS LONG VARCHAR) AS CAL_YEAR_WEEK_ADJUSTED", () => {
    validateIdentity("SELECT CAST((CAST(202305 AS INT) - 100) AS LONG VARCHAR) AS CAL_YEAR_WEEK_ADJUSTED");
  });
  it("CAST(x AS VARBINARY) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS VARBINARY)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS VARCHAR) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS VARCHAR)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS CHAR) -> CAST(x AS CHAR)", () => {
    validateIdentity("CAST(x AS CHAR)", "CAST(x AS CHAR)");
  });
  it("CAST(x AS TINYINT) -> CAST(x AS SMALLINT)", () => {
    validateIdentity("CAST(x AS TINYINT)", "CAST(x AS SMALLINT)");
  });
  it("CAST(x AS SMALLINT)", () => {
    validateIdentity("CAST(x AS SMALLINT)");
  });
  it("CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS INT)");
  });
  it("CAST(x AS MEDIUMINT) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS MEDIUMINT)", "CAST(x AS INT)");
  });
  it("CAST(x AS BIGINT)", () => {
    validateIdentity("CAST(x AS BIGINT)");
  });
  it("CAST(x AS FLOAT)", () => {
    validateIdentity("CAST(x AS FLOAT)");
  });
  it("CAST(x AS DOUBLE)", () => {
    validateIdentity("CAST(x AS DOUBLE)");
  });
  it("CAST(x AS DECIMAL32) -> CAST(x AS DECIMAL)", () => {
    validateIdentity("CAST(x AS DECIMAL32)", "CAST(x AS DECIMAL)");
  });
  it("CAST(x AS DECIMAL64) -> CAST(x AS DECIMAL)", () => {
    validateIdentity("CAST(x AS DECIMAL64)", "CAST(x AS DECIMAL)");
  });
  it("CAST(x AS DECIMAL128) -> CAST(x AS DECIMAL)", () => {
    validateIdentity("CAST(x AS DECIMAL128)", "CAST(x AS DECIMAL)");
  });
  it("CAST(x AS DECIMAL256) -> CAST(x AS DECIMAL)", () => {
    validateIdentity("CAST(x AS DECIMAL256)", "CAST(x AS DECIMAL)");
  });
  it("CAST(x AS DATE)", () => {
    validateIdentity("CAST(x AS DATE)");
  });
  it("CAST(x AS DATETIME) -> CAST(x AS TIMESTAMP)", () => {
    validateIdentity("CAST(x AS DATETIME)", "CAST(x AS TIMESTAMP)");
  });
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax)");
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax) (2)");
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax) (3)");
  it("CAST(x AS BOOLEAN)", () => {
    validateIdentity("CAST(x AS BOOLEAN)");
  });
  it.todo("CAST(x AS TIMESTAMPLTZ) (unsupported syntax)");
  it("CAST(x AS TIMESTAMP(3) WITH LOCAL TIME ZONE) -> CAST(x AS TIMESTAMP WITH LOCAL TIME ZONE)", () => {
    validateIdentity("CAST(x AS TIMESTAMP(3) WITH LOCAL TIME ZONE)", "CAST(x AS TIMESTAMP WITH LOCAL TIME ZONE)");
  });
});

describe("Exasol: mod", () => {
  it("exasol -> exasol: SELECT MOD(x, 10)", () => {
    const result = transpile("SELECT MOD(x, 10)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MOD(x, 10)");
  });
  it.todo("exasol -> teradata: SELECT MOD(x, 10) (cross-dialect transform)");
  it.todo("exasol -> mysql: SELECT MOD(x, 10) (cross-dialect transform)");
  it("exasol -> exasol: SELECT MOD(x, 10) (2)", () => {
    const result = transpile("SELECT MOD(x, 10)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT MOD(x, 10)");
  });
});

describe("Exasol: bits", () => {
  it("exasol -> exasol: SELECT BIT_AND(x, 1)", () => {
    const result = transpile("SELECT BIT_AND(x, 1)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_AND(x, 1)");
  });
  it("duckdb -> exasol: SELECT x & 1", () => {
    const result = transpile("SELECT x & 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_AND(x, 1)");
  });
  it.todo("presto -> exasol: SELECT BITWISE_AND(x, 1) (cross-dialect transform)");
  it("spark -> exasol: SELECT x & 1", () => {
    const result = transpile("SELECT x & 1", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_AND(x, 1)");
  });
  it("exasol -> exasol: SELECT BIT_AND(x, 1) (2)", () => {
    const result = transpile("SELECT BIT_AND(x, 1)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_AND(x, 1)");
  });
  it.todo("exasol -> duckdb: SELECT BIT_AND(x, 1) (cross-dialect transform)");
  it.todo("exasol -> hive: SELECT BIT_AND(x, 1) (cross-dialect transform)");
  it.todo("exasol -> presto: SELECT BIT_AND(x, 1) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT BIT_AND(x, 1) (cross-dialect transform)");
  it("exasol -> exasol: SELECT BIT_OR(x, 1)", () => {
    const result = transpile("SELECT BIT_OR(x, 1)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_OR(x, 1)");
  });
  it("duckdb -> exasol: SELECT x | 1", () => {
    const result = transpile("SELECT x | 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_OR(x, 1)");
  });
  it.todo("presto -> exasol: SELECT BITWISE_OR(x, 1) (cross-dialect transform)");
  it("spark -> exasol: SELECT x | 1", () => {
    const result = transpile("SELECT x | 1", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_OR(x, 1)");
  });
  it("exasol -> exasol: SELECT BIT_OR(x, 1) (2)", () => {
    const result = transpile("SELECT BIT_OR(x, 1)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_OR(x, 1)");
  });
  it.todo("exasol -> duckdb: SELECT BIT_OR(x, 1) (cross-dialect transform)");
  it.todo("exasol -> hive: SELECT BIT_OR(x, 1) (cross-dialect transform)");
  it.todo("exasol -> presto: SELECT BIT_OR(x, 1) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT BIT_OR(x, 1) (cross-dialect transform)");
  it.todo(" -> exasol: SELECT x ^ 1 (unsupported syntax)");
  it("exasol -> exasol: SELECT BIT_XOR(x, 1)", () => {
    const result = transpile("SELECT BIT_XOR(x, 1)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_XOR(x, 1)");
  });
  it.todo("bigquery -> exasol: SELECT x ^ 1 (unsupported syntax)");
  it.todo("presto -> exasol: SELECT BITWISE_XOR(x, 1) (cross-dialect transform)");
  it("postgres -> exasol: SELECT x # 1", () => {
    const result = transpile("SELECT x # 1", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_XOR(x, 1)");
  });
  it.todo("exasol -> : SELECT BIT_XOR(x, 1) (unsupported syntax)");
  it("exasol -> exasol: SELECT BIT_XOR(x, 1) (2)", () => {
    const result = transpile("SELECT BIT_XOR(x, 1)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_XOR(x, 1)");
  });
  it.todo("exasol -> bigquery: SELECT BIT_XOR(x, 1) (unsupported syntax)");
  it.todo("exasol -> duckdb: SELECT BIT_XOR(x, 1) (unsupported syntax)");
  it.todo("exasol -> presto: SELECT BIT_XOR(x, 1) (cross-dialect transform)");
  it.todo("exasol -> postgres: SELECT BIT_XOR(x, 1) (cross-dialect transform)");
  it("exasol -> exasol: SELECT BIT_NOT(x)", () => {
    const result = transpile("SELECT BIT_NOT(x)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_NOT(x)");
  });
  it.todo("duckdb -> exasol: SELECT ~x (unsupported syntax)");
  it.todo("presto -> exasol: SELECT BITWISE_NOT(x) (cross-dialect transform)");
  it.todo("spark -> exasol: SELECT ~x (unsupported syntax)");
  it("exasol -> exasol: SELECT BIT_NOT(x) (2)", () => {
    const result = transpile("SELECT BIT_NOT(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_NOT(x)");
  });
  it.todo("exasol -> duckdb: SELECT BIT_NOT(x) (unsupported syntax)");
  it.todo("exasol -> hive: SELECT BIT_NOT(x) (unsupported syntax)");
  it.todo("exasol -> presto: SELECT BIT_NOT(x) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT BIT_NOT(x) (unsupported syntax)");
  it("exasol -> exasol: SELECT BIT_LSHIFT(x, 1)", () => {
    const result = transpile("SELECT BIT_LSHIFT(x, 1)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_LSHIFT(x, 1)");
  });
  it.todo("spark -> exasol: SELECT SHIFTLEFT(x, 1) (cross-dialect transform)");
  it("duckdb -> exasol: SELECT x << 1", () => {
    const result = transpile("SELECT x << 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_LSHIFT(x, 1)");
  });
  it("hive -> exasol: SELECT x << 1", () => {
    const result = transpile("SELECT x << 1", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_LSHIFT(x, 1)");
  });
  it("exasol -> exasol: SELECT BIT_LSHIFT(x, 1) (2)", () => {
    const result = transpile("SELECT BIT_LSHIFT(x, 1)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_LSHIFT(x, 1)");
  });
  it.todo("exasol -> duckdb: SELECT BIT_LSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> presto: SELECT BIT_LSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> hive: SELECT BIT_LSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT BIT_LSHIFT(x, 1) (cross-dialect transform)");
  it("exasol -> exasol: SELECT BIT_RSHIFT(x, 1)", () => {
    const result = transpile("SELECT BIT_RSHIFT(x, 1)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_RSHIFT(x, 1)");
  });
  it.todo("spark -> exasol: SELECT SHIFTRIGHT(x, 1) (cross-dialect transform)");
  it("duckdb -> exasol: SELECT x >> 1", () => {
    const result = transpile("SELECT x >> 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_RSHIFT(x, 1)");
  });
  it("hive -> exasol: SELECT x >> 1", () => {
    const result = transpile("SELECT x >> 1", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_RSHIFT(x, 1)");
  });
  it("exasol -> exasol: SELECT BIT_RSHIFT(x, 1) (2)", () => {
    const result = transpile("SELECT BIT_RSHIFT(x, 1)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT BIT_RSHIFT(x, 1)");
  });
  it.todo("exasol -> duckdb: SELECT BIT_RSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> presto: SELECT BIT_RSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> hive: SELECT BIT_RSHIFT(x, 1) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT BIT_RSHIFT(x, 1) (cross-dialect transform)");
});

describe("Exasol: aggregateFunctions", () => {
  it("exasol -> exasol: SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROU...", () => {
    const result = transpile("SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROUP BY department", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROUP BY department");
  });
  it("exasol -> exasol: SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROU... (2)", () => {
    const result = transpile("SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROUP BY department", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROUP BY department");
  });
  it.todo("exasol -> duckdb: SELECT department, EVERY(age >= 30) AS EVERY FROM employee_table GROU... (cross-dialect transform)");
  it.todo("spark -> exasol: SELECT APPROX_COUNT_DISTINCT(y) (cross-dialect transform)");
  it("exasol -> exasol: SELECT APPROXIMATE_COUNT_DISTINCT(y)", () => {
    const result = transpile("SELECT APPROXIMATE_COUNT_DISTINCT(y)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROXIMATE_COUNT_DISTINCT(y)");
  });
  it.todo("exasol -> redshift: SELECT APPROXIMATE_COUNT_DISTINCT(y) (cross-dialect transform)");
  it.todo("exasol -> spark: SELECT APPROXIMATE_COUNT_DISTINCT(y) (cross-dialect transform)");
  it("exasol -> exasol: SELECT APPROXIMATE_COUNT_DISTINCT(y) (2)", () => {
    const result = transpile("SELECT APPROXIMATE_COUNT_DISTINCT(y)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT APPROXIMATE_COUNT_DISTINCT(y)");
  });
  it.todo("SELECT a, b, rank(b) OVER (ORDER BY b) FROM (VALUES ('A1', 2), ('A1... (unsupported syntax)");
});

describe("Exasol: stringFunctions", () => {
  it("TO_CHAR(CAST(TO_DATE(date, 'YYYYMMDD') AS TIMESTAMP), 'DY') AS day_of_week", () => {
    validateIdentity("TO_CHAR(CAST(TO_DATE(date, 'YYYYMMDD') AS TIMESTAMP), 'DY') AS day_of_week");
  });
  it("SELECT TO_CHAR(12345.67890, '9999999.999999999') AS TO_CHAR", () => {
    validateIdentity("SELECT TO_CHAR(12345.67890, '9999999.999999999') AS TO_CHAR");
  });
  it.todo("SELECT TO_CHAR(DATE '1999-12-31') AS TO_CHAR (unsupported syntax)");
  it.todo("SELECT TO_CHAR(TIMESTAMP '1999-12-31 23:59:00', 'HH24:MI:SS DD-MM-Y... (unsupported syntax)");
  it("SELECT TO_CHAR(12345.6789) AS TO_CHAR", () => {
    validateIdentity("SELECT TO_CHAR(12345.6789) AS TO_CHAR");
  });
  it("SELECT TO_CHAR(-12345.67890, '000G000G000D000000MI') AS TO_CHAR", () => {
    validateIdentity("SELECT TO_CHAR(-12345.67890, '000G000G000D000000MI') AS TO_CHAR");
  });
  it.todo("SELECT id, department, hire_date, GROUP_CONCAT(id ORDER BY hire_dat... (unsupported clause)");
  it.todo("GROUP_CONCAT(DISTINCT x ORDER BY y DESC) (unsupported syntax)");
  it("exasol -> exasol: EDIT_DISTANCE(col1, col2)", () => {
    const result = transpile("EDIT_DISTANCE(col1, col2)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("EDIT_DISTANCE(col1, col2)");
  });
  it.todo("bigquery -> exasol: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("clickhouse -> exasol: editDistance(col1, col2) (cross-dialect transform)");
  it.todo("drill -> exasol: LEVENSHTEIN_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("duckdb -> exasol: LEVENSHTEIN(col1, col2) (cross-dialect transform)");
  it.todo("hive -> exasol: LEVENSHTEIN(col1, col2) (cross-dialect transform)");
  it("exasol -> exasol: EDIT_DISTANCE(col1, col2) (2)", () => {
    const result = transpile("EDIT_DISTANCE(col1, col2)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("EDIT_DISTANCE(col1, col2)");
  });
  it.todo("exasol -> bigquery: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("exasol -> clickhouse: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("exasol -> drill: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("exasol -> duckdb: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("exasol -> hive: EDIT_DISTANCE(col1, col2) (cross-dialect transform)");
  it.todo("exasol -> exasol: STRPOS(haystack, needle) (unsupported syntax)");
  it.todo("exasol -> bigquery: STRPOS(haystack, needle) (unsupported syntax)");
  it.todo("exasol -> databricks: STRPOS(haystack, needle) (cross-dialect transform)");
  it.todo("exasol -> oracle: STRPOS(haystack, needle) (unsupported syntax)");
  it.todo("exasol -> presto: STRPOS(haystack, needle) (cross-dialect transform)");
  it("exasol -> exasol: SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)[a-...", () => {
    const result = transpile("SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}') AS EMAIL", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}') AS EMAIL");
  });
  it.todo("exasol -> bigquery: SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)[... (cross-dialect transform)");
  it.todo("exasol -> snowflake: SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)... (cross-dialect transform)");
  it.todo("exasol -> presto: SELECT REGEXP_SUBSTR('My mail address is my_mail@yahoo.com', '(?i)[a-... (cross-dialect transform)");
  it.todo("SELECT SUBSTR('www.apache.org', 1, NVL(NULLIF(INSTR('www.apache.org... (unsupported syntax)");
  it.todo("SELECT SUBSTR('555A66A777', 1, NVL(NULLIF(INSTR('555A66A777', 'a', ... (unsupported syntax)");
  it.todo("SELECT SUBSTR('555A66A777', 1, NVL(NULLIF(INSTR(LOWER('555A66A777')... (unsupported syntax)");
  it.todo("SELECT SUBSTR('A|a|A', 1, NVL(NULLIF(INSTR(LOWER('A|a|A'), LOWER('A... (unsupported syntax)");
});

describe("Exasol: datetime_functions", () => {
  it("SELECT TO_DATE('31-12-1999', 'dd-mm-yyyy') AS TO_DATE -> SELECT TO_DATE('31-12-1999', '...", () => {
    validateIdentity("SELECT TO_DATE('31-12-1999', 'dd-mm-yyyy') AS TO_DATE", "SELECT TO_DATE('31-12-1999', 'DD-MM-YYYY') AS TO_DATE");
  });
  it("SELECT TO_DATE('31-12-1999', 'dd-mm-YY') AS TO_DATE -> SELECT TO_DATE('31-12-1999', 'DD...", () => {
    validateIdentity("SELECT TO_DATE('31-12-1999', 'dd-mm-YY') AS TO_DATE", "SELECT TO_DATE('31-12-1999', 'DD-MM-YY') AS TO_DATE");
  });
  it("SELECT TO_DATE('31-DECEMBER-1999', 'DD-MONTH-YYYY') AS TO_DATE", () => {
    validateIdentity("SELECT TO_DATE('31-DECEMBER-1999', 'DD-MONTH-YYYY') AS TO_DATE");
  });
  it("SELECT TO_DATE('31-DEC-1999', 'DD-MON-YYYY') AS TO_DATE", () => {
    validateIdentity("SELECT TO_DATE('31-DEC-1999', 'DD-MON-YYYY') AS TO_DATE");
  });
  it("SELECT WEEKOFYEAR('2024-05-22') -> SELECT WEEK('2024-05-22')", () => {
    validateIdentity("SELECT WEEKOFYEAR('2024-05-22')", "SELECT WEEK('2024-05-22')");
  });
  it.todo("SELECT TO_CHAR(CAST('2024-07-08 13:45:00' AS TIMESTAMP), 'DY') (unsupported syntax)");
  it("exasol -> exasol: TO_DATE(x, 'YYYY-MM-DD')", () => {
    const result = transpile("TO_DATE(x, 'YYYY-MM-DD')", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("TO_DATE(x, 'YYYY-MM-DD')");
  });
  it.todo("exasol -> duckdb: TO_DATE(x, 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("exasol -> hive: TO_DATE(x, 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("exasol -> presto: TO_DATE(x, 'YYYY-MM-DD') (unsupported syntax)");
  it.todo("exasol -> spark: TO_DATE(x, 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("exasol -> snowflake: TO_DATE(x, 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("exasol -> databricks: TO_DATE(x, 'YYYY-MM-DD') (cross-dialect transform)");
  it("exasol -> exasol: TO_DATE(x, 'YYYY')", () => {
    const result = transpile("TO_DATE(x, 'YYYY')", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("TO_DATE(x, 'YYYY')");
  });
  it.todo("exasol -> duckdb: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("exasol -> hive: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("exasol -> presto: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("exasol -> spark: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("exasol -> snowflake: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("exasol -> databricks: TO_DATE(x, 'YYYY') (cross-dialect transform)");
  it.todo("SELECT CONVERT_TZ(CAST('2012-03-25 02:30:00' AS TIMESTAMP), 'Europe... (unsupported syntax)");
  it.todo("SELECT CONVERT_TZ('2012-05-10 12:00:00', 'Europe/Berlin', 'America/... (unsupported syntax)");
  it.todo("TIME_TO_STR(b, '%Y-%m-%d %H:%M:%S') (unsupported syntax)");
  it.todo("SELECT TIME_TO_STR(CAST(STR_TO_TIME(date, '%Y%m%d') AS DATE), '%a')... (unsupported syntax)");
  it.todo("SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIMESTAMP) AT TIME ZONE 'CE... (unsupported syntax)");
  it.todo("test_datetime_functions: unresolvable for-loop iterable");
  it.todo("test_datetime_functions: unresolvable for-loop iterable (2)");
  it("exasol -> exasol: SELECT quarter('2016-08-31')", () => {
    const result = transpile("SELECT quarter('2016-08-31')", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT CEIL(MONTH(TO_DATE('2016-08-31'))/3)");
  });
  it("exasol -> databricks: SELECT quarter('2016-08-31')", () => {
    const result = transpile("SELECT quarter('2016-08-31')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT QUARTER('2016-08-31')");
  });
});

describe("Exasol: number_functions", () => {
  it("SELECT TRUNC(123.456, 2) AS TRUNC", () => {
    validateIdentity("SELECT TRUNC(123.456, 2) AS TRUNC");
  });
  it("SELECT DIV(1234, 2) AS DIV", () => {
    validateIdentity("SELECT DIV(1234, 2) AS DIV");
  });
  it.todo("TRUNC(123.456, 2) (assert_is check)");
  it.todo("TRUNC(3.14159) (assert_is check)");
  it.todo("test_number_functions: parse_one call");
  it.todo("test_number_functions: parse_one call (2)");
  it.todo("test_number_functions: parse_one call (3)");
  it.todo("TRUNC(CAST(x AS DATE)) (assert_is check)");
  it.todo("TRUNC(price, 2) (DDL/DML in read/write)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'YYYY') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'MM') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'DD') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'HH') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'MI') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'SS') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'WW') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'Q') (unsupported syntax)");
});

describe("Exasol: scalar", () => {
  it("exasol -> exasol: SELECT USER", () => {
    const result = transpile("SELECT USER", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_USER");
  });
  it.todo("spark -> exasol: SELECT CURRENT_USER() (cross-dialect transform)");
  it.todo("trino -> exasol: SELECT CURRENT_USER (cross-dialect transform)");
  it.todo("snowflake -> exasol: SELECT CURRENT_USER() (cross-dialect transform)");
  it("exasol -> exasol: SELECT CURRENT_USER", () => {
    const result = transpile("SELECT CURRENT_USER", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT CURRENT_USER");
  });
  it.todo("exasol -> spark: SELECT CURRENT_USER (cross-dialect transform)");
  it.todo("exasol -> trino: SELECT CURRENT_USER (cross-dialect transform)");
  it.todo("exasol -> snowflake: SELECT CURRENT_USER (cross-dialect transform)");
  it.todo(`CREATE OR REPLACE VIEW "schema"."v" ("col" COMMENT IS 'desc') AS SE... (DDL/DML not supported)`);
  it.todo("clickhouse -> exasol: SHA1(x) (cross-dialect transform)");
  it("exasol -> exasol: HASH_SHA1(x)", () => {
    const result = transpile("HASH_SHA1(x)", { readDialect: "exasol", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA(x)");
  });
  it.todo("presto -> exasol: SHA1(x) (cross-dialect transform)");
  it.todo("trino -> exasol: SHA1(x) (cross-dialect transform)");
  it("exasol -> exasol: HASH_SHA(x)", () => {
    const result = transpile("HASH_SHA(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("HASH_SHA(x)");
  });
  it.todo("exasol -> clickhouse: HASH_SHA(x) (cross-dialect transform)");
  it.todo("exasol -> bigquery: HASH_SHA(x) (cross-dialect transform)");
  it.todo("exasol -> : HASH_SHA(x) (cross-dialect transform)");
  it.todo("exasol -> presto: HASH_SHA(x) (cross-dialect transform)");
  it.todo("exasol -> trino: HASH_SHA(x) (cross-dialect transform)");
  it("exasol -> exasol: HASH_MD5(x)", () => {
    const result = transpile("HASH_MD5(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("HASH_MD5(x)");
  });
  it.todo("exasol -> : HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> bigquery: HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> clickhouse: HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> hive: HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> presto: HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> spark: HASH_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> trino: HASH_MD5(x) (cross-dialect transform)");
  it("exasol -> exasol: HASHTYPE_MD5(x)", () => {
    const result = transpile("HASHTYPE_MD5(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("HASHTYPE_MD5(x)");
  });
  it("exasol -> : HASHTYPE_MD5(x)", () => {
    const result = transpile("HASHTYPE_MD5(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("MD5_DIGEST(x)");
  });
  it.todo("exasol -> bigquery: HASHTYPE_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> clickhouse: HASHTYPE_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> hive: HASHTYPE_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> presto: HASHTYPE_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> spark: HASHTYPE_MD5(x) (cross-dialect transform)");
  it.todo("exasol -> trino: HASHTYPE_MD5(x) (cross-dialect transform)");
  it("clickhouse -> exasol: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("presto -> exasol: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("trino -> exasol: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("postgres -> exasol: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("duckdb -> exasol: SHA256(x)", () => {
    const result = transpile("SHA256(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("exasol -> exasol: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("HASH_SHA256(x)");
  });
  it("exasol -> bigquery: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> spark2: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SHA2(x, 256)");
  });
  it("exasol -> clickhouse: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> postgres: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> presto: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> redshift: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SHA2(x, 256)");
  });
  it("exasol -> trino: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> duckdb: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SHA256(x)");
  });
  it("exasol -> snowflake: HASH_SHA256(x)", () => {
    const result = transpile("HASH_SHA256(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SHA2(x, 256)");
  });
  it("clickhouse -> exasol: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA512(x)");
  });
  it("presto -> exasol: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA512(x)");
  });
  it("trino -> exasol: SHA512(x)", () => {
    const result = transpile("SHA512(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("HASH_SHA512(x)");
  });
  it("exasol -> exasol: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("HASH_SHA512(x)");
  });
  it("exasol -> clickhouse: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("exasol -> bigquery: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("exasol -> spark2: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SHA2(x, 512)");
  });
  it("exasol -> presto: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("exasol -> trino: HASH_SHA512(x)", () => {
    const result = transpile("HASH_SHA512(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SHA512(x)");
  });
  it("exasol -> exasol: SELECT NULLIFZERO(1) NIZ1", () => {
    const result = transpile("SELECT NULLIFZERO(1) NIZ1", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT IF 1 = 0 THEN NULL ELSE 1 ENDIF AS NIZ1");
  });
  it.todo("exasol -> snowflake: SELECT NULLIFZERO(1) NIZ1 (cross-dialect transform)");
  it.todo("exasol -> sqlite: SELECT NULLIFZERO(1) NIZ1 (cross-dialect transform)");
  it("exasol -> presto: SELECT NULLIFZERO(1) NIZ1", () => {
    const result = transpile("SELECT NULLIFZERO(1) NIZ1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT IF(1 = 0, NULL, 1) AS NIZ1");
  });
  it("exasol -> spark: SELECT NULLIFZERO(1) NIZ1", () => {
    const result = transpile("SELECT NULLIFZERO(1) NIZ1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT IF(1 = 0, NULL, 1) AS NIZ1");
  });
  it("exasol -> hive: SELECT NULLIFZERO(1) NIZ1", () => {
    const result = transpile("SELECT NULLIFZERO(1) NIZ1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT IF(1 = 0, NULL, 1) AS NIZ1");
  });
  it("exasol -> duckdb: SELECT NULLIFZERO(1) NIZ1", () => {
    const result = transpile("SELECT NULLIFZERO(1) NIZ1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN 1 = 0 THEN NULL ELSE 1 END AS NIZ1");
  });
  it("exasol -> exasol: SELECT ZEROIFNULL(NULL) NIZ1", () => {
    const result = transpile("SELECT ZEROIFNULL(NULL) NIZ1", { readDialect: DIALECT, writeDialect: "exasol" })[0];
    expect(result).toBe("SELECT IF NULL IS NULL THEN 0 ELSE NULL ENDIF AS NIZ1");
  });
  it.todo("exasol -> snowflake: SELECT ZEROIFNULL(NULL) NIZ1 (cross-dialect transform)");
  it.todo("exasol -> sqlite: SELECT ZEROIFNULL(NULL) NIZ1 (cross-dialect transform)");
  it("exasol -> presto: SELECT ZEROIFNULL(NULL) NIZ1", () => {
    const result = transpile("SELECT ZEROIFNULL(NULL) NIZ1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT IF(NULL IS NULL, 0, NULL) AS NIZ1");
  });
  it("exasol -> spark: SELECT ZEROIFNULL(NULL) NIZ1", () => {
    const result = transpile("SELECT ZEROIFNULL(NULL) NIZ1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT IF(NULL IS NULL, 0, NULL) AS NIZ1");
  });
  it("exasol -> hive: SELECT ZEROIFNULL(NULL) NIZ1", () => {
    const result = transpile("SELECT ZEROIFNULL(NULL) NIZ1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT IF(NULL IS NULL, 0, NULL) AS NIZ1");
  });
  it("exasol -> duckdb: SELECT ZEROIFNULL(NULL) NIZ1", () => {
    const result = transpile("SELECT ZEROIFNULL(NULL) NIZ1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN NULL IS NULL THEN 0 ELSE NULL END AS NIZ1");
  });
  it("SELECT name, age, IF age < 18 THEN 'underaged' ELSE 'adult' ENDIF AS LEGALITY FROM persons", () => {
    validateIdentity("SELECT name, age, IF age < 18 THEN 'underaged' ELSE 'adult' ENDIF AS LEGALITY FROM persons");
  });
  it("SELECT HASHTYPE_MD5(a, b, c, d)", () => {
    validateIdentity("SELECT HASHTYPE_MD5(a, b, c, d)");
  });
});

describe("Exasol: odbc_date_literals", () => {
  it("SELECT {d'2024-01-01'} -> SELECT TO_DATE('2024-01-01')", () => {
    validateIdentity("SELECT {d'2024-01-01'}", "SELECT TO_DATE('2024-01-01')");
  });
  it("SELECT {ts'2024-01-01 12:00:00'} -> SELECT TO_TIMESTAMP('2024-01-01 12:00:00')", () => {
    validateIdentity("SELECT {ts'2024-01-01 12:00:00'}", "SELECT TO_TIMESTAMP('2024-01-01 12:00:00')");
  });
});

describe("Exasol: local_prefix_for_alias", () => {
  it('SELECT ID FROM local WHERE "LOCAL".ID IS NULL -> SELECT ID FROM "LOCAL" WHERE "LOCAL".I...', () => {
    validateIdentity('SELECT ID FROM local WHERE "LOCAL".ID IS NULL', 'SELECT ID FROM "LOCAL" WHERE "LOCAL".ID IS NULL');
  });
  it('SELECT YEAR(a_date) AS "a_year" FROM MY_SUMMARY_TABLE GROUP BY LOCAL."a_year"', () => {
    validateIdentity('SELECT YEAR(a_date) AS "a_year" FROM MY_SUMMARY_TABLE GROUP BY LOCAL."a_year"');
  });
  it('SELECT a_year AS a_year FROM "LOCAL" GROUP BY "LOCAL".a_year', () => {
    validateIdentity('SELECT a_year AS a_year FROM "LOCAL" GROUP BY "LOCAL".a_year');
  });
});
