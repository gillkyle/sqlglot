// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "redshift";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Redshift: redshift", () => {
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it("ROUND(CAST(a AS DOUBLE PRECISION) / CAST(b AS DOUBLE PRECISION), 2)", () => {
    validateIdentity("ROUND(CAST(a AS DOUBLE PRECISION) / CAST(b AS DOUBLE PRECISION), 2)");
  });
  it.todo("SELECT SPLIT_TO_ARRAY('12,345,6789') (unsupported syntax)");
  it("duckdb -> redshift: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("GETDATE()");
  });
  it.todo("redshift -> duckdb: GETDATE() (cross-dialect transform)");
  it("redshift -> redshift: GETDATE()", () => {
    const result = transpile("GETDATE()", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("GETDATE()");
  });
  it.todo(`SELECT JSON_EXTRACT_PATH_TEXT('{ "farm": {"barn": { "color": "red",... (unsupported syntax)`);
  it.todo("duckdb -> redshift: STRING_AGG(sellerid, ', ') (unsupported syntax)");
  it.todo("databricks -> redshift: STRING_AGG(sellerid, ', ') (unsupported syntax)");
  it("redshift -> duckdb: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LISTAGG(sellerid, ', ')");
  });
  it("redshift -> redshift: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("LISTAGG(sellerid, ', ')");
  });
  it("redshift -> spark, version=3.0.0: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "spark, version=3.0.0" })[0];
    expect(result).toBe("ARRAY_JOIN(COLLECT_LIST(sellerid), ', ')");
  });
  it("redshift -> spark, version=4.0.0: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "spark, version=4.0.0" })[0];
    expect(result).toBe("LISTAGG(sellerid, ', ')");
  });
  it("redshift -> spark: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LISTAGG(sellerid, ', ')");
  });
  it("redshift -> databricks: LISTAGG(sellerid, ', ')", () => {
    const result = transpile("LISTAGG(sellerid, ', ')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("LISTAGG(sellerid, ', ')");
  });
  it("spark -> redshift: SELECT APPROX_COUNT_DISTINCT(y)", () => {
    const result = transpile("SELECT APPROX_COUNT_DISTINCT(y)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROXIMATE COUNT(DISTINCT y)");
  });
  it("redshift -> redshift: SELECT APPROXIMATE COUNT(DISTINCT y)", () => {
    const result = transpile("SELECT APPROXIMATE COUNT(DISTINCT y)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT APPROXIMATE COUNT(DISTINCT y)");
  });
  it("redshift -> spark: SELECT APPROXIMATE COUNT(DISTINCT y)", () => {
    const result = transpile("SELECT APPROXIMATE COUNT(DISTINCT y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(y)");
  });
  it.todo("x ~* 'pat' (unsupported syntax)");
  it("postgres -> redshift: SELECT CAST('01:03:05.124' AS TIMETZ(2))", () => {
    const result = transpile("SELECT CAST('01:03:05.124' AS TIMETZ(2))", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)");
  });
  it("redshift -> postgres: SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)", () => {
    const result = transpile("SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT CAST('01:03:05.124' AS TIMETZ(2))");
  });
  it("redshift -> redshift: SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)", () => {
    const result = transpile("SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT CAST('01:03:05.124' AS TIME(2) WITH TIME ZONE)");
  });
  it("postgres -> redshift: SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMPTZ(2))", () => {
    const result = transpile("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMPTZ(2))", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME ZONE)");
  });
  it("redshift -> postgres: SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME Z...", () => {
    const result = transpile("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMPTZ(2))");
  });
  it("redshift -> redshift: SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME Z...", () => {
    const result = transpile("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT CAST('2020-02-02 01:03:05.124' AS TIMESTAMP(2) WITH TIME ZONE)");
  });
  it.todo(" -> redshift: SELECT INTERVAL '5' days (unsupported syntax)");
  it.todo("redshift -> bigquery: SELECT ADD_MONTHS('2008-03-31', 1) (unsupported syntax)");
  it.todo("redshift -> duckdb: SELECT ADD_MONTHS('2008-03-31', 1) (unsupported syntax)");
  it("redshift -> redshift: SELECT ADD_MONTHS('2008-03-31', 1)", () => {
    const result = transpile("SELECT ADD_MONTHS('2008-03-31', 1)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT DATEADD(MONTH, 1, '2008-03-31')");
  });
  it.todo("redshift -> trino: SELECT ADD_MONTHS('2008-03-31', 1) (unsupported syntax)");
  it.todo("redshift -> tsql: SELECT ADD_MONTHS('2008-03-31', 1) (cross-dialect transform)");
  it("trino -> redshift: SELECT FROM_BASE('abc', 16)", () => {
    const result = transpile("SELECT FROM_BASE('abc', 16)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT STRTOL('abc', 16)");
  });
  it("redshift -> redshift: SELECT STRTOL('abc', 16)", () => {
    const result = transpile("SELECT STRTOL('abc', 16)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT STRTOL('abc', 16)");
  });
  it("redshift -> trino: SELECT STRTOL('abc', 16)", () => {
    const result = transpile("SELECT STRTOL('abc', 16)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT FROM_BASE('abc', 16)");
  });
  it("redshift -> : SELECT SNAPSHOT, type", () => {
    const result = transpile("SELECT SNAPSHOT, type", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT SNAPSHOT, type");
  });
  it("redshift -> redshift: SELECT SNAPSHOT, type", () => {
    const result = transpile("SELECT SNAPSHOT, type", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe('SELECT "SNAPSHOT", "type"');
  });
  it("redshift -> redshift: x is true", () => {
    const result = transpile("x is true", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("x IS TRUE");
  });
  it("redshift -> presto: x is true", () => {
    const result = transpile("x is true", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("x");
  });
  it("redshift -> redshift: x is false", () => {
    const result = transpile("x is false", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("x IS FALSE");
  });
  it("redshift -> presto: x is false", () => {
    const result = transpile("x is false", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("NOT x");
  });
  it("redshift -> redshift: x is not false", () => {
    const result = transpile("x is not false", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("NOT x IS FALSE");
  });
  it("redshift -> presto: x is not false", () => {
    const result = transpile("x is not false", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("NOT NOT x");
  });
  it("redshift -> redshift: LEN(x)", () => {
    const result = transpile("LEN(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("LENGTH(x)");
  });
  it("redshift -> presto: LEN(x)", () => {
    const result = transpile("LEN(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("LENGTH(x)");
  });
  it.todo("x LIKE 'abc' || '%' (unsupported syntax)");
  it("redshift -> : SELECT SYSDATE", () => {
    const result = transpile("SELECT SYSDATE", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP()");
  });
  it("redshift -> postgres: SELECT SYSDATE", () => {
    const result = transpile("SELECT SYSDATE", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP");
  });
  it("redshift -> redshift: SELECT SYSDATE", () => {
    const result = transpile("SELECT SYSDATE", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT SYSDATE");
  });
  it.todo("SELECT DATE_PART(minute, timestamp '2023-01-04 04:05:06.789') (unsupported syntax)");
  it.todo("SELECT DATE_PART(month, date '20220502') (unsupported syntax)");
  it.todo('create table "group" ("col" char(10)) (DDL/DML not supported)');
  it.todo('create table if not exists city_slash_id("city/id" integer not null... (DDL/DML not supported)');
  it.todo("SELECT ST_AsEWKT(ST_GeomFromEWKT('SRID=4326;POINT(10 20)')::geography) (unsupported syntax)");
  it.todo("SELECT ST_AsEWKT(ST_GeogFromText('LINESTRING(110 40, 2 3, -10 80, -... (unsupported syntax)");
  it.todo("SELECT 'abc'::BINARY (unsupported syntax)");
  it.todo("CREATE TABLE a (b BINARY VARYING(10)) (DDL/DML not supported)");
  it.todo("SELECT 'abc'::CHARACTER (unsupported syntax)");
  it.todo("redshift -> bigquery: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> databricks: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> drill: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> hive: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it("redshift -> mysql: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END DESC, c DESC) AS _row_number FROM x) AS _t WHERE _row_number = 1");
  });
  it("redshift -> oracle: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY c DESC) AS _row_number FROM x) _t WHERE _row_number = 1");
  });
  it.todo("redshift -> presto: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it("redshift -> redshift: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY c DESC) AS _row_number FROM x) AS _t WHERE _row_number = 1");
  });
  it("redshift -> snowflake: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY c DESC) AS _row_number FROM x) AS _t WHERE _row_number = 1");
  });
  it.todo("redshift -> spark: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> sqlite: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it("redshift -> starrocks: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END DESC, c DESC) AS _row_number FROM x) AS _t WHERE _row_number = 1");
  });
  it.todo("redshift -> tableau: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> teradata: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it.todo("redshift -> trino: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC (unsupported syntax)");
  it("redshift -> tsql: SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", () => {
    const result = transpile("SELECT DISTINCT ON (a) a, b FROM x ORDER BY c DESC", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT a AS a, b AS b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END DESC, c DESC) AS _row_number FROM x) AS _t WHERE _row_number = 1");
  });
  it("redshift -> : DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d)");
  });
  it("redshift -> duckdb: DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN x = a OR (x IS NULL AND a IS NULL) THEN b WHEN x = c OR (x IS NULL AND c IS NULL) THEN d END");
  });
  it("redshift -> oracle: DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d)");
  });
  it("redshift -> redshift: DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d)");
  });
  it("redshift -> snowflake: DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d)");
  });
  it("redshift -> spark: DECODE(x, a, b, c, d)", () => {
    const result = transpile("DECODE(x, a, b, c, d)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d)");
  });
  it("redshift -> redshift: NVL(a, b, c, d)", () => {
    const result = transpile("NVL(a, b, c, d)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("COALESCE(a, b, c, d)");
  });
  it("redshift -> mysql: NVL(a, b, c, d)", () => {
    const result = transpile("NVL(a, b, c, d)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("COALESCE(a, b, c, d)");
  });
  it("redshift -> postgres: NVL(a, b, c, d)", () => {
    const result = transpile("NVL(a, b, c, d)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("COALESCE(a, b, c, d)");
  });
  it("DATEDIFF(days, a, b) -> DATEDIFF(DAY, a, b)", () => {
    validateIdentity("DATEDIFF(days, a, b)", "DATEDIFF(DAY, a, b)");
  });
  it.todo("redshift -> bigquery: DATEDIFF('day', a, b) (cross-dialect transform)");
  it.todo("redshift -> duckdb: DATEDIFF('day', a, b) (unsupported syntax)");
  it.todo("redshift -> hive: DATEDIFF('day', a, b) (cross-dialect transform)");
  it("redshift -> redshift: DATEDIFF('day', a, b)", () => {
    const result = transpile("DATEDIFF('day', a, b)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("DATEDIFF(DAY, a, b)");
  });
  it.todo("redshift -> presto: DATEDIFF('day', a, b) (unsupported syntax)");
  it.todo("redshift -> bigquery: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it.todo("redshift -> duckdb: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it.todo("redshift -> hive: SELECT DATEADD(month, 18, '2008-02-28') (cross-dialect transform)");
  it.todo("redshift -> mysql: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it.todo("redshift -> postgres: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it.todo("redshift -> presto: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it("redshift -> redshift: SELECT DATEADD(month, 18, '2008-02-28')", () => {
    const result = transpile("SELECT DATEADD(month, 18, '2008-02-28')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT DATEADD(MONTH, 18, '2008-02-28')");
  });
  it.todo("redshift -> snowflake: SELECT DATEADD(month, 18, '2008-02-28') (unsupported syntax)");
  it.todo("redshift -> tsql: SELECT DATEADD(month, 18, '2008-02-28') (cross-dialect transform)");
  it.todo("redshift -> spark: SELECT DATEADD(month, 18, '2008-02-28') (cross-dialect transform)");
  it.todo("redshift -> spark2: SELECT DATEADD(month, 18, '2008-02-28') (cross-dialect transform)");
  it.todo("redshift -> databricks: SELECT DATEADD(month, 18, '2008-02-28') (cross-dialect transform)");
  it.todo("redshift -> bigquery: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (cross-dialect transform)");
  it.todo("redshift -> duckdb: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (unsupported syntax)");
  it.todo("redshift -> hive: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (cross-dialect transform)");
  it.todo("redshift -> postgres: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (unsupported syntax)");
  it.todo("redshift -> presto: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (unsupported syntax)");
  it("redshift -> redshift: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31')", () => {
    const result = transpile("SELECT DATEDIFF(week, '2009-01-01', '2009-12-31')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT DATEDIFF(WEEK, '2009-01-01', '2009-12-31')");
  });
  it.todo("redshift -> snowflake: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (cross-dialect transform)");
  it.todo("redshift -> tsql: SELECT DATEDIFF(week, '2009-01-01', '2009-12-31') (cross-dialect transform)");
  it("redshift -> snowflake: SELECT EXTRACT(EPOCH FROM CURRENT_DATE)", () => {
    const result = transpile("SELECT EXTRACT(EPOCH FROM CURRENT_DATE)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH, CURRENT_DATE)");
  });
  it("redshift -> redshift: SELECT EXTRACT(EPOCH FROM CURRENT_DATE)", () => {
    const result = transpile("SELECT EXTRACT(EPOCH FROM CURRENT_DATE)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT EXTRACT(EPOCH FROM CURRENT_DATE)");
  });
  it("SELECT VERSION()", () => {
    validateIdentity("SELECT VERSION()");
  });
});

describe("Redshift: identity", () => {
  it("SELECT GETBIT(FROM_HEX('4d'), 2)", () => {
    validateIdentity("SELECT GETBIT(FROM_HEX('4d'), 2)");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it.todo("ALTER TABLE table_name ALTER COLUMN bla TYPE VARCHAR (DDL/DML not supported)");
  it("SELECT CAST(value AS FLOAT(8))", () => {
    validateIdentity("SELECT CAST(value AS FLOAT(8))");
  });
  it("1 div -> 1 AS div", () => {
    validateIdentity("1 div", "1 AS div");
  });
  it("LISTAGG(DISTINCT foo, ', ')", () => {
    validateIdentity("LISTAGG(DISTINCT foo, ', ')");
  });
  it.todo("CREATE MATERIALIZED VIEW orders AUTO REFRESH YES AS SELECT 1 (DDL/DML not supported)");
  it("SELECT DATEADD(DAY, 1, 'today')", () => {
    validateIdentity("SELECT DATEADD(DAY, 1, 'today')");
  });
  it("SELECT * FROM #x", () => {
    validateIdentity("SELECT * FROM #x");
  });
  it("SELECT INTERVAL '5 DAY'", () => {
    validateIdentity("SELECT INTERVAL '5 DAY'");
  });
  it("foo$", () => {
    validateIdentity("foo$");
  });
  it("CAST('bla' AS SUPER)", () => {
    validateIdentity("CAST('bla' AS SUPER)");
  });
  it.todo("CREATE TABLE real1 (realcol REAL) (DDL/DML not supported)");
  it("CAST('foo' AS HLLSKETCH)", () => {
    validateIdentity("CAST('foo' AS HLLSKETCH)");
  });
  it("'abc' SIMILAR TO '(b|c)%'", () => {
    validateIdentity("'abc' SIMILAR TO '(b|c)%'");
  });
  it.todo("CREATE TABLE datetable (start_date DATE, end_date DATE) (DDL/DML not supported)");
  it("SELECT APPROXIMATE AS y", () => {
    validateIdentity("SELECT APPROXIMATE AS y");
  });
  it.todo("CREATE TABLE t (c BIGINT IDENTITY(0, 1)) (DDL/DML not supported)");
  it.todo("COPY test_staging_tbl FROM 's3://your/bucket/prefix/here' IAM_ROLE ... (command not supported)");
  it.todo("COPY test_staging_tbl FROM 's3://your/bucket/prefix/here' IAM_ROLE ... (command not supported) (2)");
  it("SELECT * FROM venue WHERE (venuecity, venuestate) IN (('Miami', 'FL'), ('Tampa', 'FL'))...", () => {
    validateIdentity("SELECT * FROM venue WHERE (venuecity, venuestate) IN (('Miami', 'FL'), ('Tampa', 'FL')) ORDER BY venueid");
  });
  it(`SELECT tablename, "column" FROM pg_table_def WHERE "column" LIKE '%start\\\\_%' LIMIT 5`, () => {
    validateIdentity(`SELECT tablename, "column" FROM pg_table_def WHERE "column" LIKE '%start\\\\_%' LIMIT 5`);
  });
  it(`SELECT JSON_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"star"}', 'f4', 'f6', ...`, () => {
    validateIdentity(`SELECT JSON_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"star"}', 'f4', 'f6', TRUE)`);
  });
  it("SELECT CONCAT('abc', 'def') -> SELECT 'abc' || 'def'", () => {
    validateIdentity("SELECT CONCAT('abc', 'def')", "SELECT 'abc' || 'def'");
  });
  it("SELECT CONCAT_WS('DELIM', 'abc', 'def', 'ghi') -> SELECT 'abc' || 'DELIM' || 'def' || '...", () => {
    validateIdentity("SELECT CONCAT_WS('DELIM', 'abc', 'def', 'ghi')", "SELECT 'abc' || 'DELIM' || 'def' || 'DELIM' || 'ghi'");
  });
  it("SELECT TOP 1 x FROM y -> SELECT x FROM y LIMIT 1", () => {
    validateIdentity("SELECT TOP 1 x FROM y", "SELECT x FROM y LIMIT 1");
  });
  it.todo("SELECT DATE_DIFF('month', CAST('2020-02-29 00:00:00' AS TIMESTAMP),... (unsupported syntax)");
  it("SELECT * FROM x WHERE y = DATEADD('month', -1, DATE_TRUNC('month', (SELECT y FROM #temp...", () => {
    validateIdentity("SELECT * FROM x WHERE y = DATEADD('month', -1, DATE_TRUNC('month', (SELECT y FROM #temp_table)))", "SELECT * FROM x WHERE y = DATEADD(MONTH, -1, DATE_TRUNC('MONTH', (SELECT y FROM #temp_table)))");
  });
  it.todo("SELECT 'a''b' (unsupported syntax)");
  it.todo("CREATE TABLE t (c BIGINT GENERATED BY DEFAULT AS IDENTITY (0, 1)) (DDL/DML not supported)");
  it.todo("SELECT DATEADD(HOUR, 0, CAST('2020-02-02 01:03:05.124' AS TIMESTAMP)) (unsupported syntax)");
  it("SELECT DATEDIFF(SECOND, '2020-02-02 00:00:00.000', '2020-02-02 01:03:05.124')", () => {
    validateIdentity("SELECT DATEDIFF(SECOND, '2020-02-02 00:00:00.000', '2020-02-02 01:03:05.124')");
  });
  it.todo("CREATE OR REPLACE VIEW v1 AS SELECT id, AVG(average_metric1) AS m1,... (DDL/DML not supported)");
  it.todo("SELECT caldate + INTERVAL '1 SECOND' AS dateplus FROM date WHERE ca... (unsupported syntax)");
  it("SELECT COUNT(*) FROM event WHERE eventname LIKE '%Ring%' OR eventname LIKE '%Die%'", () => {
    validateIdentity("SELECT COUNT(*) FROM event WHERE eventname LIKE '%Ring%' OR eventname LIKE '%Die%'");
  });
  it.todo("CREATE TABLE SOUP (LIKE other_table) DISTKEY(soup1) SORTKEY(soup2) ... (DDL/DML not supported)");
  it.todo("CREATE TABLE sales (salesid INTEGER NOT NULL) DISTKEY(listid) COMPO... (DDL/DML not supported)");
  it.todo("COPY customer FROM 's3://mybucket/customer' IAM_ROLE 'arn:aws:iam::... (command not supported)");
  it.todo("COPY customer FROM 's3://mybucket/mydata' CREDENTIALS 'aws_iam_role... (command not supported)");
  it.todo("UNLOAD ('select * from venue') TO 's3://mybucket/unload/' IAM_ROLE ... (check_command_warning)");
  it.todo("CREATE TABLE SOUP (SOUP1 VARCHAR(50) NOT NULL ENCODE ZSTD, SOUP2 VA... (DDL/DML not supported)");
  it("SELECT DATEADD('day', ndays, caldate) -> SELECT DATEADD(DAY, ndays, caldate)", () => {
    validateIdentity("SELECT DATEADD('day', ndays, caldate)", "SELECT DATEADD(DAY, ndays, caldate)");
  });
  it.todo("CONVERT(INT, x) (unsupported syntax)");
  it("SELECT DATE_ADD('day', 1, DATE('2023-01-01')) -> SELECT DATEADD(DAY, 1, DATE('2023-01-0...", () => {
    validateIdentity("SELECT DATE_ADD('day', 1, DATE('2023-01-01'))", "SELECT DATEADD(DAY, 1, DATE('2023-01-01'))");
  });
  it.todo("SELECT\n  c_name,\n  orders.o_orderkey AS orderkey,\n  index AS orderk... (pretty=True not supported)");
  it.todo("SELECT attr AS attr, JSON_TYPEOF(val) AS value_type FROM customer_o... (unsupported clause)");
  it.todo("SELECT attr AS attr, JSON_TYPEOF(val) AS value_type FROM customer_o... (unsupported clause) (2)");
  it("SELECT JSON_PARSE('[]')", () => {
    validateIdentity("SELECT JSON_PARSE('[]')");
  });
  it.todo("SELECT ARRAY(1, 2, 3) (unsupported syntax)");
  it.todo("SELECT ARRAY[1, 2, 3] (unsupported syntax)");
  it("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000') -> SELECT CONVER...", () => {
    validateIdentity("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", "SELECT CONVERT_TIMEZONE('UTC', 'America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("redshift -> redshift: SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, ...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)");
  });
  it("redshift -> duckdb: SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 ...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col2, col3) FROM (SELECT *, 4 AS col4 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("redshift -> snowflake: SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1,...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col2, col3) FROM (SELECT *, 4 AS col4 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("redshift -> redshift: SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2 ...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT *, 4 AS col4 EXCLUDE (col2, col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)");
  });
  it("redshift -> duckdb: SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2 AS...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col2, col3) FROM (SELECT *, 4 AS col4 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("redshift -> snowflake: SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2...", () => {
    const result = transpile("SELECT *, 4 AS col4 EXCLUDE col2, col3 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col2, col3) FROM (SELECT *, 4 AS col4 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("redshift -> redshift: SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS c...", () => {
    const result = transpile("SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT col1, *, col2 EXCLUDE (col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)");
  });
  it("redshift -> duckdb: SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS col...", () => {
    const result = transpile("SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col3) FROM (SELECT col1, *, col2 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("redshift -> snowflake: SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS ...", () => {
    const result = transpile("SELECT col1, *, col2 EXCLUDE(col3) FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * EXCLUDE (col3) FROM (SELECT col1, *, col2 FROM (SELECT 1 AS col1, 2 AS col2, 3 AS col3))");
  });
  it("SELECT 1 EXCLUDE -> SELECT 1 AS EXCLUDE", () => {
    validateIdentity("SELECT 1 EXCLUDE", "SELECT 1 AS EXCLUDE");
  });
  it("SELECT 1 EXCLUDE FROM t -> SELECT 1 AS EXCLUDE FROM t", () => {
    validateIdentity("SELECT 1 EXCLUDE FROM t", "SELECT 1 AS EXCLUDE FROM t");
  });
  it("SELECT 1 AS EXCLUDE", () => {
    validateIdentity("SELECT 1 AS EXCLUDE");
  });
  it("SELECT * FROM (SELECT 1 AS EXCLUDE) AS t", () => {
    validateIdentity("SELECT * FROM (SELECT 1 AS EXCLUDE) AS t");
  });
  it("SELECT 1 AS EXCLUDE, 2 AS foo", () => {
    validateIdentity("SELECT 1 AS EXCLUDE, 2 AS foo");
  });
});

describe("Redshift: values", () => {
  it.todo("test_values: assertEqual call");
  it.todo("test_values: assertEqual call (2)");
  it.todo("INSERT INTO t (a) VALUES (1), (2), (3) (DDL/DML not supported)");
  it.todo("INSERT INTO t (a, b) VALUES (1, 2), (3, 4) (DDL/DML not supported)");
  it.todo(" -> redshift: SELECT * FROM (VALUES (1, 2)) AS t (unsupported syntax)");
  it("redshift -> mysql: SELECT * FROM (SELECT 1, 2) AS t", () => {
    const result = transpile("SELECT * FROM (SELECT 1, 2) AS t", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT * FROM (SELECT 1, 2) AS t");
  });
  it("redshift -> presto: SELECT * FROM (SELECT 1, 2) AS t", () => {
    const result = transpile("SELECT * FROM (SELECT 1, 2) AS t", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT * FROM (SELECT 1, 2) AS t");
  });
  it.todo(" -> redshift: SELECT * FROM (VALUES (1)) AS t1(id) CROSS JOIN (VALUES (1)) AS t2(id) (unsupported syntax)");
  it.todo(" -> redshift: SELECT a, b FROM (VALUES (1, 2)) AS t (a, b) (unsupported syntax)");
  it.todo(' -> redshift: SELECT a, b FROM (VALUES (1, 2), (3, 4)) AS "t" (a, b) (unsupported syntax)');
  it.todo(" -> redshift: SELECT a, b FROM (VALUES (1, 2), (3, 4), (5, 6), (7, 8)) AS t (a, b) (unsupported syntax)");
  it.todo("INSERT INTO t (a, b) SELECT a, b FROM (SELECT 1 AS a, 2 AS b UNION ... (DDL/DML not supported)");
  it.todo("CREATE TABLE table_backup BACKUP NO AS SELECT * FROM event (DDL/DML not supported)");
  it.todo("CREATE TABLE table_backup BACKUP YES AS SELECT * FROM event (DDL/DML not supported)");
  it.todo("CREATE TABLE table_backup (i INTEGER, b VARCHAR) BACKUP NO (DDL/DML not supported)");
  it.todo("CREATE TABLE table_backup (i INTEGER, b VARCHAR) BACKUP YES (DDL/DML not supported)");
  it("select foo, bar from table_1 minus select foo, bar from table_2 -> SELECT foo, bar FROM...", () => {
    validateIdentity("select foo, bar from table_1 minus select foo, bar from table_2", "SELECT foo, bar FROM table_1 EXCEPT SELECT foo, bar FROM table_2");
  });
});

describe("Redshift: create_table_like", () => {
  it.todo("CREATE TABLE SOUP (LIKE other_table) DISTKEY(soup1) SORTKEY(soup2) ... (DDL/DML not supported)");
  it.todo("CREATE TABLE t1 (LIKE t2) (DDL/DML not supported)");
  it.todo("CREATE TABLE t1 (col VARCHAR, LIKE t2) (DDL/DML not supported)");
});

describe("Redshift: alter_table", () => {
  it.todo("ALTER TABLE s.t ALTER SORTKEY (c) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER SORTKEY AUTO (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER SORTKEY NONE (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER SORTKEY (c1, c2) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER SORTKEY (c1, c2) (DDL/DML not supported) (2)");
  it.todo("ALTER TABLE t ALTER COMPOUND SORTKEY (c1, c2) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER DISTSTYLE ALL (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER DISTSTYLE EVEN (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER DISTSTYLE AUTO (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER DISTSTYLE KEY DISTKEY c (DDL/DML not supported)");
  it.todo("ALTER TABLE t SET TABLE PROPERTIES ('a' = '5', 'b' = 'c') (DDL/DML not supported)");
  it.todo("ALTER TABLE t SET LOCATION 's3://bucket/folder/' (DDL/DML not supported)");
  it.todo("ALTER TABLE t SET FILE FORMAT AVRO (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER DISTKEY c (DDL/DML not supported)");
  it.todo("ALTER TABLE db.t1 RENAME TO db.t2 (DDL/DML not supported)");
});

describe("Redshift: varchar_max", () => {
  it.todo('CREATE TABLE "TEST" ("cola" VARCHAR(MAX)) (identify=True not supported)');
});

describe("Redshift: no_schema_binding", () => {
  it.todo("CREATE OR REPLACE VIEW v1 AS SELECT cola, colb FROM t1 WITH NO SCHE... (DDL/DML not supported)");
});

describe("Redshift: column_unnesting", () => {
  it("SELECT c.*, o FROM bloo AS c, c.c_orders AS o", () => {
    validateIdentity("SELECT c.*, o FROM bloo AS c, c.c_orders AS o");
  });
  it("SELECT c.*, o, l FROM bloo AS c, c.c_orders AS o, o.o_lineitems AS l", () => {
    validateIdentity("SELECT c.*, o, l FROM bloo AS c, c.c_orders AS o, o.o_lineitems AS l");
  });
  it.todo("test_column_unnesting: assertEqual call");
  it.todo("test_column_unnesting: assertEqual call (2)");
  it.todo("test_column_unnesting: assertEqual call (3)");
});

describe("Redshift: join_markers", () => {
  it("select a.foo, b.bar, a.baz from a, b where a.baz = b.baz (+) -> SELECT a.foo, b.bar, a....", () => {
    validateIdentity("select a.foo, b.bar, a.baz from a, b where a.baz = b.baz (+)", "SELECT a.foo, b.bar, a.baz FROM a, b WHERE a.baz = b.baz (+)");
  });
});

describe("Redshift: time", () => {
  it.todo("TIME_TO_STR(a, '%Y-%m-%d %H:%M:%S.%f') (unsupported syntax)");
});

describe("Redshift: grant", () => {
  it.todo("test_grant: unresolvable for-loop iterable");
  it.todo("GRANT SELECT ON TABLE sales TO fred (command not supported)");
  it.todo("GRANT ALL ON SCHEMA qa_tickit TO GROUP qa_users (command not supported)");
  it.todo("GRANT ALL ON TABLE qa_tickit.sales TO GROUP qa_users (command not supported)");
  it.todo("GRANT ALL ON TABLE qa_tickit.sales TO GROUP qa_users, GROUP ro_users (command not supported)");
  it.todo("GRANT ALL ON view_date TO view_user (command not supported)");
  it.todo("GRANT SELECT(cust_name, cust_phone), UPDATE(cust_contact_preference... (command not supported)");
  it.todo("GRANT ALL(cust_name, cust_phone, cust_contact_preference) ON cust_p... (command not supported)");
  it.todo("GRANT USAGE ON DATABASE sales_db TO Bob (command not supported)");
  it.todo("GRANT USAGE ON SCHEMA sales_schema TO ROLE Analyst_role (command not supported)");
  it.todo("GRANT SELECT ON sales_db.sales_schema.tickit_sales_redshift TO Bob (command not supported)");
});

describe("Redshift: revoke", () => {
  it.todo("test_revoke: unresolvable for-loop iterable");
  it.todo("REVOKE SELECT ON TABLE sales FROM fred (command not supported)");
  it.todo("REVOKE ALL ON SCHEMA qa_tickit FROM GROUP qa_users (command not supported)");
  it.todo("REVOKE USAGE ON DATABASE sales_db FROM Bob (command not supported)");
  it.todo("REVOKE USAGE ON SCHEMA sales_schema FROM ROLE Analyst_role (command not supported)");
});

describe("Redshift: analyze", () => {
  it.todo("ANALYZE TBL(col1, col2) (command not supported)");
  it.todo("ANALYZE VERBOSE TBL (command not supported)");
  it.todo("ANALYZE TBL PREDICATE COLUMNS (command not supported)");
  it.todo("ANALYZE TBL ALL COLUMNS (command not supported)");
});

describe("Redshift: fetch_to_limit", () => {
  it.todo("SELECT * FROM t FETCH FIRST 1 ROWS ONLY (unsupported clause)");
});

describe("Redshift: regexp_extract", () => {
  it("redshift -> redshift: SELECT REGEXP_SUBSTR(abc, 'pattern(group)', 2) FROM table", () => {
    const result = transpile("SELECT REGEXP_SUBSTR(abc, 'pattern(group)', 2) FROM table", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe(`SELECT REGEXP_SUBSTR(abc, 'pattern(group)', 2) FROM "table"`);
  });
  it("redshift -> duckdb: SELECT REGEXP_SUBSTR(abc, 'pattern(group)', 2) FROM table", () => {
    const result = transpile("SELECT REGEXP_SUBSTR(abc, 'pattern(group)', 2) FROM table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(SUBSTRING(abc, 2), 'pattern(group)') FROM "table"`);
  });
});
