// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "doris";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Doris: doris", () => {
  it("doris -> doris: SELECT TO_DATE('2020-02-02 00:00:00')", () => {
    const result = transpile("SELECT TO_DATE('2020-02-02 00:00:00')", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("SELECT TO_DATE('2020-02-02 00:00:00')");
  });
  it.todo("doris -> oracle: SELECT TO_DATE('2020-02-02 00:00:00') (cross-dialect transform)");
  it.todo("clickhouse -> doris: SELECT argMax(a, b), argMin(c, d) (cross-dialect transform)");
  it.todo("SELECT ARRAY_SUM(x -> x * x, ARRAY(2, 3)) (unsupported syntax)");
  it.todo("oracle -> doris: ADD_MONTHS(d, n) (cross-dialect transform)");
  it("doris -> doris: MONTHS_ADD(d, n)", () => {
    const result = transpile("MONTHS_ADD(d, n)", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("MONTHS_ADD(d, n)");
  });
  it.todo("doris -> oracle: MONTHS_ADD(d, n) (cross-dialect transform)");
  it.todo(`postgres -> doris: SELECT '{"key": 1}'::jsonb ->> 'key' (unsupported syntax)`);
  it(`doris -> doris: SELECT JSON_EXTRACT(CAST('{"key": 1}' AS JSONB), '$.key')`, () => {
    const result = transpile(`SELECT JSON_EXTRACT(CAST('{"key": 1}' AS JSONB), '$.key')`, { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT(CAST('{"key": 1}' AS JSONB), '$.key')`);
  });
  it.todo(`doris -> postgres: SELECT JSON_EXTRACT(CAST('{"key": 1}' AS JSONB), '$.key') (cross-dialect transform)`);
  it.todo("SELECT GROUP_CONCAT('aa', ',') (unsupported syntax)");
  it("doris -> doris: SELECT LAG(1, 1, NULL) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LAG(1, 1, NULL) OVER (ORDER BY 1)", { readDialect: "doris", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAG(1, 1, NULL) OVER (ORDER BY 1)");
  });
  it("postgres -> doris: SELECT LAG(1) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LAG(1) OVER (ORDER BY 1)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAG(1, 1, NULL) OVER (ORDER BY 1)");
  });
  it("doris -> doris: SELECT LAG(1, 2, NULL) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LAG(1, 2, NULL) OVER (ORDER BY 1)", { readDialect: "doris", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAG(1, 2, NULL) OVER (ORDER BY 1)");
  });
  it("postgres -> doris: SELECT LAG(1, 2) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LAG(1, 2) OVER (ORDER BY 1)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAG(1, 2, NULL) OVER (ORDER BY 1)");
  });
  it("doris -> doris: SELECT LEAD(1, 1, NULL) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LEAD(1, 1, NULL) OVER (ORDER BY 1)", { readDialect: "doris", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LEAD(1, 1, NULL) OVER (ORDER BY 1)");
  });
  it("postgres -> doris: SELECT LEAD(1) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LEAD(1) OVER (ORDER BY 1)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LEAD(1, 1, NULL) OVER (ORDER BY 1)");
  });
  it("doris -> doris: SELECT LEAD(1, 2, NULL) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LEAD(1, 2, NULL) OVER (ORDER BY 1)", { readDialect: "doris", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LEAD(1, 2, NULL) OVER (ORDER BY 1)");
  });
  it("postgres -> doris: SELECT LEAD(1, 2) OVER (ORDER BY 1)", () => {
    const result = transpile("SELECT LEAD(1, 2) OVER (ORDER BY 1)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LEAD(1, 2, NULL) OVER (ORDER BY 1)");
  });
  it(`JSON_TYPE('{"foo": "1" }', '$.foo')`, () => {
    validateIdentity(`JSON_TYPE('{"foo": "1" }', '$.foo')`);
  });
  it("L2_DISTANCE(x, y)", () => {
    validateIdentity("L2_DISTANCE(x, y)");
  });
});

describe("Doris: identity", () => {
  it.todo("CREATE TABLE t (c INT) PROPERTIES ('x'='y') (DDL/DML not supported)");
  it.todo("CREATE TABLE t (c INT) COMMENT 'c' (DDL/DML not supported)");
  it("COALECSE(a, b, c, d)", () => {
    validateIdentity("COALECSE(a, b, c, d)");
  });
  it("SELECT CAST(`a`.`b` AS INT) FROM foo", () => {
    validateIdentity("SELECT CAST(`a`.`b` AS INT) FROM foo");
  });
  it("SELECT APPROX_COUNT_DISTINCT(a) FROM x", () => {
    validateIdentity("SELECT APPROX_COUNT_DISTINCT(a) FROM x");
  });
  it.todo("CREATE TABLE IF NOT EXISTS example_tbl_unique (user_id BIGINT NOT N... (DDL/DML not supported)");
  it.todo("INSERT OVERWRITE TABLE test PARTITION(p1, p2) VALUES (1, 2) (DDL/DML not supported)");
});

describe("Doris: time", () => {
  it("TIMESTAMP('2022-01-01')", () => {
    validateIdentity("TIMESTAMP('2022-01-01')");
  });
  it("DATE_TRUNC(event_date, 'DAY')", () => {
    validateIdentity("DATE_TRUNC(event_date, 'DAY')");
  });
  it("DATE_TRUNC('2010-12-02 19:28:30', 'HOUR')", () => {
    validateIdentity("DATE_TRUNC('2010-12-02 19:28:30', 'HOUR')");
  });
  it("CURRENT_DATE()", () => {
    validateIdentity("CURRENT_DATE()");
  });
});

describe("Doris: regex", () => {
  it("doris -> doris: SELECT REGEXP_LIKE(abc, '%foo%')", () => {
    const result = transpile("SELECT REGEXP_LIKE(abc, '%foo%')", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("SELECT REGEXP(abc, '%foo%')");
  });
});

describe("Doris: analyze", () => {
  it.todo("ANALYZE TABLE tbl (command not supported)");
  it.todo("ANALYZE DATABASE db (command not supported)");
  it.todo("ANALYZE TABLE TBL(c1, c2) (command not supported)");
});

describe("Doris: key", () => {
  it.todo("CREATE TABLE test_table (c1 INT, c2 INT) UNIQUE KEY (c1) (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 INT) DUPLICATE KEY (c1) (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_table (c1 INT, c2 INT) KEY (c1) (DDL/DML not supported)");
});

describe("Doris: distributed", () => {
  it.todo("CREATE TABLE test_table (c1 INT, c2 INT) UNIQUE KEY (c1) DISTRIBUTE... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 INT) DISTRIBUTED BY RANDOM (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 INT) DISTRIBUTED BY RANDOM BUCK... (DDL/DML not supported)");
});

describe("Doris: partition", () => {
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY RANGE (`c2`)... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY RANGE (`c2`)... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY RANGE (`c2`)... (DDL/DML not supported) (3)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY (c2) (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY (c1, c2) (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT, c2 DATE) PARTITION BY (DATE_TRUNC(... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (c1 INT) PARTITION BY LIST (`c1`) (PARTITIO... (DDL/DML not supported)");
});

describe("Doris: table_alias_conversion", () => {
  it.todo("DELETE FROM sales s WHERE s.id = 1 (DDL/DML not supported)");
  it.todo("DELETE FROM orders o WHERE o.customer_id IN (SELECT c.id FROM custo... (DDL/DML not supported)");
  it.todo("DELETE FROM temp_data t WHERE NOT EXISTS(SELECT 1 FROM main_data AS... (DDL/DML not supported)");
  it.todo("UPDATE employees e SET e.salary = e.salary * 1.1 WHERE e.department... (DDL/DML not supported)");
  it.todo("UPDATE accounts a SET a.balance = a.balance + 100, a.status_code = ... (DDL/DML not supported)");
  it.todo("UPDATE prices p SET p.amount = p.amount * 0.9 WHERE p.product_id IN... (DDL/DML not supported)");
});

describe("Doris: rename_table", () => {
  it.todo("ALTER TABLE db.t1 RENAME TO db.t2 (DDL/DML not supported)");
});

describe("Doris: materialized_view_properties", () => {
  it.todo("CREATE MATERIALIZED VIEW mv BUILD IMMEDIATE AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW mv BUILD DEFERRED AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW mv REFRESH COMPLETE ON MANUAL AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW mv REFRESH AUTO ON COMMIT AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW mv REFRESH AUTO ON SCHEDULE EVERY 5 MINUTE... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW mv BUILD DEFERRED REFRESH AUTO ON SCHEDULE... (DDL/DML not supported)");
});
