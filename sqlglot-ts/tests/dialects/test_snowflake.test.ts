// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "snowflake";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Snowflake: snowflake", () => {
  it("SELECT * FROM x ASOF JOIN y OFFSET MATCH_CONDITION (x.a > y.a) -> SELECT * FROM x ASOF ...", () => {
    validateIdentity("SELECT * FROM x ASOF JOIN y OFFSET MATCH_CONDITION (x.a > y.a)", "SELECT * FROM x ASOF JOIN y AS OFFSET MATCH_CONDITION (x.a > y.a)");
  });
  it("SELECT * FROM x ASOF JOIN y LIMIT MATCH_CONDITION (x.a > y.a) -> SELECT * FROM x ASOF J...", () => {
    validateIdentity("SELECT * FROM x ASOF JOIN y LIMIT MATCH_CONDITION (x.a > y.a)", "SELECT * FROM x ASOF JOIN y AS LIMIT MATCH_CONDITION (x.a > y.a)");
  });
  it("SELECT session", () => {
    validateIdentity("SELECT session");
  });
  it.todo("x::nvarchar() (unsupported syntax)");
  it.todo("test_snowflake: assertEqual call");
  it("SELECT DATE_PART(EPOCH_MILLISECOND, CURRENT_TIMESTAMP()) AS a", () => {
    validateIdentity("SELECT DATE_PART(EPOCH_MILLISECOND, CURRENT_TIMESTAMP()) AS a");
  });
  it("SELECT GET(a, b)", () => {
    validateIdentity("SELECT GET(a, b)");
  });
  it("SELECT HASH_AGG(a, b, c, d)", () => {
    validateIdentity("SELECT HASH_AGG(a, b, c, d)");
  });
  it("SELECT GREATEST(1, 2, 3, NULL)", () => {
    validateIdentity("SELECT GREATEST(1, 2, 3, NULL)");
  });
  it("SELECT GREATEST_IGNORE_NULLS(1, 2, 3, NULL)", () => {
    validateIdentity("SELECT GREATEST_IGNORE_NULLS(1, 2, 3, NULL)");
  });
  it("SELECT LEAST(5, NULL, 7, 3)", () => {
    validateIdentity("SELECT LEAST(5, NULL, 7, 3)");
  });
  it("SELECT LEAST_IGNORE_NULLS(5, NULL, 7, 3)", () => {
    validateIdentity("SELECT LEAST_IGNORE_NULLS(5, NULL, 7, 3)");
  });
  it("SELECT MAX(x)", () => {
    validateIdentity("SELECT MAX(x)");
  });
  it("SELECT COUNT(x)", () => {
    validateIdentity("SELECT COUNT(x)");
  });
  it("SELECT MIN(amount)", () => {
    validateIdentity("SELECT MIN(amount)");
  });
  it("SELECT MODE(x)", () => {
    validateIdentity("SELECT MODE(x)");
  });
  it("SELECT MODE(status) OVER (PARTITION BY region) FROM orders", () => {
    validateIdentity("SELECT MODE(status) OVER (PARTITION BY region) FROM orders");
  });
  it("SELECT TAN(x)", () => {
    validateIdentity("SELECT TAN(x)");
  });
  it("SELECT COS(x)", () => {
    validateIdentity("SELECT COS(x)");
  });
  it("SELECT SINH(1.5)", () => {
    validateIdentity("SELECT SINH(1.5)");
  });
  it("SELECT MOD(x, y) -> SELECT x % y", () => {
    validateIdentity("SELECT MOD(x, y)", "SELECT x % y");
  });
  it("SELECT ROUND(x)", () => {
    validateIdentity("SELECT ROUND(x)");
  });
  it("SELECT ROUND(123.456, -1)", () => {
    validateIdentity("SELECT ROUND(123.456, -1)");
  });
  it("SELECT ROUND(123.456, 2, 'HALF_AWAY_FROM_ZERO')", () => {
    validateIdentity("SELECT ROUND(123.456, 2, 'HALF_AWAY_FROM_ZERO')");
  });
  it("SELECT FLOOR(x)", () => {
    validateIdentity("SELECT FLOOR(x)");
  });
  it("SELECT FLOOR(135.135, 1)", () => {
    validateIdentity("SELECT FLOOR(135.135, 1)");
  });
  it("SELECT FLOOR(x, -1)", () => {
    validateIdentity("SELECT FLOOR(x, -1)");
  });
  it.todo("SELECT PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) FROM em... (unsupported clause)");
  it.todo("test_snowflake: assertEqual call (2)");
  it("SELECT APPROX_TOP_K(col) FROM t -> SELECT APPROX_TOP_K(col, 1) FROM t", () => {
    validateIdentity("SELECT APPROX_TOP_K(col) FROM t", "SELECT APPROX_TOP_K(col, 1) FROM t");
  });
  it("SELECT APPROX_TOP_K(category, 3) FROM t", () => {
    validateIdentity("SELECT APPROX_TOP_K(category, 3) FROM t");
  });
  it.todo("APPROX_TOP_K(C4, 3, 5) (assert_is check)");
  it("SELECT MINHASH(5, col)", () => {
    validateIdentity("SELECT MINHASH(5, col)");
  });
  it("SELECT MINHASH(5, col1, col2)", () => {
    validateIdentity("SELECT MINHASH(5, col1, col2)");
  });
  it("SELECT MINHASH(5, *)", () => {
    validateIdentity("SELECT MINHASH(5, *)");
  });
  it("SELECT MINHASH_COMBINE(minhash_col)", () => {
    validateIdentity("SELECT MINHASH_COMBINE(minhash_col)");
  });
  it("SELECT APPROXIMATE_SIMILARITY(minhash_col)", () => {
    validateIdentity("SELECT APPROXIMATE_SIMILARITY(minhash_col)");
  });
  it("SELECT APPROXIMATE_JACCARD_INDEX(minhash_col) -> SELECT APPROXIMATE_SIMILARITY(minhash_...", () => {
    validateIdentity("SELECT APPROXIMATE_JACCARD_INDEX(minhash_col)", "SELECT APPROXIMATE_SIMILARITY(minhash_col)");
  });
  it("SELECT APPROX_PERCENTILE_ACCUMULATE(col)", () => {
    validateIdentity("SELECT APPROX_PERCENTILE_ACCUMULATE(col)");
  });
  it("SELECT APPROX_PERCENTILE_ESTIMATE(state, 0.5)", () => {
    validateIdentity("SELECT APPROX_PERCENTILE_ESTIMATE(state, 0.5)");
  });
  it("SELECT APPROX_TOP_K_ACCUMULATE(col, 10)", () => {
    validateIdentity("SELECT APPROX_TOP_K_ACCUMULATE(col, 10)");
  });
  it("SELECT APPROX_TOP_K_COMBINE(state, 2)", () => {
    validateIdentity("SELECT APPROX_TOP_K_COMBINE(state, 2)");
  });
  it("SELECT APPROX_TOP_K_COMBINE(state)", () => {
    validateIdentity("SELECT APPROX_TOP_K_COMBINE(state)");
  });
  it("SELECT APPROX_TOP_K_ESTIMATE(state_column, 4)", () => {
    validateIdentity("SELECT APPROX_TOP_K_ESTIMATE(state_column, 4)");
  });
  it("SELECT APPROX_TOP_K_ESTIMATE(state_column)", () => {
    validateIdentity("SELECT APPROX_TOP_K_ESTIMATE(state_column)");
  });
  it("SELECT APPROX_PERCENTILE_COMBINE(state_column)", () => {
    validateIdentity("SELECT APPROX_PERCENTILE_COMBINE(state_column)");
  });
  it("SELECT EQUAL_NULL(1, 2)", () => {
    validateIdentity("SELECT EQUAL_NULL(1, 2)");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it("SELECT FACTORIAL(5)", () => {
    validateIdentity("SELECT FACTORIAL(5)");
  });
  it("SELECT BIT_LENGTH('abc')", () => {
    validateIdentity("SELECT BIT_LENGTH('abc')");
  });
  it.todo("SELECT BIT_LENGTH(x'A1B2') (unsupported syntax)");
  it("snowflake -> duckdb: SELECT BITMAP_BIT_POSITION(10)", () => {
    const result = transpile("SELECT BITMAP_BIT_POSITION(10)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT (CASE WHEN 10 > 0 THEN 10 - 1 ELSE ABS(10) END) % 32768");
  });
  it("snowflake -> snowflake: SELECT BITMAP_BIT_POSITION(10)", () => {
    const result = transpile("SELECT BITMAP_BIT_POSITION(10)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITMAP_BIT_POSITION(10)");
  });
  it("SELECT BITMAP_BUCKET_NUMBER(32769)", () => {
    validateIdentity("SELECT BITMAP_BUCKET_NUMBER(32769)");
  });
  it("SELECT BITMAP_CONSTRUCT_AGG(value)", () => {
    validateIdentity("SELECT BITMAP_CONSTRUCT_AGG(value)");
  });
  it("snowflake -> snowflake: SELECT BITMAP_CONSTRUCT_AGG(v) FROM t", () => {
    const result = transpile("SELECT BITMAP_CONSTRUCT_AGG(v) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITMAP_CONSTRUCT_AGG(v) FROM t");
  });
  it.todo("snowflake -> duckdb: SELECT BITMAP_CONSTRUCT_AGG(v) FROM t (unsupported syntax)");
  it("SELECT BITMAP_COUNT(BITMAP_CONSTRUCT_AGG(value)) FROM TABLE(FLATTEN(INPUT => ARRAY_CONS...", () => {
    validateIdentity("SELECT BITMAP_COUNT(BITMAP_CONSTRUCT_AGG(value)) FROM TABLE(FLATTEN(INPUT => ARRAY_CONSTRUCT(1, 2, 3, 5)))", "SELECT BITMAP_COUNT(BITMAP_CONSTRUCT_AGG(value)) FROM TABLE(FLATTEN(INPUT => [1, 2, 3, 5]))");
  });
  it("SELECT BOOLAND(1, -2)", () => {
    validateIdentity("SELECT BOOLAND(1, -2)");
  });
  it("SELECT BOOLXOR(2, 0)", () => {
    validateIdentity("SELECT BOOLXOR(2, 0)");
  });
  it("SELECT BOOLOR(1, 0)", () => {
    validateIdentity("SELECT BOOLOR(1, 0)");
  });
  it("SELECT TO_BOOLEAN('true')", () => {
    validateIdentity("SELECT TO_BOOLEAN('true')");
  });
  it("SELECT TO_BOOLEAN(1)", () => {
    validateIdentity("SELECT TO_BOOLEAN(1)");
  });
  it("SELECT IS_NULL_VALUE(GET_PATH(payload, 'field'))", () => {
    validateIdentity("SELECT IS_NULL_VALUE(GET_PATH(payload, 'field'))");
  });
  it("SELECT RTRIMMED_LENGTH(' ABCD ')", () => {
    validateIdentity("SELECT RTRIMMED_LENGTH(' ABCD ')");
  });
  it("SELECT HEX_DECODE_STRING('48656C6C6F')", () => {
    validateIdentity("SELECT HEX_DECODE_STRING('48656C6C6F')");
  });
  it("SELECT HEX_ENCODE('Hello World')", () => {
    validateIdentity("SELECT HEX_ENCODE('Hello World')");
  });
  it("SELECT HEX_ENCODE('Hello World', 1)", () => {
    validateIdentity("SELECT HEX_ENCODE('Hello World', 1)");
  });
  it("SELECT HEX_ENCODE('Hello World', 0)", () => {
    validateIdentity("SELECT HEX_ENCODE('Hello World', 0)");
  });
  it("SELECT IFNULL(col1, col2) -> SELECT COALESCE(col1, col2)", () => {
    validateIdentity("SELECT IFNULL(col1, col2)", "SELECT COALESCE(col1, col2)");
  });
  it("SELECT NEXT_DAY('2025-10-15', 'FRIDAY')", () => {
    validateIdentity("SELECT NEXT_DAY('2025-10-15', 'FRIDAY')");
  });
  it("SELECT NVL2(col1, col2, col3)", () => {
    validateIdentity("SELECT NVL2(col1, col2, col3)");
  });
  it("SELECT NVL(col1, col2) -> SELECT COALESCE(col1, col2)", () => {
    validateIdentity("SELECT NVL(col1, col2)", "SELECT COALESCE(col1, col2)");
  });
  it("SELECT CHR(8364)", () => {
    validateIdentity("SELECT CHR(8364)");
  });
  it(`SELECT CHECK_JSON('{"key": "value"}')`, () => {
    validateIdentity(`SELECT CHECK_JSON('{"key": "value"}')`);
  });
  it(`SELECT CHECK_XML('<root><key attribute="attr">value</key></root>')`, () => {
    validateIdentity(`SELECT CHECK_XML('<root><key attribute="attr">value</key></root>')`);
  });
  it(`SELECT CHECK_XML('<root><key attribute="attr">value</key></root>', TRUE)`, () => {
    validateIdentity(`SELECT CHECK_XML('<root><key attribute="attr">value</key></root>', TRUE)`);
  });
  it("SELECT COMPRESS('Hello World', 'ZLIB')", () => {
    validateIdentity("SELECT COMPRESS('Hello World', 'ZLIB')");
  });
  it("SELECT DECOMPRESS_BINARY('compressed_data', 'SNAPPY')", () => {
    validateIdentity("SELECT DECOMPRESS_BINARY('compressed_data', 'SNAPPY')");
  });
  it("SELECT DECOMPRESS_STRING('compressed_data', 'ZSTD')", () => {
    validateIdentity("SELECT DECOMPRESS_STRING('compressed_data', 'ZSTD')");
  });
  it("SELECT LPAD('Hello', 10, '*')", () => {
    validateIdentity("SELECT LPAD('Hello', 10, '*')");
  });
  it("SELECT LPAD(tbl.bin_col, 10)", () => {
    validateIdentity("SELECT LPAD(tbl.bin_col, 10)");
  });
  it("SELECT RPAD('Hello', 10, '*')", () => {
    validateIdentity("SELECT RPAD('Hello', 10, '*')");
  });
  it("SELECT RPAD(tbl.bin_col, 10)", () => {
    validateIdentity("SELECT RPAD(tbl.bin_col, 10)");
  });
  it("snowflake -> snowflake: SELECT RPAD('test', 10, 'ab')", () => {
    const result = transpile("SELECT RPAD('test', 10, 'ab')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RPAD('test', 10, 'ab')");
  });
  it("snowflake -> duckdb: SELECT RPAD('test', 10, 'ab')", () => {
    const result = transpile("SELECT RPAD('test', 10, 'ab')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RPAD('test', 10, 'ab')");
  });
  it("snowflake -> snowflake: SELECT RPAD('data', 8)", () => {
    const result = transpile("SELECT RPAD('data', 8)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RPAD('data', 8)");
  });
  it("snowflake -> duckdb: SELECT RPAD('data', 8)", () => {
    const result = transpile("SELECT RPAD('data', 8)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RPAD('data', 8, ' ')");
  });
  it("snowflake -> postgres: SELECT RPAD('data', 8)", () => {
    const result = transpile("SELECT RPAD('data', 8)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT RPAD('data', 8)");
  });
  it("snowflake -> snowflake: SELECT RPAD('exact', 5, '*')", () => {
    const result = transpile("SELECT RPAD('exact', 5, '*')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RPAD('exact', 5, '*')");
  });
  it("snowflake -> duckdb: SELECT RPAD('exact', 5, '*')", () => {
    const result = transpile("SELECT RPAD('exact', 5, '*')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RPAD('exact', 5, '*')");
  });
  it.todo("test_snowflake: assertEqual call (3)");
  it("SELECT SOUNDEX(column_name)", () => {
    validateIdentity("SELECT SOUNDEX(column_name)");
  });
  it("SELECT SOUNDEX_P123(column_name)", () => {
    validateIdentity("SELECT SOUNDEX_P123(column_name)");
  });
  it("SELECT ABS(x)", () => {
    validateIdentity("SELECT ABS(x)");
  });
  it("SELECT ASIN(0.5)", () => {
    validateIdentity("SELECT ASIN(0.5)");
  });
  it("SELECT ASINH(0.5)", () => {
    validateIdentity("SELECT ASINH(0.5)");
  });
  it("SELECT ATAN(0.5)", () => {
    validateIdentity("SELECT ATAN(0.5)");
  });
  it("SELECT ATAN2(0.5, 0.3)", () => {
    validateIdentity("SELECT ATAN2(0.5, 0.3)");
  });
  it("SELECT ATANH(0.5)", () => {
    validateIdentity("SELECT ATANH(0.5)");
  });
  it("SELECT CBRT(27.0)", () => {
    validateIdentity("SELECT CBRT(27.0)");
  });
  it("SELECT POW(2, 3) -> SELECT POWER(2, 3)", () => {
    validateIdentity("SELECT POW(2, 3)", "SELECT POWER(2, 3)");
  });
  it("SELECT POW(2.5, 3.0) -> SELECT POWER(2.5, 3.0)", () => {
    validateIdentity("SELECT POW(2.5, 3.0)", "SELECT POWER(2.5, 3.0)");
  });
  it("SELECT SQUARE(2.5) -> SELECT POWER(2.5, 2)", () => {
    validateIdentity("SELECT SQUARE(2.5)", "SELECT POWER(2.5, 2)");
  });
  it("SELECT SIGN(x)", () => {
    validateIdentity("SELECT SIGN(x)");
  });
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it("SELECT TANH(0.5)", () => {
    validateIdentity("SELECT TANH(0.5)");
  });
  it("snowflake -> snowflake: JAROWINKLER_SIMILARITY('hello', 'world')", () => {
    const result = transpile("JAROWINKLER_SIMILARITY('hello', 'world')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("JAROWINKLER_SIMILARITY('hello', 'world')");
  });
  it("snowflake -> duckdb: JAROWINKLER_SIMILARITY('hello', 'world')", () => {
    const result = transpile("JAROWINKLER_SIMILARITY('hello', 'world')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("JARO_WINKLER_SIMILARITY(UPPER('hello'), UPPER('world'))");
  });
  it("snowflake -> clickhouse: JAROWINKLER_SIMILARITY('hello', 'world')", () => {
    const result = transpile("JAROWINKLER_SIMILARITY('hello', 'world')", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("jaroWinklerSimilarity(UPPER('hello'), UPPER('world'))");
  });
  it("SELECT TRANSLATE(column_name, 'abc', '123')", () => {
    validateIdentity("SELECT TRANSLATE(column_name, 'abc', '123')");
  });
  it("SELECT UNICODE(column_name)", () => {
    validateIdentity("SELECT UNICODE(column_name)");
  });
  it("SELECT WIDTH_BUCKET(col, 0, 100, 10)", () => {
    validateIdentity("SELECT WIDTH_BUCKET(col, 0, 100, 10)");
  });
  it("SELECT SPLIT_PART('11.22.33', '.', 1)", () => {
    validateIdentity("SELECT SPLIT_PART('11.22.33', '.', 1)");
  });
  it("SELECT PI()", () => {
    validateIdentity("SELECT PI()");
  });
  it("SELECT DEGREES(PI() / 3)", () => {
    validateIdentity("SELECT DEGREES(PI() / 3)");
  });
  it("SELECT DEGREES(1)", () => {
    validateIdentity("SELECT DEGREES(1)");
  });
  it("SELECT RADIANS(180)", () => {
    validateIdentity("SELECT RADIANS(180)");
  });
  it("snowflake -> snowflake: SELECT REGR_VALX(y, x)", () => {
    const result = transpile("SELECT REGR_VALX(y, x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REGR_VALX(y, x)");
  });
  it("snowflake -> duckdb: SELECT REGR_VALX(y, x)", () => {
    const result = transpile("SELECT REGR_VALX(y, x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN y IS NULL THEN CAST(NULL AS DOUBLE) ELSE x END");
  });
  it("snowflake -> snowflake: SELECT REGR_VALY(y, x)", () => {
    const result = transpile("SELECT REGR_VALY(y, x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REGR_VALY(y, x)");
  });
  it("snowflake -> duckdb: SELECT REGR_VALY(y, x)", () => {
    const result = transpile("SELECT REGR_VALY(y, x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN x IS NULL THEN CAST(NULL AS DOUBLE) ELSE y END");
  });
  it("SELECT REGR_AVGX(y, x)", () => {
    validateIdentity("SELECT REGR_AVGX(y, x)");
  });
  it("SELECT REGR_AVGY(y, x)", () => {
    validateIdentity("SELECT REGR_AVGY(y, x)");
  });
  it("SELECT REGR_COUNT(y, x)", () => {
    validateIdentity("SELECT REGR_COUNT(y, x)");
  });
  it("SELECT REGR_INTERCEPT(y, x)", () => {
    validateIdentity("SELECT REGR_INTERCEPT(y, x)");
  });
  it("SELECT REGR_R2(y, x)", () => {
    validateIdentity("SELECT REGR_R2(y, x)");
  });
  it("SELECT REGR_SXX(y, x)", () => {
    validateIdentity("SELECT REGR_SXX(y, x)");
  });
  it("SELECT REGR_SXY(y, x)", () => {
    validateIdentity("SELECT REGR_SXY(y, x)");
  });
  it("SELECT REGR_SYY(y, x)", () => {
    validateIdentity("SELECT REGR_SYY(y, x)");
  });
  it("SELECT REGR_SLOPE(y, x)", () => {
    validateIdentity("SELECT REGR_SLOPE(y, x)");
  });
  it.todo("SELECT IS_ARRAY(PARSE_JSON('[1,2,3]')) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT IFF(x > 5, 10, 20)", () => {
    const result = transpile("SELECT IFF(x > 5, 10, 20)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT IFF(x > 5, 10, 20)");
  });
  it("snowflake -> duckdb: SELECT IFF(x > 5, 10, 20)", () => {
    const result = transpile("SELECT IFF(x > 5, 10, 20)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN x > 5 THEN 10 ELSE 20 END");
  });
  it("snowflake -> snowflake: SELECT IFF(col IS NULL, 0, col)", () => {
    const result = transpile("SELECT IFF(col IS NULL, 0, col)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT IFF(col IS NULL, 0, col)");
  });
  it("snowflake -> duckdb: SELECT IFF(col IS NULL, 0, col)", () => {
    const result = transpile("SELECT IFF(col IS NULL, 0, col)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN col IS NULL THEN 0 ELSE col END");
  });
  it("snowflake -> snowflake: SELECT VAR_SAMP(x)", () => {
    const result = transpile("SELECT VAR_SAMP(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT VARIANCE(x)");
  });
  it.todo("snowflake -> duckdb: SELECT VAR_SAMP(x) (cross-dialect transform)");
  it("snowflake -> postgres: SELECT VAR_SAMP(x)", () => {
    const result = transpile("SELECT VAR_SAMP(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT VAR_SAMP(x)");
  });
  it("snowflake -> snowflake: SELECT GREATEST(1, 2)", () => {
    const result = transpile("SELECT GREATEST(1, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GREATEST(1, 2)");
  });
  it("snowflake -> duckdb: SELECT GREATEST(1, 2)", () => {
    const result = transpile("SELECT GREATEST(1, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN 1 IS NULL OR 2 IS NULL THEN NULL ELSE GREATEST(1, 2) END");
  });
  it("snowflake -> snowflake: SELECT GREATEST_IGNORE_NULLS(1, 2)", () => {
    const result = transpile("SELECT GREATEST_IGNORE_NULLS(1, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GREATEST_IGNORE_NULLS(1, 2)");
  });
  it("snowflake -> duckdb: SELECT GREATEST_IGNORE_NULLS(1, 2)", () => {
    const result = transpile("SELECT GREATEST_IGNORE_NULLS(1, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT GREATEST(1, 2)");
  });
  it("snowflake -> snowflake: SELECT LEAST(1, 2)", () => {
    const result = transpile("SELECT LEAST(1, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LEAST(1, 2)");
  });
  it("snowflake -> duckdb: SELECT LEAST(1, 2)", () => {
    const result = transpile("SELECT LEAST(1, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CASE WHEN 1 IS NULL OR 2 IS NULL THEN NULL ELSE LEAST(1, 2) END");
  });
  it("snowflake -> snowflake: SELECT LEAST_IGNORE_NULLS(1, 2)", () => {
    const result = transpile("SELECT LEAST_IGNORE_NULLS(1, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LEAST_IGNORE_NULLS(1, 2)");
  });
  it("snowflake -> duckdb: SELECT LEAST_IGNORE_NULLS(1, 2)", () => {
    const result = transpile("SELECT LEAST_IGNORE_NULLS(1, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LEAST(1, 2)");
  });
  it("snowflake -> snowflake: SELECT VAR_POP(x)", () => {
    const result = transpile("SELECT VAR_POP(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT VARIANCE_POP(x)");
  });
  it("snowflake -> duckdb: SELECT VAR_POP(x)", () => {
    const result = transpile("SELECT VAR_POP(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT VAR_POP(x)");
  });
  it("snowflake -> postgres: SELECT VAR_POP(x)", () => {
    const result = transpile("SELECT VAR_POP(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT VAR_POP(x)");
  });
  it("duckdb -> snowflake: SELECT SKEWNESS(a)", () => {
    const result = transpile("SELECT SKEWNESS(a)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SKEW(a)");
  });
  it("spark -> snowflake: SELECT SKEWNESS(a)", () => {
    const result = transpile("SELECT SKEWNESS(a)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SKEW(a)");
  });
  it("trino -> snowflake: SELECT SKEWNESS(a)", () => {
    const result = transpile("SELECT SKEWNESS(a)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SKEW(a)");
  });
  it("snowflake -> snowflake: SELECT SKEW(a)", () => {
    const result = transpile("SELECT SKEW(a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SKEW(a)");
  });
  it("snowflake -> duckdb: SELECT SKEW(a)", () => {
    const result = transpile("SELECT SKEW(a)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT SKEWNESS(a)");
  });
  it("snowflake -> spark: SELECT SKEW(a)", () => {
    const result = transpile("SELECT SKEW(a)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SKEWNESS(a)");
  });
  it("snowflake -> trino: SELECT SKEW(a)", () => {
    const result = transpile("SELECT SKEW(a)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT SKEWNESS(a)");
  });
  it("SELECT RANDOM()", () => {
    validateIdentity("SELECT RANDOM()");
  });
  it("SELECT RANDOM(123)", () => {
    validateIdentity("SELECT RANDOM(123)");
  });
  it("SELECT RANDSTR(123, 456)", () => {
    validateIdentity("SELECT RANDSTR(123, 456)");
  });
  it("SELECT RANDSTR(123, RANDOM())", () => {
    validateIdentity("SELECT RANDSTR(123, RANDOM())");
  });
  it("SELECT NORMAL(0, 1, RANDOM())", () => {
    validateIdentity("SELECT NORMAL(0, 1, RANDOM())");
  });
  it("snowflake -> duckdb: IS_NULL_VALUE(x)", () => {
    const result = transpile("IS_NULL_VALUE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("JSON_TYPE(x) = 'NULL'");
  });
  it("snowflake -> snowflake: IS_NULL_VALUE(x)", () => {
    const result = transpile("IS_NULL_VALUE(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IS_NULL_VALUE(x)");
  });
  it("snowflake -> snowflake: SELECT RANDSTR(10, 123)", () => {
    const result = transpile("SELECT RANDSTR(10, 123)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RANDSTR(10, 123)");
  });
  it("snowflake -> duckdb: SELECT RANDSTR(10, 123)", () => {
    const result = transpile("SELECT RANDSTR(10, 123)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT (SELECT LISTAGG(SUBSTRING('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 1 + CAST(FLOOR(random_value * 62) AS INT), 1), '') FROM (SELECT (ABS(HASH(i + 123)) % 1000) / 1000.0 AS random_value FROM RANGE(10) AS t(i)))");
  });
  it("snowflake -> snowflake: SELECT RANDSTR(10, RANDOM(123))", () => {
    const result = transpile("SELECT RANDSTR(10, RANDOM(123))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RANDSTR(10, RANDOM(123))");
  });
  it.todo("snowflake -> duckdb: SELECT RANDSTR(10, RANDOM(123)) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT RANDSTR(10, RANDOM())", () => {
    const result = transpile("SELECT RANDSTR(10, RANDOM())", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT RANDSTR(10, RANDOM())");
  });
  it.todo("snowflake -> duckdb: SELECT RANDSTR(10, RANDOM()) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT BOOLNOT(0)", () => {
    const result = transpile("SELECT BOOLNOT(0)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLNOT(0)");
  });
  it("snowflake -> duckdb: SELECT BOOLNOT(0)", () => {
    const result = transpile("SELECT BOOLNOT(0)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT NOT (ROUND(0, 0))");
  });
  it.todo("snowflake -> duckdb: SELECT ZIPF(1, 10, 1234) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ZIPF(1, 10, 1234)", () => {
    const result = transpile("SELECT ZIPF(1, 10, 1234)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ZIPF(1, 10, 1234)");
  });
  it.todo("snowflake -> duckdb: SELECT ZIPF(2, 100, RANDOM()) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ZIPF(2, 100, RANDOM())", () => {
    const result = transpile("SELECT ZIPF(2, 100, RANDOM())", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ZIPF(2, 100, RANDOM())");
  });
  it.todo("SELECT GROUPING_ID(a, b) AS g_id FROM x GROUP BY ROLLUP (a, b) (unsupported clause)");
  it("PARSE_URL('https://example.com/path')", () => {
    validateIdentity("PARSE_URL('https://example.com/path')");
  });
  it("PARSE_URL('https://example.com/path', 1)", () => {
    validateIdentity("PARSE_URL('https://example.com/path', 1)");
  });
  it("SELECT XMLGET(object_col, 'level2')", () => {
    validateIdentity("SELECT XMLGET(object_col, 'level2')");
  });
  it("SELECT XMLGET(object_col, 'level3', 1)", () => {
    validateIdentity("SELECT XMLGET(object_col, 'level3', 1)");
  });
  it("SELECT {*} FROM my_table", () => {
    validateIdentity("SELECT {*} FROM my_table");
  });
  it("SELECT {my_table.*} FROM my_table", () => {
    validateIdentity("SELECT {my_table.*} FROM my_table");
  });
  it("SELECT {* ILIKE 'col1%'} FROM my_table", () => {
    validateIdentity("SELECT {* ILIKE 'col1%'} FROM my_table");
  });
  it("SELECT {* EXCLUDE (col1)} FROM my_table", () => {
    validateIdentity("SELECT {* EXCLUDE (col1)} FROM my_table");
  });
  it("SELECT {* EXCLUDE (col1, col2)} FROM my_table", () => {
    validateIdentity("SELECT {* EXCLUDE (col1, col2)} FROM my_table");
  });
  it("SELECT a, b, COUNT(*) FROM x GROUP BY ALL LIMIT 100", () => {
    validateIdentity("SELECT a, b, COUNT(*) FROM x GROUP BY ALL LIMIT 100");
  });
  it.todo("STRTOK_TO_ARRAY('a b c') (unsupported syntax)");
  it.todo("STRTOK_TO_ARRAY('a.b.c', '.') (unsupported syntax)");
  it.todo("GET(a, b) (command not supported)");
  it.todo("INSERT INTO test VALUES (x'48FAF43B0AFCEF9B63EE3A93EE2AC2') (DDL/DML not supported)");
  it.todo("SELECT STAR(tbl, exclude := [foo]) (unsupported syntax)");
  it("SELECT CAST([1, 2, 3] AS VECTOR(FLOAT, 3))", () => {
    validateIdentity("SELECT CAST([1, 2, 3] AS VECTOR(FLOAT, 3))");
  });
  it("SELECT VECTOR_COSINE_SIMILARITY(a, b)", () => {
    validateIdentity("SELECT VECTOR_COSINE_SIMILARITY(a, b)");
  });
  it("SELECT VECTOR_INNER_PRODUCT(a, b)", () => {
    validateIdentity("SELECT VECTOR_INNER_PRODUCT(a, b)");
  });
  it("SELECT VECTOR_L1_DISTANCE(a, b)", () => {
    validateIdentity("SELECT VECTOR_L1_DISTANCE(a, b)");
  });
  it("SELECT VECTOR_L2_DISTANCE(a, b)", () => {
    validateIdentity("SELECT VECTOR_L2_DISTANCE(a, b)");
  });
  it("SELECT CONNECT_BY_ROOT test AS test_column_alias", () => {
    validateIdentity("SELECT CONNECT_BY_ROOT test AS test_column_alias");
  });
  it("INTERVAL '4 years, 5 months, 3 hours'", () => {
    validateIdentity("INTERVAL '4 years, 5 months, 3 hours'");
  });
  it.todo("ALTER TABLE table1 CLUSTER BY (name DESC) (DDL/DML not supported)");
  it("SELECT rename, replace", () => {
    validateIdentity("SELECT rename, replace");
  });
  it("SELECT TIMEADD(HOUR, 2, CAST('09:05:03' AS TIME))", () => {
    validateIdentity("SELECT TIMEADD(HOUR, 2, CAST('09:05:03' AS TIME))");
  });
  it("SELECT CAST(OBJECT_CONSTRUCT('a', 1) AS MAP(VARCHAR, INT))", () => {
    validateIdentity("SELECT CAST(OBJECT_CONSTRUCT('a', 1) AS MAP(VARCHAR, INT))");
  });
  it("SELECT MAP_CAT(CAST(col AS MAP(VARCHAR, VARCHAR)), CAST(col AS MAP(VARCHAR, VARCHAR)))", () => {
    validateIdentity("SELECT MAP_CAT(CAST(col AS MAP(VARCHAR, VARCHAR)), CAST(col AS MAP(VARCHAR, VARCHAR)))");
  });
  it.todo("snowflake -> duckdb: SELECT MAP_CAT(CAST(m1 AS MAP(VARCHAR, INT)), CAST(m2 AS MAP(VARCH... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT MAP_CAT(CAST(m1 AS MAP(VARCHAR, INT)), CAST(m2 AS MAP(VA...", () => {
    const result = transpile("SELECT MAP_CAT(CAST(m1 AS MAP(VARCHAR, INT)), CAST(m2 AS MAP(VARCHAR, INT)))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MAP_CAT(CAST(m1 AS MAP(VARCHAR, INT)), CAST(m2 AS MAP(VARCHAR, INT)))");
  });
  it.todo("snowflake -> duckdb: SELECT MAP_CAT(CAST(OBJECT_CONSTRUCT() AS MAP(VARCHAR, INT)), CAST... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT MAP_CAT(CAST(OBJECT_CONSTRUCT() AS MAP(VARCHAR, INT)), C...", () => {
    const result = transpile("SELECT MAP_CAT(CAST(OBJECT_CONSTRUCT() AS MAP(VARCHAR, INT)), CAST(OBJECT_CONSTRUCT('a', 1) AS MAP(VARCHAR, INT)))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MAP_CAT(CAST(OBJECT_CONSTRUCT() AS MAP(VARCHAR, INT)), CAST(OBJECT_CONSTRUCT('a', 1) AS MAP(VARCHAR, INT)))");
  });
  it("SELECT MAP_CONTAINS_KEY('k1', CAST(col AS MAP(VARCHAR, VARCHAR)))", () => {
    validateIdentity("SELECT MAP_CONTAINS_KEY('k1', CAST(col AS MAP(VARCHAR, VARCHAR)))");
  });
  it("SELECT MAP_DELETE(CAST(col AS MAP(VARCHAR, VARCHAR)), 'k1')", () => {
    validateIdentity("SELECT MAP_DELETE(CAST(col AS MAP(VARCHAR, VARCHAR)), 'k1')");
  });
  it("SELECT MAP_INSERT(CAST(col AS MAP(VARCHAR, VARCHAR)), 'b', '2')", () => {
    validateIdentity("SELECT MAP_INSERT(CAST(col AS MAP(VARCHAR, VARCHAR)), 'b', '2')");
  });
  it("SELECT MAP_KEYS(CAST(col AS MAP(VARCHAR, VARCHAR)))", () => {
    validateIdentity("SELECT MAP_KEYS(CAST(col AS MAP(VARCHAR, VARCHAR)))");
  });
  it("SELECT MAP_PICK(CAST(col AS MAP(VARCHAR, VARCHAR)), 'a', 'c')", () => {
    validateIdentity("SELECT MAP_PICK(CAST(col AS MAP(VARCHAR, VARCHAR)), 'a', 'c')");
  });
  it("SELECT MAP_SIZE(CAST(col AS MAP(VARCHAR, VARCHAR)))", () => {
    validateIdentity("SELECT MAP_SIZE(CAST(col AS MAP(VARCHAR, VARCHAR)))");
  });
  it("SELECT CAST(OBJECT_CONSTRUCT('a', 1) AS OBJECT(a CHAR NOT NULL))", () => {
    validateIdentity("SELECT CAST(OBJECT_CONSTRUCT('a', 1) AS OBJECT(a CHAR NOT NULL))");
  });
  it.todo("SELECT CAST([1, 2, 3] AS ARRAY(INT)) (unsupported syntax)");
  it("SELECT CAST(obj AS OBJECT(x CHAR) RENAME FIELDS)", () => {
    validateIdentity("SELECT CAST(obj AS OBJECT(x CHAR) RENAME FIELDS)");
  });
  it("SELECT CAST(obj AS OBJECT(x CHAR, y VARCHAR) ADD FIELDS)", () => {
    validateIdentity("SELECT CAST(obj AS OBJECT(x CHAR, y VARCHAR) ADD FIELDS)");
  });
  it("SELECT TO_TIMESTAMP(x) FROM t", () => {
    validateIdentity("SELECT TO_TIMESTAMP(x) FROM t");
  });
  it("SELECT TO_TIMESTAMP_NTZ(x) FROM t", () => {
    validateIdentity("SELECT TO_TIMESTAMP_NTZ(x) FROM t");
  });
  it("SELECT TO_TIMESTAMP_LTZ(x) FROM t", () => {
    validateIdentity("SELECT TO_TIMESTAMP_LTZ(x) FROM t");
  });
  it("SELECT TO_TIMESTAMP_TZ(x) FROM t", () => {
    validateIdentity("SELECT TO_TIMESTAMP_TZ(x) FROM t");
  });
  it("TO_DECIMAL(expr) -> TO_NUMBER(expr)", () => {
    validateIdentity("TO_DECIMAL(expr)", "TO_NUMBER(expr)");
  });
  it("TO_DECIMAL(expr, fmt) -> TO_NUMBER(expr, fmt)", () => {
    validateIdentity("TO_DECIMAL(expr, fmt)", "TO_NUMBER(expr, fmt)");
  });
  it("TO_DECIMAL(expr, fmt, precision, scale) -> TO_NUMBER(expr, fmt, precision, scale)", () => {
    validateIdentity("TO_DECIMAL(expr, fmt, precision, scale)", "TO_NUMBER(expr, fmt, precision, scale)");
  });
  it("TO_NUMBER(expr)", () => {
    validateIdentity("TO_NUMBER(expr)");
  });
  it("TO_NUMBER(expr, fmt)", () => {
    validateIdentity("TO_NUMBER(expr, fmt)");
  });
  it("TO_NUMBER(expr, fmt, precision, scale)", () => {
    validateIdentity("TO_NUMBER(expr, fmt, precision, scale)");
  });
  it("TO_DECFLOAT('123.456')", () => {
    validateIdentity("TO_DECFLOAT('123.456')");
  });
  it("TO_DECFLOAT('1,234.56', '999,999.99')", () => {
    validateIdentity("TO_DECFLOAT('1,234.56', '999,999.99')");
  });
  it("TRY_TO_DECFLOAT('123.456')", () => {
    validateIdentity("TRY_TO_DECFLOAT('123.456')");
  });
  it("TRY_TO_DECFLOAT('1,234.56', '999,999.99')", () => {
    validateIdentity("TRY_TO_DECFLOAT('1,234.56', '999,999.99')");
  });
  it("snowflake -> snowflake: TRY_TO_BOOLEAN('true')", () => {
    const result = transpile("TRY_TO_BOOLEAN('true')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_TO_BOOLEAN('true')");
  });
  it.todo("snowflake -> duckdb: TRY_TO_BOOLEAN('true') (unsupported syntax)");
  it("TRY_TO_DECIMAL('123.45') -> TRY_TO_NUMBER('123.45')", () => {
    validateIdentity("TRY_TO_DECIMAL('123.45')", "TRY_TO_NUMBER('123.45')");
  });
  it("TRY_TO_DECIMAL('123.45', '999.99') -> TRY_TO_NUMBER('123.45', '999.99')", () => {
    validateIdentity("TRY_TO_DECIMAL('123.45', '999.99')", "TRY_TO_NUMBER('123.45', '999.99')");
  });
  it("TRY_TO_DECIMAL('123.45', '999.99', 10, 2) -> TRY_TO_NUMBER('123.45', '999.99', 10, 2)", () => {
    validateIdentity("TRY_TO_DECIMAL('123.45', '999.99', 10, 2)", "TRY_TO_NUMBER('123.45', '999.99', 10, 2)");
  });
  it("snowflake -> snowflake: TRY_TO_DOUBLE('123.456')", () => {
    const result = transpile("TRY_TO_DOUBLE('123.456')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_TO_DOUBLE('123.456')");
  });
  it("snowflake -> duckdb: TRY_TO_DOUBLE('123.456')", () => {
    const result = transpile("TRY_TO_DOUBLE('123.456')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST('123.456' AS DOUBLE)");
  });
  it("TRY_TO_DOUBLE('123.456', '999.99')", () => {
    validateIdentity("TRY_TO_DOUBLE('123.456', '999.99')");
  });
  it.todo("TRY_TO_DOUBLE('-4.56E-03', 'S9.99EEEE') (UnsupportedError in write)");
  it("TO_FILE(object_col)", () => {
    validateIdentity("TO_FILE(object_col)");
  });
  it("TO_FILE('file.csv')", () => {
    validateIdentity("TO_FILE('file.csv')");
  });
  it("TO_FILE('file.csv', 'relativepath/')", () => {
    validateIdentity("TO_FILE('file.csv', 'relativepath/')");
  });
  it("TRY_TO_FILE(object_col)", () => {
    validateIdentity("TRY_TO_FILE(object_col)");
  });
  it("TRY_TO_FILE('file.csv')", () => {
    validateIdentity("TRY_TO_FILE('file.csv')");
  });
  it("TRY_TO_FILE('file.csv', 'relativepath/')", () => {
    validateIdentity("TRY_TO_FILE('file.csv', 'relativepath/')");
  });
  it("TRY_TO_NUMBER('123.45')", () => {
    validateIdentity("TRY_TO_NUMBER('123.45')");
  });
  it("TRY_TO_NUMBER('123.45', '999.99')", () => {
    validateIdentity("TRY_TO_NUMBER('123.45', '999.99')");
  });
  it("TRY_TO_NUMBER('123.45', '999.99', 10, 2)", () => {
    validateIdentity("TRY_TO_NUMBER('123.45', '999.99', 10, 2)");
  });
  it("TO_NUMERIC('123.45') -> TO_NUMBER('123.45')", () => {
    validateIdentity("TO_NUMERIC('123.45')", "TO_NUMBER('123.45')");
  });
  it("TO_NUMERIC('123.45', '999.99') -> TO_NUMBER('123.45', '999.99')", () => {
    validateIdentity("TO_NUMERIC('123.45', '999.99')", "TO_NUMBER('123.45', '999.99')");
  });
  it("TO_NUMERIC('123.45', '999.99', 10, 2) -> TO_NUMBER('123.45', '999.99', 10, 2)", () => {
    validateIdentity("TO_NUMERIC('123.45', '999.99', 10, 2)", "TO_NUMBER('123.45', '999.99', 10, 2)");
  });
  it("TRY_TO_NUMERIC('123.45') -> TRY_TO_NUMBER('123.45')", () => {
    validateIdentity("TRY_TO_NUMERIC('123.45')", "TRY_TO_NUMBER('123.45')");
  });
  it("TRY_TO_NUMERIC('123.45', '999.99') -> TRY_TO_NUMBER('123.45', '999.99')", () => {
    validateIdentity("TRY_TO_NUMERIC('123.45', '999.99')", "TRY_TO_NUMBER('123.45', '999.99')");
  });
  it("TRY_TO_NUMERIC('123.45', '999.99', 10, 2) -> TRY_TO_NUMBER('123.45', '999.99', 10, 2)", () => {
    validateIdentity("TRY_TO_NUMERIC('123.45', '999.99', 10, 2)", "TRY_TO_NUMBER('123.45', '999.99', 10, 2)");
  });
  it("snowflake -> snowflake: TRY_TO_TIME('12:30:00')", () => {
    const result = transpile("TRY_TO_TIME('12:30:00')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_CAST('12:30:00' AS TIME)");
  });
  it("snowflake -> duckdb: TRY_TO_TIME('12:30:00')", () => {
    const result = transpile("TRY_TO_TIME('12:30:00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST('12:30:00' AS TIME)");
  });
  it("TRY_TO_TIME('12:30:00', 'AUTO')", () => {
    validateIdentity("TRY_TO_TIME('12:30:00', 'AUTO')");
  });
  it("snowflake -> snowflake: TRY_TO_TIMESTAMP('2024-01-15 12:30:00')", () => {
    const result = transpile("TRY_TO_TIMESTAMP('2024-01-15 12:30:00')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_CAST('2024-01-15 12:30:00' AS TIMESTAMP)");
  });
  it("snowflake -> duckdb: TRY_TO_TIMESTAMP('2024-01-15 12:30:00')", () => {
    const result = transpile("TRY_TO_TIMESTAMP('2024-01-15 12:30:00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST('2024-01-15 12:30:00' AS TIMESTAMP)");
  });
  it("TRY_TO_TIMESTAMP('2024-01-15 12:30:00', 'AUTO')", () => {
    validateIdentity("TRY_TO_TIMESTAMP('2024-01-15 12:30:00', 'AUTO')");
  });
  it.todo("ALTER TABLE authors ADD CONSTRAINT c1 UNIQUE (id, email) (DDL/DML not supported)");
  it.todo("RM @parquet_stage (check_command_warning)");
  it.todo("REMOVE @parquet_stage (check_command_warning)");
  it("SELECT TIMESTAMP_FROM_PARTS(2024, 5, 9, 14, 30, 45)", () => {
    validateIdentity("SELECT TIMESTAMP_FROM_PARTS(2024, 5, 9, 14, 30, 45)");
  });
  it("SELECT TIMESTAMP_FROM_PARTS(2024, 5, 9, 14, 30, 45, 123)", () => {
    validateIdentity("SELECT TIMESTAMP_FROM_PARTS(2024, 5, 9, 14, 30, 45, 123)");
  });
  it("SELECT TIMESTAMP_LTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)", () => {
    validateIdentity("SELECT TIMESTAMP_LTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it("SELECT TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)", () => {
    validateIdentity("SELECT TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it("SELECT TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 0, 'America/Los_Angeles')", () => {
    validateIdentity("SELECT TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 0, 'America/Los_Angeles')");
  });
  it("SELECT TIMESTAMP_FROM_PARTS(CAST('2024-05-09' AS DATE), CAST('14:30:45' AS TIME))", () => {
    validateIdentity("SELECT TIMESTAMP_FROM_PARTS(CAST('2024-05-09' AS DATE), CAST('14:30:45' AS TIME))");
  });
  it("SELECT TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2013-04-05'), TO_TIME('12:00:00')) -> SELECT T...", () => {
    validateIdentity("SELECT TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2013-04-05'), TO_TIME('12:00:00'))", "SELECT TIMESTAMP_FROM_PARTS(CAST('2013-04-05' AS DATE), CAST('12:00:00' AS TIME))");
  });
  it("SELECT TIMESTAMP_NTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321) -> SELECT TIMESTAMP_...", () => {
    validateIdentity("SELECT TIMESTAMP_NTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321)", "SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321)");
  });
  it("SELECT DATE_FROM_PARTS(1977, 8, 7)", () => {
    validateIdentity("SELECT DATE_FROM_PARTS(1977, 8, 7)");
  });
  it("SELECT GET_PATH(v, 'attr[0].name') FROM vartab", () => {
    validateIdentity("SELECT GET_PATH(v, 'attr[0].name') FROM vartab");
  });
  it.todo("SELECT TO_ARRAY(CAST(x AS ARRAY)) (unsupported syntax)");
  it.todo("SELECT TO_ARRAY(CAST(['test'] AS VARIANT)) (unsupported syntax)");
  it("SELECT ARRAY_UNIQUE_AGG(x)", () => {
    validateIdentity("SELECT ARRAY_UNIQUE_AGG(x)");
  });
  it("SELECT ARRAY_APPEND([1, 2, 3], 4)", () => {
    validateIdentity("SELECT ARRAY_APPEND([1, 2, 3], 4)");
  });
  it("SELECT ARRAY_CAT([1, 2], [3, 4])", () => {
    validateIdentity("SELECT ARRAY_CAT([1, 2], [3, 4])");
  });
  it("SELECT ARRAY_PREPEND([2, 3, 4], 1)", () => {
    validateIdentity("SELECT ARRAY_PREPEND([2, 3, 4], 1)");
  });
  it("SELECT ARRAY_REMOVE([1, 2, 3], 2)", () => {
    validateIdentity("SELECT ARRAY_REMOVE([1, 2, 3], 2)");
  });
  it("SELECT ARRAYS_ZIP([1, 2, 3])", () => {
    validateIdentity("SELECT ARRAYS_ZIP([1, 2, 3])");
  });
  it("SELECT ARRAYS_ZIP([1, 2, 3], ['a', 'b', 'c'], [10, 20, 30])", () => {
    validateIdentity("SELECT ARRAYS_ZIP([1, 2, 3], ['a', 'b', 'c'], [10, 20, 30])");
  });
  it("SELECT AI_AGG(review, 'Summarize the reviews')", () => {
    validateIdentity("SELECT AI_AGG(review, 'Summarize the reviews')");
  });
  it("SELECT AI_SUMMARIZE_AGG(review)", () => {
    validateIdentity("SELECT AI_SUMMARIZE_AGG(review)");
  });
  it("SELECT AI_CLASSIFY('text', ['travel', 'cooking'])", () => {
    validateIdentity("SELECT AI_CLASSIFY('text', ['travel', 'cooking'])");
  });
  it("SELECT OBJECT_CONSTRUCT()", () => {
    validateIdentity("SELECT OBJECT_CONSTRUCT()");
  });
  it("SELECT CURRENT_ACCOUNT()", () => {
    validateIdentity("SELECT CURRENT_ACCOUNT()");
  });
  it("SELECT CURRENT_ACCOUNT_NAME()", () => {
    validateIdentity("SELECT CURRENT_ACCOUNT_NAME()");
  });
  it("SELECT CURRENT_AVAILABLE_ROLES()", () => {
    validateIdentity("SELECT CURRENT_AVAILABLE_ROLES()");
  });
  it("SELECT CURRENT_CLIENT()", () => {
    validateIdentity("SELECT CURRENT_CLIENT()");
  });
  it("SELECT CURRENT_IP_ADDRESS()", () => {
    validateIdentity("SELECT CURRENT_IP_ADDRESS()");
  });
  it("SELECT CURRENT_DATABASE()", () => {
    validateIdentity("SELECT CURRENT_DATABASE()");
  });
  it.todo("SELECT CURRENT_SCHEMAS() (unsupported syntax)");
  it("SELECT CURRENT_SECONDARY_ROLES()", () => {
    validateIdentity("SELECT CURRENT_SECONDARY_ROLES()");
  });
  it("SELECT CURRENT_SESSION()", () => {
    validateIdentity("SELECT CURRENT_SESSION()");
  });
  it("SELECT CURRENT_STATEMENT()", () => {
    validateIdentity("SELECT CURRENT_STATEMENT()");
  });
  it("SELECT CURRENT_VERSION()", () => {
    validateIdentity("SELECT CURRENT_VERSION()");
  });
  it("SELECT CURRENT_TRANSACTION()", () => {
    validateIdentity("SELECT CURRENT_TRANSACTION()");
  });
  it("SELECT CURRENT_WAREHOUSE()", () => {
    validateIdentity("SELECT CURRENT_WAREHOUSE()");
  });
  it("SELECT CURRENT_ORGANIZATION_USER()", () => {
    validateIdentity("SELECT CURRENT_ORGANIZATION_USER()");
  });
  it("SELECT CURRENT_REGION()", () => {
    validateIdentity("SELECT CURRENT_REGION()");
  });
  it("SELECT CURRENT_ROLE()", () => {
    validateIdentity("SELECT CURRENT_ROLE()");
  });
  it("SELECT CURRENT_ROLE_TYPE()", () => {
    validateIdentity("SELECT CURRENT_ROLE_TYPE()");
  });
  it("SELECT DAY(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT DAY(CURRENT_TIMESTAMP())");
  });
  it("SELECT DAYOFMONTH(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT DAYOFMONTH(CURRENT_TIMESTAMP())");
  });
  it("SELECT DAYOFYEAR(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT DAYOFYEAR(CURRENT_TIMESTAMP())");
  });
  it("SELECT MONTH(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT MONTH(CURRENT_TIMESTAMP())");
  });
  it("SELECT QUARTER(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT QUARTER(CURRENT_TIMESTAMP())");
  });
  it("SELECT WEEK(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT WEEK(CURRENT_TIMESTAMP())");
  });
  it("SELECT WEEKISO(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT WEEKISO(CURRENT_TIMESTAMP())");
  });
  it("WEEKOFYEAR(tstamp) -> WEEK(tstamp)", () => {
    validateIdentity("WEEKOFYEAR(tstamp)", "WEEK(tstamp)");
  });
  it("SELECT YEAR(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT YEAR(CURRENT_TIMESTAMP())");
  });
  it("SELECT YEAROFWEEK(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT YEAROFWEEK(CURRENT_TIMESTAMP())");
  });
  it("SELECT YEAROFWEEKISO(CURRENT_TIMESTAMP())", () => {
    validateIdentity("SELECT YEAROFWEEKISO(CURRENT_TIMESTAMP())");
  });
  it.todo("SELECT DAYOFWEEKISO('2024-01-15'::DATE) (unsupported syntax)");
  it.todo("SELECT YEAROFWEEK('2024-12-31'::DATE) (unsupported syntax)");
  it.todo("SELECT YEAROFWEEKISO('2024-12-31'::DATE) (unsupported syntax)");
  it.todo("SELECT WEEKISO('2024-01-15'::DATE) (unsupported syntax)");
  it("SELECT SUM(amount) FROM mytable GROUP BY ALL", () => {
    validateIdentity("SELECT SUM(amount) FROM mytable GROUP BY ALL");
  });
  it("SELECT STDDEV(x)", () => {
    validateIdentity("SELECT STDDEV(x)");
  });
  it("SELECT STDDEV(x) OVER (PARTITION BY 1)", () => {
    validateIdentity("SELECT STDDEV(x) OVER (PARTITION BY 1)");
  });
  it("SELECT STDDEV_POP(x)", () => {
    validateIdentity("SELECT STDDEV_POP(x)");
  });
  it("SELECT STDDEV_POP(x) OVER (PARTITION BY 1)", () => {
    validateIdentity("SELECT STDDEV_POP(x) OVER (PARTITION BY 1)");
  });
  it("SELECT STDDEV_SAMP(x) -> SELECT STDDEV(x)", () => {
    validateIdentity("SELECT STDDEV_SAMP(x)", "SELECT STDDEV(x)");
  });
  it("SELECT STDDEV_SAMP(x) OVER (PARTITION BY 1) -> SELECT STDDEV(x) OVER (PARTITION BY 1)", () => {
    validateIdentity("SELECT STDDEV_SAMP(x) OVER (PARTITION BY 1)", "SELECT STDDEV(x) OVER (PARTITION BY 1)");
  });
  it("SELECT KURTOSIS(x)", () => {
    validateIdentity("SELECT KURTOSIS(x)");
  });
  it("SELECT KURTOSIS(x) OVER (PARTITION BY 1)", () => {
    validateIdentity("SELECT KURTOSIS(x) OVER (PARTITION BY 1)");
  });
  it("WITH x AS (SELECT 1 AS foo) SELECT foo FROM IDENTIFIER('x')", () => {
    validateIdentity("WITH x AS (SELECT 1 AS foo) SELECT foo FROM IDENTIFIER('x')");
  });
  it("WITH x AS (SELECT 1 AS foo) SELECT IDENTIFIER('foo') FROM x", () => {
    validateIdentity("WITH x AS (SELECT 1 AS foo) SELECT IDENTIFIER('foo') FROM x");
  });
  it("INITCAP('iqamqinterestedqinqthisqtopic', 'q')", () => {
    validateIdentity("INITCAP('iqamqinterestedqinqthisqtopic', 'q')");
  });
  it("OBJECT_CONSTRUCT(*)", () => {
    validateIdentity("OBJECT_CONSTRUCT(*)");
  });
  it("SELECT CAST('2021-01-01' AS DATE) + INTERVAL '1 DAY'", () => {
    validateIdentity("SELECT CAST('2021-01-01' AS DATE) + INTERVAL '1 DAY'");
  });
  it("SELECT HLL(*)", () => {
    validateIdentity("SELECT HLL(*)");
  });
  it("SELECT HLL(a)", () => {
    validateIdentity("SELECT HLL(a)");
  });
  it("SELECT HLL(DISTINCT t.a)", () => {
    validateIdentity("SELECT HLL(DISTINCT t.a)");
  });
  it("SELECT HLL(a, b, c)", () => {
    validateIdentity("SELECT HLL(a, b, c)");
  });
  it("SELECT HLL(DISTINCT a, b, c)", () => {
    validateIdentity("SELECT HLL(DISTINCT a, b, c)");
  });
  it("$x", () => {
    validateIdentity("$x");
  });
  it("a$b", () => {
    validateIdentity("a$b");
  });
  it("SELECT REGEXP_LIKE(a, b, c)", () => {
    validateIdentity("SELECT REGEXP_LIKE(a, b, c)");
  });
  it.todo("CREATE TABLE foo (bar DOUBLE AUTOINCREMENT START 0 INCREMENT 1) (DDL/DML not supported)");
  it.todo("COMMENT IF EXISTS ON TABLE foo IS 'bar' (command not supported)");
  it("SELECT CONVERT_TIMEZONE('UTC', 'America/Los_Angeles', col)", () => {
    validateIdentity("SELECT CONVERT_TIMEZONE('UTC', 'America/Los_Angeles', col)");
  });
  it("SELECT CURRENT_ORGANIZATION_NAME()", () => {
    validateIdentity("SELECT CURRENT_ORGANIZATION_NAME()");
  });
  it.todo("ALTER TABLE a SWAP WITH b (DDL/DML not supported)");
  it("SELECT MATCH_CONDITION", () => {
    validateIdentity("SELECT MATCH_CONDITION");
  });
  it("SELECT OBJECT_AGG(key, value) FROM tbl", () => {
    validateIdentity("SELECT OBJECT_AGG(key, value) FROM tbl");
  });
  it("1 /* /* */", () => {
    validateIdentity("1 /* /* */");
  });
  it("TO_TIMESTAMP(col, fmt)", () => {
    validateIdentity("TO_TIMESTAMP(col, fmt)");
  });
  it("SELECT TO_CHAR(CAST('12:05:05' AS TIME))", () => {
    validateIdentity("SELECT TO_CHAR(CAST('12:05:05' AS TIME))");
  });
  it("SELECT TRIM(COALESCE(TO_CHAR(CAST(c AS TIME)), '')) FROM t", () => {
    validateIdentity("SELECT TRIM(COALESCE(TO_CHAR(CAST(c AS TIME)), '')) FROM t");
  });
  it("SELECT GET_PATH(PARSE_JSON(foo), 'bar')", () => {
    validateIdentity("SELECT GET_PATH(PARSE_JSON(foo), 'bar')");
  });
  it("SELECT PARSE_IP('192.168.1.1', 'INET')", () => {
    validateIdentity("SELECT PARSE_IP('192.168.1.1', 'INET')");
  });
  it("SELECT PARSE_IP('192.168.1.1', 'INET', 0)", () => {
    validateIdentity("SELECT PARSE_IP('192.168.1.1', 'INET', 0)");
  });
  it("SELECT GET_PATH(foo, 'bar')", () => {
    validateIdentity("SELECT GET_PATH(foo, 'bar')");
  });
  it("SELECT a, exclude, b FROM xxx", () => {
    validateIdentity("SELECT a, exclude, b FROM xxx");
  });
  it("SELECT ARRAY_SORT(x, TRUE, FALSE)", () => {
    validateIdentity("SELECT ARRAY_SORT(x, TRUE, FALSE)");
  });
  it("SELECT BOOLXOR_AGG(col) FROM tbl", () => {
    validateIdentity("SELECT BOOLXOR_AGG(col) FROM tbl");
  });
  it.todo("SELECT PERCENTILE_DISC(0.9) WITHIN GROUP (ORDER BY col) OVER (PARTI... (unsupported clause)");
  it("SELECT STRTOK('hello world') -> SELECT SPLIT_PART('hello world', ' ', 1)", () => {
    validateIdentity("SELECT STRTOK('hello world')", "SELECT SPLIT_PART('hello world', ' ', 1)");
  });
  it("SELECT STRTOK('hello world', ' ') -> SELECT SPLIT_PART('hello world', ' ', 1)", () => {
    validateIdentity("SELECT STRTOK('hello world', ' ')", "SELECT SPLIT_PART('hello world', ' ', 1)");
  });
  it("SELECT STRTOK('hello world', ' ', 2) -> SELECT SPLIT_PART('hello world', ' ', 2)", () => {
    validateIdentity("SELECT STRTOK('hello world', ' ', 2)", "SELECT SPLIT_PART('hello world', ' ', 2)");
  });
  it("SELECT AI_CLASSIFY('text', ['travel', 'cooking'], OBJECT_CONSTRUCT('output_mode', 'mult...", () => {
    validateIdentity("SELECT AI_CLASSIFY('text', ['travel', 'cooking'], OBJECT_CONSTRUCT('output_mode', 'multi'))");
  });
  it.todo("SELECT * FROM table AT (TIMESTAMP => '2024-07-24') UNPIVOT(a FOR b ... (unsupported clause)");
  it.todo("SELECT * FROM quarterly_sales PIVOT(SUM(amount) FOR quarter IN ('20... (unsupported clause)");
  it.todo("SELECT * FROM quarterly_sales PIVOT(SUM(amount) FOR quarter IN (SEL... (unsupported clause)");
  it.todo("SELECT * FROM quarterly_sales PIVOT(SUM(amount) FOR quarter IN (ANY... (unsupported clause)");
  it.todo("SELECT * FROM quarterly_sales PIVOT(SUM(amount) FOR quarter IN (ANY... (unsupported clause) (2)");
  it.todo("MERGE INTO my_db AS ids USING (SELECT new_id FROM my_model WHERE NO... (DDL/DML not supported)");
  it.todo("INSERT OVERWRITE TABLE t SELECT 1 (DDL/DML not supported)");
  it.todo('DESCRIBE TABLE "SNOWFLAKE_SAMPLE_DATA"."TPCDS_SF100TCL"."WEB_SITE" ... (command not supported)');
  it("SELECT * FROM DATA AS DATA_L ASOF JOIN DATA AS DATA_R MATCH_CONDITION (DATA_L.VAL > DAT...", () => {
    validateIdentity("SELECT * FROM DATA AS DATA_L ASOF JOIN DATA AS DATA_R MATCH_CONDITION (DATA_L.VAL > DATA_R.VAL) ON DATA_L.ID = DATA_R.ID");
  });
  it("SELECT TO_TIMESTAMP('2025-01-16T14:45:30.123+0500', 'yyyy-mm-DDThh24:mi:ss.ff9tzhtzm')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('2025-01-16T14:45:30.123+0500', 'yyyy-mm-DDThh24:mi:ss.ff9tzhtzm')");
  });
  it("SELECT * REPLACE (CAST(col AS TEXT) AS scol) FROM t -> SELECT * REPLACE (CAST(col AS VA...", () => {
    validateIdentity("SELECT * REPLACE (CAST(col AS TEXT) AS scol) FROM t", "SELECT * REPLACE (CAST(col AS VARCHAR) AS scol) FROM t");
  });
  it.todo("GET(value, 'foo')::VARCHAR (command not supported)");
  it("SELECT 1 put -> SELECT 1 AS put", () => {
    validateIdentity("SELECT 1 put", "SELECT 1 AS put");
  });
  it("SELECT 1 get -> SELECT 1 AS get", () => {
    validateIdentity("SELECT 1 get", "SELECT 1 AS get");
  });
  it("WITH t (SELECT 1 AS c) SELECT c FROM t -> WITH t AS (SELECT 1 AS c) SELECT c FROM t", () => {
    validateIdentity("WITH t (SELECT 1 AS c) SELECT c FROM t", "WITH t AS (SELECT 1 AS c) SELECT c FROM t");
  });
  it(`GET_PATH(json_data, '$id') -> GET_PATH(json_data, '["$id"]')`, () => {
    validateIdentity("GET_PATH(json_data, '$id')", `GET_PATH(json_data, '["$id"]')`);
  });
  it("CAST(x AS GEOGRAPHY) -> TO_GEOGRAPHY(x)", () => {
    validateIdentity("CAST(x AS GEOGRAPHY)", "TO_GEOGRAPHY(x)");
  });
  it("CAST(x AS GEOMETRY) -> TO_GEOMETRY(x)", () => {
    validateIdentity("CAST(x AS GEOMETRY)", "TO_GEOMETRY(x)");
  });
  it("transform(x, a int -> a + a + 1) -> TRANSFORM(x, a -> CAST(a AS INT) + CAST(a AS INT) + 1)", () => {
    validateIdentity("transform(x, a int -> a + a + 1)", "TRANSFORM(x, a -> CAST(a AS INT) + CAST(a AS INT) + 1)");
  });
  it("SELECT * FROM s WHERE c NOT IN (1, 2, 3) -> SELECT * FROM s WHERE NOT c IN (1, 2, 3)", () => {
    validateIdentity("SELECT * FROM s WHERE c NOT IN (1, 2, 3)", "SELECT * FROM s WHERE NOT c IN (1, 2, 3)");
  });
  it("SELECT * FROM s WHERE c NOT IN (SELECT * FROM t) -> SELECT * FROM s WHERE c <> ALL (SEL...", () => {
    validateIdentity("SELECT * FROM s WHERE c NOT IN (SELECT * FROM t)", "SELECT * FROM s WHERE c <> ALL (SELECT * FROM t)");
  });
  it("SELECT * FROM t1 INNER JOIN t2 USING (t1.col) -> SELECT * FROM t1 INNER JOIN t2 USING (...", () => {
    validateIdentity("SELECT * FROM t1 INNER JOIN t2 USING (t1.col)", "SELECT * FROM t1 INNER JOIN t2 USING (col)");
  });
  it.todo("CURRENT_TIMESTAMP - INTERVAL '1 w' AND (1 = 1) (unsupported syntax)");
  it.todo("REGEXP_REPLACE('target', 'pattern', '\n') (unsupported syntax)");
  it.todo("SELECT a:from::STRING, a:from || ' test'  (unsupported syntax)");
  it("SELECT a:select -> SELECT GET_PATH(a, 'select')", () => {
    validateIdentity("SELECT a:select", "SELECT GET_PATH(a, 'select')");
  });
  it("x:from -> GET_PATH(x, 'from')", () => {
    validateIdentity("x:from", "GET_PATH(x, 'from')");
  });
  it.todo("value:values::string::int (unsupported syntax)");
  it(`SELECT GET_PATH(PARSE_JSON('{"y": [{"z": 1}]}'), 'y[0]:z') -> SELECT GET_PATH(PARSE_JSO...`, () => {
    validateIdentity(`SELECT GET_PATH(PARSE_JSON('{"y": [{"z": 1}]}'), 'y[0]:z')`, `SELECT GET_PATH(PARSE_JSON('{"y": [{"z": 1}]}'), 'y[0].z')`);
  });
  it("SELECT p FROM t WHERE p:val NOT IN ('2') -> SELECT p FROM t WHERE NOT GET_PATH(p, 'val'...", () => {
    validateIdentity("SELECT p FROM t WHERE p:val NOT IN ('2')", "SELECT p FROM t WHERE NOT GET_PATH(p, 'val') IN ('2')");
  });
  it(`SELECT PARSE_JSON('{"x": "hello"}'):x LIKE 'hello' -> SELECT GET_PATH(PARSE_JSON('{"x":...`, () => {
    validateIdentity(`SELECT PARSE_JSON('{"x": "hello"}'):x LIKE 'hello'`, `SELECT GET_PATH(PARSE_JSON('{"x": "hello"}'), 'x') LIKE 'hello'`);
  });
  it("SELECT data:x LIKE 'hello' FROM some_table -> SELECT GET_PATH(data, 'x') LIKE 'hello' F...", () => {
    validateIdentity("SELECT data:x LIKE 'hello' FROM some_table", "SELECT GET_PATH(data, 'x') LIKE 'hello' FROM some_table");
  });
  it.todo("SELECT SUM({ fn CONVERT(123, SQL_DOUBLE) }) (unsupported syntax)");
  it.todo("SELECT SUM({ fn CONVERT(123, SQL_VARCHAR) }) (unsupported syntax)");
  it("SELECT TIMESTAMPFROMPARTS(d, t) -> SELECT TIMESTAMP_FROM_PARTS(d, t)", () => {
    validateIdentity("SELECT TIMESTAMPFROMPARTS(d, t)", "SELECT TIMESTAMP_FROM_PARTS(d, t)");
  });
  it("SELECT v:attr[0].name FROM vartab -> SELECT GET_PATH(v, 'attr[0].name') FROM vartab", () => {
    validateIdentity("SELECT v:attr[0].name FROM vartab", "SELECT GET_PATH(v, 'attr[0].name') FROM vartab");
  });
  it(`SELECT v:"fruit" FROM vartab -> SELECT GET_PATH(v, 'fruit') FROM vartab`, () => {
    validateIdentity('SELECT v:"fruit" FROM vartab', "SELECT GET_PATH(v, 'fruit') FROM vartab");
  });
  it("v:attr[0]:name -> GET_PATH(v, 'attr[0].name')", () => {
    validateIdentity("v:attr[0]:name", "GET_PATH(v, 'attr[0].name')");
  });
  it.todo("a.x:from.b:c.d::int (unsupported syntax)");
  it.todo(`SELECT PARSE_JSON('{"food":{"fruit":"banana"}}'):food.fruit::VARCHAR (unsupported syntax)`);
  it.todo("SELECT * FROM t, UNNEST(x) WITH ORDINALITY (unsupported clause)");
  it.todo("CREATE TABLE foo (ID INT COMMENT $$some comment$$) (DDL/DML not supported)");
  it("SELECT state, city, SUM(retail_price * quantity) AS gross_revenue FROM sales GROUP BY ALL", () => {
    validateIdentity("SELECT state, city, SUM(retail_price * quantity) AS gross_revenue FROM sales GROUP BY ALL");
  });
  it("SELECT * FROM foo window -> SELECT * FROM foo AS window", () => {
    validateIdentity("SELECT * FROM foo window", "SELECT * FROM foo AS window");
  });
  it.todo("SELECT RLIKE(a, $$regular expression with \\ characters: \\d{2}-\\d{3}... (unsupported syntax)");
  it.todo("SELECT $$a ' \\ \\t \\x21 z $ $$ (unsupported syntax)");
  it.todo("SELECT {'test': 'best'}::VARIANT (unsupported syntax)");
  it("SELECT {fn DAYNAME('2022-5-13')} -> SELECT DAYNAME('2022-5-13')", () => {
    validateIdentity("SELECT {fn DAYNAME('2022-5-13')}", "SELECT DAYNAME('2022-5-13')");
  });
  it("SELECT {fn LOG(5)} -> SELECT LN(5)", () => {
    validateIdentity("SELECT {fn LOG(5)}", "SELECT LN(5)");
  });
  it("SELECT {fn CEILING(5.3)} -> SELECT CEIL(5.3)", () => {
    validateIdentity("SELECT {fn CEILING(5.3)}", "SELECT CEIL(5.3)");
  });
  it("SELECT CEIL(3.14)", () => {
    validateIdentity("SELECT CEIL(3.14)");
  });
  it("SELECT CEIL(3.14, 1)", () => {
    validateIdentity("SELECT CEIL(3.14, 1)");
  });
  it("CAST(x AS BYTEINT) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS BYTEINT)", "CAST(x AS INT)");
  });
  it("CAST(x AS CHAR VARYING) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS CHAR VARYING)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS CHARACTER VARYING) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS CHARACTER VARYING)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS NCHAR VARYING) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS NCHAR VARYING)", "CAST(x AS VARCHAR)");
  });
  it.todo("CREATE OR REPLACE TEMPORARY TABLE x (y NUMBER IDENTITY(0, 1)) (DDL/DML not supported)");
  it.todo("CREATE TEMPORARY TABLE x (y NUMBER AUTOINCREMENT(0, 1)) (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE TABLE x (y NUMBER(38, 0) NOT NULL AUTOINCREMENT S... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE TABLE x (y NUMBER(38, 0) NOT NULL AUTOINCREMENT S... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE x (y NUMBER IDENTITY START 0 INCREMENT 1) (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD COLUMN id INT identity(1, 1) (DDL/DML not supported)");
  it.todo("SELECT DAYOFWEEK('2016-01-02T23:39:20.123-07:00'::TIMESTAMP) (unsupported syntax)");
  it.todo("SELECT * FROM xxx WHERE col ilike '%Don''t%' (unsupported syntax)");
  it("SELECT * EXCLUDE a, b FROM xxx -> SELECT * EXCLUDE (a), b FROM xxx", () => {
    validateIdentity("SELECT * EXCLUDE a, b FROM xxx", "SELECT * EXCLUDE (a), b FROM xxx");
  });
  it("SELECT * RENAME a AS b, c AS d FROM xxx -> SELECT * RENAME (a AS b), c AS d FROM xxx", () => {
    validateIdentity("SELECT * RENAME a AS b, c AS d FROM xxx", "SELECT * RENAME (a AS b), c AS d FROM xxx");
  });
  it("SELECT * FROM xxx, yyy, zzz, -> SELECT * FROM xxx, yyy, zzz", () => {
    validateIdentity("SELECT * FROM xxx, yyy, zzz,", "SELECT * FROM xxx, yyy, zzz");
  });
  it("SELECT * FROM xxx, yyy, zzz, WHERE foo = bar -> SELECT * FROM xxx, yyy, zzz WHERE foo =...", () => {
    validateIdentity("SELECT * FROM xxx, yyy, zzz, WHERE foo = bar", "SELECT * FROM xxx, yyy, zzz WHERE foo = bar");
  });
  it("SELECT * FROM xxx, yyy, zzz -> SELECT * FROM xxx, yyy, zzz", () => {
    validateIdentity("SELECT * FROM xxx, yyy, zzz", "SELECT * FROM xxx, yyy, zzz");
  });
  it("snowflake -> duckdb: SELECT LTRIM(RTRIM(col)) FROM t1", () => {
    const result = transpile("SELECT LTRIM(RTRIM(col)) FROM t1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LTRIM(RTRIM(col)) FROM t1");
  });
  it("snowflake -> snowflake: SELECT LTRIM(RTRIM(col)) FROM t1", () => {
    const result = transpile("SELECT LTRIM(RTRIM(col)) FROM t1", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LTRIM(RTRIM(col)) FROM t1");
  });
  it.todo("bigquery -> snowflake: SELECT x FROM UNNEST([STRUCT('x' AS x)]) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT => [OBJECT_CONS...", () => {
    const result = transpile("SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'x')])) AS _t0(seq, key, path, index, value, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'x')])) AS _t0(seq, key, path, index, value, this)");
  });
  it.todo("bigquery -> snowflake: SELECT x, y, z FROM UNNEST([STRUCT(1 AS x, 2 AS y, 3 AS z)]) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT value['x'] AS x, value['y'] AS y, value['z'] AS z FROM T...", () => {
    const result = transpile("SELECT value['x'] AS x, value['y'] AS y, value['z'] AS z FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1, 'y', 2, 'z', 3)])) AS _t0(seq, key, path, index, value, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT value['x'] AS x, value['y'] AS y, value['z'] AS z FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1, 'y', 2, 'z', 3)])) AS _t0(seq, key, path, index, value, this)");
  });
  it.todo("bigquery -> snowflake: SELECT u1.x, u2.y FROM UNNEST([STRUCT(1 AS x)]) AS u1, UNNEST([S... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT u1['x'] AS x, u2['y'] AS y FROM TABLE(FLATTEN(INPUT => [...", () => {
    const result = transpile("SELECT u1['x'] AS x, u2['y'] AS y FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1)])) AS _t0(seq, key, path, index, u1, this) CROSS JOIN TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('y', 2)])) AS _t1(seq, key, path, index, u2, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT u1['x'] AS x, u2['y'] AS y FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1)])) AS _t0(seq, key, path, index, u1, this) CROSS JOIN TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('y', 2)])) AS _t1(seq, key, path, index, u2, this)");
  });
  it.todo("SELECT t.id, value['name'] AS name, value['age'] AS age FROM t CROS... (unsupported syntax)");
  it.todo("bigquery -> snowflake: SELECT value FROM UNNEST([STRUCT(1 AS x)]) AS value (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT value FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x',...", () => {
    const result = transpile("SELECT value FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1)])) AS _t0(seq, key, path, index, value, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT value FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 1)])) AS _t0(seq, key, path, index, value, this)");
  });
  it.todo("bigquery -> snowflake: SELECT t.col1, field1, other_col, field2 FROM t, UNNEST([STRUCT(... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT t.col1, value['field1'] AS field1, other_col, value['fie...", () => {
    const result = transpile("SELECT t.col1, value['field1'] AS field1, other_col, value['field2'] AS field2 FROM t CROSS JOIN TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('field1', 'a', 'field2', 'b')])) AS _t0(seq, key, path, index, value, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT t.col1, value['field1'] AS field1, other_col, value['field2'] AS field2 FROM t CROSS JOIN TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('field1', 'a', 'field2', 'b')])) AS _t0(seq, key, path, index, value, this)");
  });
  it.todo("bigquery -> snowflake: SELECT * FROM (SELECT x FROM UNNEST([STRUCT('value' AS x)])) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT * FROM (SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT ...", () => {
    const result = transpile("SELECT * FROM (SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'value')])) AS _t0(seq, key, path, index, value, this))", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM (SELECT value['x'] AS x FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'value')])) AS _t0(seq, key, path, index, value, this))");
  });
  it.todo("bigquery -> snowflake: SELECT value FROM UNNEST([1, 2, 3]) AS value (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT value FROM TABLE(FLATTEN(INPUT => [1, 2, 3])) AS _t0(seq...", () => {
    const result = transpile("SELECT value FROM TABLE(FLATTEN(INPUT => [1, 2, 3])) AS _t0(seq, key, path, index, value, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT value FROM TABLE(FLATTEN(INPUT => [1, 2, 3])) AS _t0(seq, key, path, index, value, this)");
  });
  it("bigquery -> snowflake: SELECT * FROM t1 AS t1, t2 AS t2 LEFT JOIN t3 AS t3 ON t1.a = t3.i", () => {
    const result = transpile("SELECT * FROM t1 AS t1, t2 AS t2 LEFT JOIN t3 AS t3 ON t1.a = t3.i", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 AS t1 CROSS JOIN t2 AS t2 LEFT JOIN t3 AS t3 ON t1.a = t3.i");
  });
  it("snowflake -> snowflake: SELECT * FROM t1 AS t1 CROSS JOIN t2 AS t2 LEFT JOIN t3 AS t3 O...", () => {
    const result = transpile("SELECT * FROM t1 AS t1 CROSS JOIN t2 AS t2 LEFT JOIN t3 AS t3 ON t1.a = t3.i", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 AS t1 CROSS JOIN t2 AS t2 LEFT JOIN t3 AS t3 ON t1.a = t3.i");
  });
  it.todo("bigquery -> snowflake: SELECT x, yval, zval FROM UNNEST([STRUCT('x' AS x, ['y1', 'y2', ... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT value['x'] AS x, yval, zval FROM TABLE(FLATTEN(INPUT => ...", () => {
    const result = transpile("SELECT value['x'] AS x, yval, zval FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'x', 'y', ['y1', 'y2', 'y3'], 'z', ['z1', 'z2', 'z3'])])) AS _t0(seq, key, path, index, value, this) CROSS JOIN TABLE(FLATTEN(INPUT => value['y'])) AS _t1(seq, key, path, index, yval, this) CROSS JOIN TABLE(FLATTEN(INPUT => value['z'])) AS _t2(seq, key, path, index, zval, this)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT value['x'] AS x, yval, zval FROM TABLE(FLATTEN(INPUT => [OBJECT_CONSTRUCT('x', 'x', 'y', ['y1', 'y2', 'y3'], 'z', ['z1', 'z2', 'z3'])])) AS _t0(seq, key, path, index, value, this) CROSS JOIN TABLE(FLATTEN(INPUT => value['y'])) AS _t1(seq, key, path, index, yval, this) CROSS JOIN TABLE(FLATTEN(INPUT => value['z'])) AS _t2(seq, key, path, index, zval, this)");
  });
  it.todo("bigquery -> snowflake: SELECT _u.foo, bar, baz FROM UNNEST([struct('x' AS foo, ['y', 'z... (cross-dialect transform)");
  it.todo("bigquery -> snowflake: select _u, _u.foo, _u.bar from unnest([struct('x' as foo, 'y' AS... (cross-dialect transform)");
  it.todo("bigquery -> snowflake: select _u.foo[0].bar from unnest([struct([struct(1 as bar)] as f... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT ARRAY_INTERSECTION([1, 2], [2, 3])", () => {
    const result = transpile("SELECT ARRAY_INTERSECTION([1, 2], [2, 3])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_INTERSECTION([1, 2], [2, 3])");
  });
  it("snowflake -> starrocks: SELECT ARRAY_INTERSECTION([1, 2], [2, 3])", () => {
    const result = transpile("SELECT ARRAY_INTERSECTION([1, 2], [2, 3])", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT ARRAY_INTERSECT([1, 2], [2, 3])");
  });
  it.todo("CREATE TABLE test_table (id NUMERIC NOT NULL AUTOINCREMENT) (DDL/DML not supported)");
  it.todo("snowflake -> : SELECT TO_TIMESTAMP('2025-01-16 14:45:30.123', 'yyyy-mm-DD hh24:mi:ss.ff6') (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP('2025-01-16 14:45:30.123', 'yyyy-mm-DD hh24...", () => {
    const result = transpile("SELECT TO_TIMESTAMP('2025-01-16 14:45:30.123', 'yyyy-mm-DD hh24:mi:ss.ff6')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('2025-01-16 14:45:30.123', 'yyyy-mm-DD hh24:mi:ss.ff6')");
  });
  it.todo("snowflake -> spark: ARRAY_CONSTRUCT_COMPACT(1, null, 2) (unsupported syntax)");
  it("snowflake -> snowflake: ARRAY_CONSTRUCT_COMPACT(1, null, 2)", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT(1, null, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CONSTRUCT_COMPACT(1, NULL, 2)");
  });
  it("spark -> snowflake: ARRAY_COMPACT(arr)", () => {
    const result = transpile("ARRAY_COMPACT(arr)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_COMPACT(arr)");
  });
  it("databricks -> snowflake: ARRAY_COMPACT(arr)", () => {
    const result = transpile("ARRAY_COMPACT(arr)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_COMPACT(arr)");
  });
  it("snowflake -> snowflake: ARRAY_COMPACT(arr)", () => {
    const result = transpile("ARRAY_COMPACT(arr)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_COMPACT(arr)");
  });
  it("snowflake -> spark: ARRAY_COMPACT(arr)", () => {
    const result = transpile("ARRAY_COMPACT(arr)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ARRAY_COMPACT(arr)");
  });
  it("snowflake -> databricks: ARRAY_COMPACT(arr)", () => {
    const result = transpile("ARRAY_COMPACT(arr)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("ARRAY_COMPACT(arr)");
  });
  it("bigquery -> snowflake: JSON_OBJECT(['key_1', 'key_2'], ['one', NULL])", () => {
    const result = transpile("JSON_OBJECT(['key_1', 'key_2'], ['one', NULL])", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)");
  });
  it("duckdb -> snowflake: JSON_OBJECT('key_1', 'one', 'key_2', NULL)", () => {
    const result = transpile("JSON_OBJECT('key_1', 'one', 'key_2', NULL)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)");
  });
  it("snowflake -> bigquery: OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", () => {
    const result = transpile("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("JSON_OBJECT('key_1', 'one', 'key_2', NULL)");
  });
  it("snowflake -> duckdb: OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", () => {
    const result = transpile("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("JSON_OBJECT('key_1', 'one', 'key_2', NULL)");
  });
  it("snowflake -> snowflake: OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", () => {
    const result = transpile("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL)");
  });
  it("snowflake -> duckdb: SELECT TIME_FROM_PARTS(12, 34, 56)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(12, 34, 56)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_TIME(12, 34, 56)");
  });
  it("snowflake -> snowflake: SELECT TIME_FROM_PARTS(12, 34, 56)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(12, 34, 56)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIME_FROM_PARTS(12, 34, 56)");
  });
  it("snowflake -> duckdb: SELECT TIME_FROM_PARTS(12, 34, 56, 987654321)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(12, 34, 56, 987654321)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('00:00:00' AS TIME) + INTERVAL ((12 * 3600) + (34 * 60) + 56 + (987654321 / 1000000000.0)) SECOND");
  });
  it("snowflake -> snowflake: SELECT TIME_FROM_PARTS(12, 34, 56, 987654321)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(12, 34, 56, 987654321)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIME_FROM_PARTS(12, 34, 56, 987654321)");
  });
  it("snowflake -> duckdb: SELECT TIME_FROM_PARTS(0, 100, 0)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(0, 100, 0)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('00:00:00' AS TIME) + INTERVAL ((0 * 3600) + (100 * 60) + 0) SECOND");
  });
  it("snowflake -> snowflake: SELECT TIME_FROM_PARTS(0, 100, 0)", () => {
    const result = transpile("SELECT TIME_FROM_PARTS(0, 100, 0)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIME_FROM_PARTS(0, 100, 0)");
  });
  it("SELECT TIMESTAMPNTZFROMPARTS(2013, 4, 5, 12, 00, 00) -> SELECT TIMESTAMP_FROM_PARTS(201...", () => {
    validateIdentity("SELECT TIMESTAMPNTZFROMPARTS(2013, 4, 5, 12, 00, 00)", "SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it("duckdb -> snowflake: SELECT MAKE_TIMESTAMP(2013, 4, 5, 12, 00, 00)", () => {
    const result = transpile("SELECT MAKE_TIMESTAMP(2013, 4, 5, 12, 00, 00)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it("snowflake -> snowflake: SELECT TIMESTAMP_NTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)", () => {
    const result = transpile("SELECT TIMESTAMP_NTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it("snowflake -> duckdb: SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)", () => {
    const result = transpile("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_TIMESTAMP(2013, 4, 5, 12, 00, 00)");
  });
  it("snowflake -> snowflake: SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)", () => {
    const result = transpile("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 00, 00)");
  });
  it.todo("snowflake -> duckdb: SELECT TIMESTAMP_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME('14:30:... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TIMESTAMP_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME('14:...", () => {
    const result = transpile("SELECT TIMESTAMP_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME('14:30:45'))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIMESTAMP_FROM_PARTS(CAST('2023-06-15' AS DATE), CAST('14:30:45' AS TIME))");
  });
  it.todo("snowflake -> duckdb: SELECT TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME('14... (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME(...", () => {
    const result = transpile("SELECT TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2023-06-15'), TO_TIME('14:30:45'))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIMESTAMP_FROM_PARTS(CAST('2023-06-15' AS DATE), CAST('14:30:45' AS TIME))");
  });
  it("snowflake -> duckdb: SELECT TIMESTAMP_LTZ_FROM_PARTS(2023, 6, 15, 14, 30, 45)", () => {
    const result = transpile("SELECT TIMESTAMP_LTZ_FROM_PARTS(2023, 6, 15, 14, 30, 45)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_TIMESTAMP(2023, 6, 15, 14, 30, 45) AS TIMESTAMPTZ)");
  });
  it("snowflake -> snowflake: SELECT TIMESTAMP_LTZ_FROM_PARTS(2023, 6, 15, 14, 30, 45)", () => {
    const result = transpile("SELECT TIMESTAMP_LTZ_FROM_PARTS(2023, 6, 15, 14, 30, 45)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIMESTAMP_LTZ_FROM_PARTS(2023, 6, 15, 14, 30, 45)");
  });
  it.todo("snowflake -> duckdb: SELECT TIMESTAMP_TZ_FROM_PARTS(2023, 6, 15, 14, 30, 45, 0, 'Americ... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT TIMESTAMP_TZ_FROM_PARTS(2023, 6, 15, 14, 30, 45, 0, 'Ame...", () => {
    const result = transpile("SELECT TIMESTAMP_TZ_FROM_PARTS(2023, 6, 15, 14, 30, 45, 0, 'America/Los_Angeles')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TIMESTAMP_TZ_FROM_PARTS(2023, 6, 15, 14, 30, 45, 0, 'America/Los_Angeles')");
  });
  it(`snowflake -> bigquery: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banan...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}]}]')) SELECT GET_PATH(v, '[0].attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`WITH vartab AS (SELECT PARSE_JSON('[{"attr": [{"name": "banana"}]}]') AS v) SELECT JSON_EXTRACT(v, '$[0].attr[0].name') FROM vartab`);
  });
  it.todo(`snowflake -> duckdb: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"... (unsupported syntax)`);
  it(`snowflake -> mysql: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}]}]')) SELECT GET_PATH(v, '[0].attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT '[{"attr": [{"name": "banana"}]}]') SELECT JSON_EXTRACT(v, '$[0].attr[0].name') FROM vartab`);
  });
  it(`snowflake -> presto: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}]}]')) SELECT GET_PATH(v, '[0].attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT JSON_PARSE('[{"attr": [{"name": "banana"}]}]')) SELECT JSON_EXTRACT(v, '$[0].attr[0].name') FROM vartab`);
  });
  it(`snowflake -> snowflake: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "bana...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}]}]')) SELECT GET_PATH(v, '[0].attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT PARSE_JSON('[{"attr": [{"name": "banana"}]}]')) SELECT GET_PATH(v, '[0].attr[0].name') FROM vartab`);
  });
  it.todo(`snowflake -> tsql: WITH vartab(v) AS (select parse_json('[{"attr": [{"name": "banana"}]... (unsupported syntax)`);
  it(`snowflake -> bigquery: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]}')) SELECT GET_PATH(v, 'attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`WITH vartab AS (SELECT PARSE_JSON('{"attr": [{"name": "banana"}]}') AS v) SELECT JSON_EXTRACT(v, '$.attr[0].name') FROM vartab`);
  });
  it.todo(`snowflake -> duckdb: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}... (unsupported syntax)`);
  it(`snowflake -> mysql: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]}')) SELECT GET_PATH(v, 'attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT '{"attr": [{"name": "banana"}]}') SELECT JSON_EXTRACT(v, '$.attr[0].name') FROM vartab`);
  });
  it(`snowflake -> presto: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]}')) SELECT GET_PATH(v, 'attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT JSON_PARSE('{"attr": [{"name": "banana"}]}')) SELECT JSON_EXTRACT(v, '$.attr[0].name') FROM vartab`);
  });
  it(`snowflake -> snowflake: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banan...`, () => {
    const result = transpile(`WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]}')) SELECT GET_PATH(v, 'attr[0].name') FROM vartab`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`WITH vartab(v) AS (SELECT PARSE_JSON('{"attr": [{"name": "banana"}]}')) SELECT GET_PATH(v, 'attr[0].name') FROM vartab`);
  });
  it.todo(`snowflake -> tsql: WITH vartab(v) AS (select parse_json('{"attr": [{"name": "banana"}]}... (unsupported syntax)`);
  it(`snowflake -> bigquery: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT(PARSE_JSON('{"fruit":"banana"}'), '$.fruit')`);
  });
  it(`snowflake -> databricks: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`);
  });
  it.todo(`snowflake -> duckdb: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit (unsupported syntax)`);
  it(`snowflake -> mysql: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT('{"fruit":"banana"}', '$.fruit')`);
  });
  it(`snowflake -> presto: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT(JSON_PARSE('{"fruit":"banana"}'), '$.fruit')`);
  });
  it(`snowflake -> snowflake: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT GET_PATH(PARSE_JSON('{"fruit":"banana"}'), 'fruit')`);
  });
  it(`snowflake -> spark: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"fruit":"banana"}'):fruit`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe(`SELECT GET_JSON_OBJECT('{"fruit":"banana"}', '$.fruit')`);
  });
  it.todo(`snowflake -> tsql: SELECT PARSE_JSON('{"fruit":"banana"}'):fruit (unsupported syntax)`);
  it.todo("SELECT TO_ARRAY(['test']) (unsupported syntax)");
  it.todo("SELECT TO_ARRAY(['test']) (unsupported syntax) (2)");
  it.todo('duckdb -> snowflake: WITH t(x, "value") AS (SELECT [1,2,3], 1) SELECT UNNEST(t.x) AS "v... (cross-dialect transform)');
  it("snowflake -> duckdb: SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_capital", () => {
    const result = transpile("SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_capital", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT {'Manitoba': 'Winnipeg', 'foo': 'bar'} AS province_capital");
  });
  it("snowflake -> snowflake: SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_cap...", () => {
    const result = transpile("SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_capital", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT OBJECT_CONSTRUCT('Manitoba', 'Winnipeg', 'foo', 'bar') AS province_capital");
  });
  it("snowflake -> spark: SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_capital", () => {
    const result = transpile("SELECT { 'Manitoba': 'Winnipeg', 'foo': 'bar' } AS province_capital", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT STRUCT('Winnipeg' AS Manitoba, 'bar' AS foo) AS province_capital");
  });
  it("snowflake -> bigquery: SELECT COLLATE('B', 'und:ci')", () => {
    const result = transpile("SELECT COLLATE('B', 'und:ci')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT COLLATE('B', 'und:ci')");
  });
  it("snowflake -> snowflake: SELECT COLLATE('B', 'und:ci')", () => {
    const result = transpile("SELECT COLLATE('B', 'und:ci')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT COLLATE('B', 'und:ci')");
  });
  it.todo("snowflake -> duckdb: SELECT To_BOOLEAN('T') (unsupported syntax)");
  it.todo("SELECT * FROM x START WITH a = b CONNECT BY c = PRIOR d (unsupported clause)");
  it("mysql -> snowflake: SELECT INSERT(a, 0, 0, 'b')", () => {
    const result = transpile("SELECT INSERT(a, 0, 0, 'b')", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT INSERT(a, 0, 0, 'b')");
  });
  it("snowflake -> snowflake: SELECT INSERT(a, 0, 0, 'b')", () => {
    const result = transpile("SELECT INSERT(a, 0, 0, 'b')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT INSERT(a, 0, 0, 'b')");
  });
  it("tsql -> snowflake: SELECT STUFF(a, 0, 0, 'b')", () => {
    const result = transpile("SELECT STUFF(a, 0, 0, 'b')", { readDialect: "tsql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT INSERT(a, 0, 0, 'b')");
  });
  it("snowflake -> mysql: SELECT INSERT(a, 0, 0, 'b')", () => {
    const result = transpile("SELECT INSERT(a, 0, 0, 'b')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT INSERT(a, 0, 0, 'b')");
  });
  it("snowflake -> snowflake: SELECT INSERT(a, 0, 0, 'b') (2)", () => {
    const result = transpile("SELECT INSERT(a, 0, 0, 'b')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT INSERT(a, 0, 0, 'b')");
  });
  it("snowflake -> tsql: SELECT INSERT(a, 0, 0, 'b')", () => {
    const result = transpile("SELECT INSERT(a, 0, 0, 'b')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("SELECT STUFF(a, 0, 0, 'b')");
  });
  it.todo("snowflake -> bigquery: ARRAY_GENERATE_RANGE(0, 3) (unsupported syntax)");
  it.todo("snowflake -> postgres: ARRAY_GENERATE_RANGE(0, 3) (unsupported syntax)");
  it("snowflake -> presto: ARRAY_GENERATE_RANGE(0, 3)", () => {
    const result = transpile("ARRAY_GENERATE_RANGE(0, 3)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SEQUENCE(0, 3 - 1)");
  });
  it("snowflake -> snowflake: ARRAY_GENERATE_RANGE(0, 3)", () => {
    const result = transpile("ARRAY_GENERATE_RANGE(0, 3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_GENERATE_RANGE(0, (3 - 1) + 1)");
  });
  it.todo("bigquery -> snowflake: GENERATE_ARRAY(0, 3) (unsupported syntax)");
  it.todo("postgres -> snowflake: GENERATE_SERIES(0, 3) (unsupported syntax)");
  it("presto -> snowflake: SEQUENCE(0, 3)", () => {
    const result = transpile("SEQUENCE(0, 3)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_GENERATE_RANGE(0, 3 + 1)");
  });
  it.todo("SELECT DATE_PART('year', TIMESTAMP '2020-01-01') (unsupported syntax)");
  it.todo("SELECT * FROM (VALUES (0) foo(bar)) (unsupported syntax)");
  it(" -> snowflake: STRUCT(b as a, d as c)", () => {
    const result = transpile("STRUCT(b as a, d as c)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("OBJECT_CONSTRUCT('a', b, 'c', d)");
  });
  it("snowflake -> duckdb: OBJECT_CONSTRUCT('a', b, 'c', d)", () => {
    const result = transpile("OBJECT_CONSTRUCT('a', b, 'c', d)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("{'a': b, 'c': d}");
  });
  it("snowflake -> snowflake: OBJECT_CONSTRUCT('a', b, 'c', d)", () => {
    const result = transpile("OBJECT_CONSTRUCT('a', b, 'c', d)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("OBJECT_CONSTRUCT('a', b, 'c', d)");
  });
  it("snowflake -> : OBJECT_CONSTRUCT('a', b, 'c', d)", () => {
    const result = transpile("OBJECT_CONSTRUCT('a', b, 'c', d)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("STRUCT(b AS a, d AS c)");
  });
  it("OBJECT_CONSTRUCT(a, b, c, d)", () => {
    validateIdentity("OBJECT_CONSTRUCT(a, b, c, d)");
  });
  it.todo("SELECT i, p, o FROM qt QUALIFY ROW_NUMBER() OVER (PARTITION BY p OR... (unsupported clause)");
  it("snowflake -> snowflake: SELECT NTH_VALUE(is_deleted, 2) FROM FIRST IGNORE NULLS OVER (P...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) FROM FIRST IGNORE NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2) FROM FIRST IGNORE NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> duckdb: SELECT NTH_VALUE(is_deleted, 2) FROM FIRST IGNORE NULLS OVER (PART...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) FROM FIRST IGNORE NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2 IGNORE NULLS) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> snowflake: SELECT NTH_VALUE(is_deleted, 2) FROM LAST RESPECT NULLS OVER (P...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) FROM LAST RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2) FROM LAST RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> duckdb: SELECT NTH_VALUE(is_deleted, 2) FROM LAST RESPECT NULLS OVER (PART...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) FROM LAST RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2 RESPECT NULLS) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> snowflake: SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_i...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> duckdb: SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_d...", () => {
    const result = transpile("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> snowflake: SELECT LEAD(is_deleted, 2, -10) RESPECT NULLS OVER (PARTITION B...", () => {
    const result = transpile("SELECT LEAD(is_deleted, 2, -10) RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LEAD(is_deleted, 2, -10) RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> duckdb: SELECT LEAD(is_deleted, 2, -10) RESPECT NULLS OVER (PARTITION BY i...", () => {
    const result = transpile("SELECT LEAD(is_deleted, 2, -10) RESPECT NULLS OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LEAD(is_deleted, 2, -10 RESPECT NULLS) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> snowflake: SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_del...", () => {
    const result = transpile("SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("snowflake -> duckdb: SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_delete...", () => {
    const result = transpile("SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LEAD(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it.todo("snowflake -> : SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test (cross-dialect transform)");
  it.todo("snowflake -> duckdb: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test (cross-dialect transform)");
  it("snowflake -> oracle: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT MAX(c1), MAX(c2) FROM test");
  });
  it.todo("snowflake -> postgres: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test");
  });
  it.todo("snowflake -> spark: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test (cross-dialect transform)");
  it("snowflake -> sqlite: SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLOR_AGG(c1), BOOLOR_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT MAX(c1), MAX(c2) FROM test");
  });
  it("snowflake -> : SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT LOGICAL_AND(c1), LOGICAL_AND(c2) FROM test");
  });
  it("snowflake -> duckdb: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT BOOL_AND(CAST(c1 AS BOOLEAN)), BOOL_AND(CAST(c2 AS BOOLEAN)) FROM test");
  });
  it("snowflake -> oracle: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT MIN(c1), MIN(c2) FROM test");
  });
  it("snowflake -> postgres: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT BOOL_AND(c1), BOOL_AND(c2) FROM test");
  });
  it("snowflake -> snowflake: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test");
  });
  it("snowflake -> spark: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT BOOL_AND(c1), BOOL_AND(c2) FROM test");
  });
  it("snowflake -> sqlite: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT MIN(c1), MIN(c2) FROM test");
  });
  it("snowflake -> mysql: SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", () => {
    const result = transpile("SELECT BOOLAND_AGG(c1), BOOLAND_AGG(c2) FROM test", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT MIN(c1), MIN(c2) FROM test");
  });
  it("snowflake -> duckdb: SELECT BOOLXOR_AGG(c1) FROM test", () => {
    const result = transpile("SELECT BOOLXOR_AGG(c1) FROM test", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COUNT_IF(CAST(c1 AS BOOLEAN)) = 1 FROM test");
  });
  it("snowflake -> snowflake: SELECT BOOLXOR_AGG(c1) FROM test", () => {
    const result = transpile("SELECT BOOLXOR_AGG(c1) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLXOR_AGG(c1) FROM test");
  });
  it.todo("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x) (unsupported clause)");
  it("snowflake -> : SELECT COVAR_POP(y, x)", () => {
    const result = transpile("SELECT COVAR_POP(y, x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x)");
  });
  it("snowflake -> duckdb: SELECT COVAR_POP(y, x)", () => {
    const result = transpile("SELECT COVAR_POP(y, x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x)");
  });
  it("snowflake -> postgres: SELECT COVAR_POP(y, x)", () => {
    const result = transpile("SELECT COVAR_POP(y, x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x)");
  });
  it("snowflake -> snowflake: SELECT COVAR_POP(y, x)", () => {
    const result = transpile("SELECT COVAR_POP(y, x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x)");
  });
  it("snowflake -> : SELECT COVAR_SAMP(y, x)", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x)");
  });
  it("snowflake -> duckdb: SELECT COVAR_SAMP(y, x)", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x)");
  });
  it("snowflake -> postgres: SELECT COVAR_SAMP(y, x)", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x)");
  });
  it("snowflake -> snowflake: SELECT COVAR_SAMP(y, x)", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x)");
  });
  it.todo("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x) OVER () (unsupported clause)");
  it("snowflake -> : SELECT COVAR_POP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_POP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x) OVER ()");
  });
  it("snowflake -> duckdb: SELECT COVAR_POP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_POP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x) OVER ()");
  });
  it("snowflake -> postgres: SELECT COVAR_POP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_POP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x) OVER ()");
  });
  it("snowflake -> snowflake: SELECT COVAR_POP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_POP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT COVAR_POP(y, x) OVER ()");
  });
  it("snowflake -> : SELECT COVAR_SAMP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x) OVER ()");
  });
  it("snowflake -> duckdb: SELECT COVAR_SAMP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x) OVER ()");
  });
  it("snowflake -> postgres: SELECT COVAR_SAMP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x) OVER ()");
  });
  it("snowflake -> snowflake: SELECT COVAR_SAMP(y, x) OVER ()", () => {
    const result = transpile("SELECT COVAR_SAMP(y, x) OVER ()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT COVAR_SAMP(y, x) OVER ()");
  });
  it(" -> snowflake: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> snowflake: TO_VARCHAR(x, y)", () => {
    const result = transpile("TO_VARCHAR(x, y)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it.todo("snowflake -> : TO_CHAR(x, y) (cross-dialect transform)");
  it("snowflake -> databricks: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> drill: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "drill" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> oracle: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> postgres: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> snowflake: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it("snowflake -> teradata: TO_CHAR(x, y)", () => {
    const result = transpile("TO_CHAR(x, y)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("TO_CHAR(x, y)");
  });
  it.todo("TO_CHAR(foo::DATE, 'yyyy') (unsupported syntax)");
  it.todo("TO_CHAR(foo::TIMESTAMP, 'YYYY-MM') (unsupported syntax)");
  it.todo("TO_VARCHAR(foo::DATE, 'yyyy') (unsupported syntax)");
  it.todo("TO_VARCHAR(foo::TIMESTAMP, 'YYYY-MM') (unsupported syntax)");
  it("snowflake -> bigquery: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> clickhouse: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> databricks: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> drill: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "drill" })[0];
    expect(result).toBe("POW(x, 2)");
  });
  it("snowflake -> duckdb: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> hive: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> mysql: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> oracle: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> postgres: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> presto: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> redshift: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> snowflake: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> spark: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> sqlite: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> starrocks: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> teradata: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("x ** 2");
  });
  it("snowflake -> trino: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> tsql: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("oracle -> snowflake: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> snowflake: SQUARE(x) (2)", () => {
    const result = transpile("SQUARE(x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("tsql -> snowflake: SQUARE(x)", () => {
    const result = transpile("SQUARE(x)", { readDialect: "tsql", writeDialect: DIALECT })[0];
    expect(result).toBe("POWER(x, 2)");
  });
  it("snowflake -> snowflake: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF(bar = 0 AND NOT foo IS NULL, 0, foo / bar)");
  });
  it("snowflake -> sqlite: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF(bar = 0 AND NOT foo IS NULL, 0, CAST(foo AS REAL) / bar)");
  });
  it("snowflake -> presto: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(bar = 0 AND NOT foo IS NULL, 0, CAST(foo AS DOUBLE) / bar)");
  });
  it("snowflake -> spark: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF(bar = 0 AND NOT foo IS NULL, 0, foo / bar)");
  });
  it("snowflake -> hive: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF(bar = 0 AND NOT foo IS NULL, 0, foo / bar)");
  });
  it("snowflake -> duckdb: DIV0(foo, bar)", () => {
    const result = transpile("DIV0(foo, bar)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN bar = 0 AND NOT foo IS NULL THEN 0 ELSE foo / bar END");
  });
  it("snowflake -> snowflake: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF((c - d) = 0 AND NOT (a - b) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> sqlite: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF((c - d) = 0 AND NOT (a - b) IS NULL, 0, CAST((a - b) AS REAL) / (c - d))");
  });
  it("snowflake -> presto: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF((c - d) = 0 AND NOT (a - b) IS NULL, 0, CAST((a - b) AS DOUBLE) / (c - d))");
  });
  it("snowflake -> spark: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF((c - d) = 0 AND NOT (a - b) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> hive: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF((c - d) = 0 AND NOT (a - b) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> duckdb: DIV0(a - b, c - d)", () => {
    const result = transpile("DIV0(a - b, c - d)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN (c - d) = 0 AND NOT (a - b) IS NULL THEN 0 ELSE (a - b) / (c - d) END");
  });
  it("snowflake -> snowflake: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF(bar = 0 OR bar IS NULL, 0, foo / bar)");
  });
  it("snowflake -> sqlite: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF(bar = 0 OR bar IS NULL, 0, CAST(foo AS REAL) / bar)");
  });
  it("snowflake -> presto: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(bar = 0 OR bar IS NULL, 0, CAST(foo AS DOUBLE) / bar)");
  });
  it("snowflake -> spark: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF(bar = 0 OR bar IS NULL, 0, foo / bar)");
  });
  it("snowflake -> hive: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF(bar = 0 OR bar IS NULL, 0, foo / bar)");
  });
  it("snowflake -> duckdb: DIV0NULL(foo, bar)", () => {
    const result = transpile("DIV0NULL(foo, bar)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN bar = 0 OR bar IS NULL THEN 0 ELSE foo / bar END");
  });
  it("snowflake -> snowflake: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF((c - d) = 0 OR (c - d) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> sqlite: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF((c - d) = 0 OR (c - d) IS NULL, 0, CAST((a - b) AS REAL) / (c - d))");
  });
  it("snowflake -> presto: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF((c - d) = 0 OR (c - d) IS NULL, 0, CAST((a - b) AS DOUBLE) / (c - d))");
  });
  it("snowflake -> spark: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF((c - d) = 0 OR (c - d) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> hive: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF((c - d) = 0 OR (c - d) IS NULL, 0, (a - b) / (c - d))");
  });
  it("snowflake -> duckdb: DIV0NULL(a - b, c - d)", () => {
    const result = transpile("DIV0NULL(a - b, c - d)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN (c - d) = 0 OR (c - d) IS NULL THEN 0 ELSE (a - b) / (c - d) END");
  });
  it("snowflake -> snowflake: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF(foo IS NULL, 0, foo)");
  });
  it("snowflake -> sqlite: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF(foo IS NULL, 0, foo)");
  });
  it("snowflake -> presto: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(foo IS NULL, 0, foo)");
  });
  it("snowflake -> spark: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF(foo IS NULL, 0, foo)");
  });
  it("snowflake -> hive: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF(foo IS NULL, 0, foo)");
  });
  it("snowflake -> duckdb: ZEROIFNULL(foo)", () => {
    const result = transpile("ZEROIFNULL(foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN foo IS NULL THEN 0 ELSE foo END");
  });
  it("snowflake -> snowflake: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("IFF(foo = 0, NULL, foo)");
  });
  it("snowflake -> sqlite: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("IIF(foo = 0, NULL, foo)");
  });
  it("snowflake -> presto: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(foo = 0, NULL, foo)");
  });
  it("snowflake -> spark: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("IF(foo = 0, NULL, foo)");
  });
  it("snowflake -> hive: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("IF(foo = 0, NULL, foo)");
  });
  it("snowflake -> duckdb: NULLIFZERO(foo)", () => {
    const result = transpile("NULLIFZERO(foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN foo = 0 THEN NULL ELSE foo END");
  });
  it("duckdb -> snowflake: SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", () => {
    const result = transpile("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx");
  });
  it("snowflake -> snowflake: SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", () => {
    const result = transpile("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx");
  });
  it("snowflake -> duckdb: SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", () => {
    const result = transpile("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * EXCLUDE (a, b) REPLACE (c AS d, E AS F) FROM xxx");
  });
  it.todo(`snowflake -> duckdb: SELECT PARSE_JSON('{"a": {"b c": "foo"}}'):a:"b c" (unsupported syntax)`);
  it(`snowflake -> mysql: SELECT PARSE_JSON('{"a": {"b c": "foo"}}'):a:"b c"`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"a": {"b c": "foo"}}'):a:"b c"`, { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT('{"a": {"b c": "foo"}}', '$.a."b c"')`);
  });
  it(`snowflake -> snowflake: SELECT PARSE_JSON('{"a": {"b c": "foo"}}'):a:"b c"`, () => {
    const result = transpile(`SELECT PARSE_JSON('{"a": {"b c": "foo"}}'):a:"b c"`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT GET_PATH(PARSE_JSON('{"a": {"b c": "foo"}}'), 'a["b c"]')`);
  });
  it.todo("SELECT a FROM test WHERE a = 1 GROUP BY a HAVING a = 2 QUALIFY z OR... (unsupported clause)");
  it.todo("SELECT a FROM test AS t QUALIFY ROW_NUMBER() OVER (PARTITION BY a O... (unsupported clause)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP(col, 'DD-MM-YYYY HH12:MI:SS') FROM t (cross-dialect transform)");
  it.todo("snowflake -> duckdb: SELECT TO_TIMESTAMP(col, 'DD-MM-YYYY HH12:MI:SS') FROM t (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP(col, 'DD-MM-YYYY HH12:MI:SS') FROM t", () => {
    const result = transpile("SELECT TO_TIMESTAMP(col, 'DD-MM-YYYY HH12:MI:SS') FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP(col, 'DD-mm-yyyy hh12:mi:ss') FROM t");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP(col, 'DD-MM-YYYY HH12:MI:SS') FROM t (cross-dialect transform)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP(1659981729) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP(1659981729)", () => {
    const result = transpile("SELECT TO_TIMESTAMP(1659981729)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP(1659981729)");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP(1659981729) (cross-dialect transform)");
  it.todo("snowflake -> redshift: SELECT TO_TIMESTAMP(1659981729) (unsupported syntax)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP(1659981729000, 3) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP(1659981729000, 3)", () => {
    const result = transpile("SELECT TO_TIMESTAMP(1659981729000, 3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP(1659981729000, 3)");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP(1659981729000, 3) (cross-dialect transform)");
  it.todo("snowflake -> redshift: SELECT TO_TIMESTAMP(1659981729000, 3) (unsupported syntax)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP(16599817290000, 4) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP(16599817290000, 4)", () => {
    const result = transpile("SELECT TO_TIMESTAMP(16599817290000, 4)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP(16599817290000, 4)");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP(16599817290000, 4) (cross-dialect transform)");
  it.todo("snowflake -> redshift: SELECT TO_TIMESTAMP(16599817290000, 4) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP('1659981729')", () => {
    const result = transpile("SELECT TO_TIMESTAMP('1659981729')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('1659981729')");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP('1659981729') (cross-dialect transform)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP(1659981729000000000, 9) (cross-dialect transform)");
  it.todo("snowflake -> duckdb: SELECT TO_TIMESTAMP(1659981729000000000, 9) (unsupported syntax)");
  it.todo("snowflake -> presto: SELECT TO_TIMESTAMP(1659981729000000000, 9) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP(1659981729000000000, 9)", () => {
    const result = transpile("SELECT TO_TIMESTAMP(1659981729000000000, 9)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP(1659981729000000000, 9)");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP(1659981729000000000, 9) (cross-dialect transform)");
  it.todo("snowflake -> redshift: SELECT TO_TIMESTAMP(1659981729000000000, 9) (unsupported syntax)");
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP('2013-04-05 01:02:03') (cross-dialect transform)");
  it.todo("snowflake -> snowflake: SELECT TO_TIMESTAMP('2013-04-05 01:02:03') (unsupported syntax)");
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP('2013-04-05 01:02:03') (unsupported syntax)");
  it("bigquery -> snowflake: SELECT PARSE_TIMESTAMP('%m/%d/%Y %H:%M:%S', '04/05/2013 01:02:03')", () => {
    const result = transpile("SELECT PARSE_TIMESTAMP('%m/%d/%Y %H:%M:%S', '04/05/2013 01:02:03')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')");
  });
  it("duckdb -> snowflake: SELECT STRPTIME('04/05/2013 01:02:03', '%m/%d/%Y %H:%M:%S')", () => {
    const result = transpile("SELECT STRPTIME('04/05/2013 01:02:03', '%m/%d/%Y %H:%M:%S')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')");
  });
  it.todo("snowflake -> bigquery: SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss') (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:...", () => {
    const result = transpile("SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')");
  });
  it.todo("snowflake -> spark: SELECT TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss') (cross-dialect transform)");
  it.todo("snowflake -> duckdb: TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI PM') (cross-dialect transform)");
  it("snowflake -> snowflake: TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI PM')", () => {
    const result = transpile("TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI PM')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_TIMESTAMP('2024-01-15 3:00 AM', 'yyyy-mm-DD hh12:mi pm')");
  });
  it.todo("snowflake -> duckdb: TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI AM') (cross-dialect transform)");
  it("snowflake -> snowflake: TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI AM')", () => {
    const result = transpile("TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI AM')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_TIMESTAMP('2024-01-15 3:00 PM', 'yyyy-mm-DD hh12:mi pm')");
  });
  it.todo("snowflake -> duckdb: TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI PM') (cross-dialect transform)");
  it("snowflake -> snowflake: TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI PM')", () => {
    const result = transpile("TO_TIMESTAMP('2024-01-15 3:00 PM', 'YYYY-MM-DD HH12:MI PM')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_TIMESTAMP('2024-01-15 3:00 PM', 'yyyy-mm-DD hh12:mi pm')");
  });
  it.todo("snowflake -> duckdb: TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI AM') (cross-dialect transform)");
  it("snowflake -> snowflake: TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI AM')", () => {
    const result = transpile("TO_TIMESTAMP('2024-01-15 3:00 AM', 'YYYY-MM-DD HH12:MI AM')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_TIMESTAMP('2024-01-15 3:00 AM', 'yyyy-mm-DD hh12:mi pm')");
  });
  it("snowflake -> snowflake: SELECT IFF(TRUE, 'true', 'false')", () => {
    const result = transpile("SELECT IFF(TRUE, 'true', 'false')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT IFF(TRUE, 'true', 'false')");
  });
  it("snowflake -> spark: SELECT IFF(TRUE, 'true', 'false')", () => {
    const result = transpile("SELECT IFF(TRUE, 'true', 'false')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT IF(TRUE, 'true', 'false')");
  });
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it("snowflake -> spark: SELECT ARRAY_AGG(DISTINCT a)", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT a)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT COLLECT_LIST(DISTINCT a)");
  });
  it("snowflake -> snowflake: SELECT ARRAY_AGG(DISTINCT a)", () => {
    const result = transpile("SELECT ARRAY_AGG(DISTINCT a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_AGG(DISTINCT a)");
  });
  it.todo("snowflake -> duckdb: SELECT ARRAY_AGG(DISTINCT a) (unsupported syntax)");
  it.todo("snowflake -> presto: SELECT ARRAY_AGG(DISTINCT a) (unsupported syntax)");
  it.todo("SELECT ARRAY_AGG(col) WITHIN GROUP (ORDER BY sort_col) (unsupported clause)");
  it.todo("SELECT ARRAY_AGG(DISTINCT col) WITHIN GROUP (ORDER BY col DESC) (unsupported clause)");
  it("duckdb -> snowflake: ARRAY_TO_STRING(x, '')", () => {
    const result = transpile("ARRAY_TO_STRING(x, '')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(x, '')");
  });
  it("snowflake -> spark: ARRAY_TO_STRING(x, '')", () => {
    const result = transpile("ARRAY_TO_STRING(x, '')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ARRAY_JOIN(x, '')");
  });
  it("snowflake -> snowflake: ARRAY_TO_STRING(x, '')", () => {
    const result = transpile("ARRAY_TO_STRING(x, '')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_TO_STRING(x, '')");
  });
  it("snowflake -> duckdb: ARRAY_TO_STRING(x, '')", () => {
    const result = transpile("ARRAY_TO_STRING(x, '')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_TO_STRING(x, '')");
  });
  it.todo("TO_ARRAY(x) (unsupported syntax)");
  it.todo("SELECT * FROM a INTERSECT ALL SELECT * FROM b (UnsupportedError in write)");
  it.todo("SELECT * FROM a EXCEPT ALL SELECT * FROM b (UnsupportedError in write)");
  it("snowflake -> snowflake: SELECT ARRAY_UNION_AGG(a)", () => {
    const result = transpile("SELECT ARRAY_UNION_AGG(a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_UNION_AGG(a)");
  });
  it.todo("SELECT $$a$$ (unsupported syntax)");
  it("snowflake -> hive: SELECT RLIKE(a, b)", () => {
    const result = transpile("SELECT RLIKE(a, b)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT a RLIKE b");
  });
  it("snowflake -> snowflake: SELECT RLIKE(a, b)", () => {
    const result = transpile("SELECT RLIKE(a, b)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REGEXP_LIKE(a, b)");
  });
  it("snowflake -> spark: SELECT RLIKE(a, b)", () => {
    const result = transpile("SELECT RLIKE(a, b)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT a RLIKE b");
  });
  it("snowflake -> snowflake: 'foo' REGEXP 'bar'", () => {
    const result = transpile("'foo' REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_LIKE('foo', 'bar')");
  });
  it.todo("snowflake -> postgres: 'foo' REGEXP 'bar' (unsupported syntax)");
  it("snowflake -> mysql: 'foo' REGEXP 'bar'", () => {
    const result = transpile("'foo' REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("REGEXP_LIKE('foo', 'bar')");
  });
  it("snowflake -> bigquery: 'foo' REGEXP 'bar'", () => {
    const result = transpile("'foo' REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_CONTAINS('foo', 'bar')");
  });
  it("snowflake -> snowflake: 'foo' NOT REGEXP 'bar'", () => {
    const result = transpile("'foo' NOT REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("NOT REGEXP_LIKE('foo', 'bar')");
  });
  it.todo("snowflake -> postgres: 'foo' NOT REGEXP 'bar' (unsupported syntax)");
  it("snowflake -> mysql: 'foo' NOT REGEXP 'bar'", () => {
    const result = transpile("'foo' NOT REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("NOT REGEXP_LIKE('foo', 'bar')");
  });
  it("snowflake -> bigquery: 'foo' NOT REGEXP 'bar'", () => {
    const result = transpile("'foo' NOT REGEXP 'bar'", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("NOT REGEXP_CONTAINS('foo', 'bar')");
  });
  it.todo("SELECT a FROM test pivot (unsupported clause)");
  it.todo("SELECT a FROM test unpivot (unsupported clause)");
  it("snowflake -> bigquery: trim(date_column, 'UTC')", () => {
    const result = transpile("trim(date_column, 'UTC')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TRIM(date_column, 'UTC')");
  });
  it("snowflake -> snowflake: trim(date_column, 'UTC')", () => {
    const result = transpile("trim(date_column, 'UTC')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRIM(date_column, 'UTC')");
  });
  it.todo("snowflake -> postgres: trim(date_column, 'UTC') (unsupported syntax)");
  it("snowflake -> snowflake: trim(date_column)", () => {
    const result = transpile("trim(date_column)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRIM(date_column)");
  });
  it("snowflake -> bigquery: trim(date_column)", () => {
    const result = transpile("trim(date_column)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TRIM(date_column)");
  });
  it("snowflake -> duckdb: DECODE(x, a, b, c, d, e)", () => {
    const result = transpile("DECODE(x, a, b, c, d, e)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN x = a OR (x IS NULL AND a IS NULL) THEN b WHEN x = c OR (x IS NULL AND c IS NULL) THEN d ELSE e END");
  });
  it("snowflake -> snowflake: DECODE(x, a, b, c, d, e)", () => {
    const result = transpile("DECODE(x, a, b, c, d, e)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DECODE(x, a, b, c, d, e)");
  });
  it("snowflake -> duckdb: DECODE(TRUE, a.b = 'value', 'value')", () => {
    const result = transpile("DECODE(TRUE, a.b = 'value', 'value')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN TRUE = (a.b = 'value') OR (TRUE IS NULL AND (a.b = 'value') IS NULL) THEN 'value' END");
  });
  it("snowflake -> snowflake: DECODE(TRUE, a.b = 'value', 'value')", () => {
    const result = transpile("DECODE(TRUE, a.b = 'value', 'value')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DECODE(TRUE, a.b = 'value', 'value')");
  });
  it("snowflake -> snowflake: SELECT BOOLAND(1, -2)", () => {
    const result = transpile("SELECT BOOLAND(1, -2)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BOOLAND(1, -2)");
  });
  it("snowflake -> snowflake: SELECT BOOLAND(1, -2) (2)", () => {
    const result = transpile("SELECT BOOLAND(1, -2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLAND(1, -2)");
  });
  it("snowflake -> duckdb: SELECT BOOLAND(1, -2)", () => {
    const result = transpile("SELECT BOOLAND(1, -2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ((ROUND(1, 0)) AND (ROUND(-2, 0)))");
  });
  it("snowflake -> snowflake: SELECT BOOLOR(1, 0)", () => {
    const result = transpile("SELECT BOOLOR(1, 0)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLOR(1, 0)");
  });
  it("snowflake -> duckdb: SELECT BOOLOR(1, 0)", () => {
    const result = transpile("SELECT BOOLOR(1, 0)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ((ROUND(1, 0)) OR (ROUND(0, 0)))");
  });
  it("snowflake -> snowflake: SELECT BOOLXOR(2, 0.3)", () => {
    const result = transpile("SELECT BOOLXOR(2, 0.3)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BOOLXOR(2, 0.3)");
  });
  it("snowflake -> snowflake: SELECT BOOLXOR(2, 0.3) (2)", () => {
    const result = transpile("SELECT BOOLXOR(2, 0.3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BOOLXOR(2, 0.3)");
  });
  it("snowflake -> duckdb: SELECT BOOLXOR(2, 0.3)", () => {
    const result = transpile("SELECT BOOLXOR(2, 0.3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT (ROUND(2, 0) AND (NOT ROUND(0.3, 0))) OR ((NOT ROUND(2, 0)) AND ROUND(0.3, 0))");
  });
  it("trino -> snowflake: SELECT APPROX_PERCENTILE(a, 1, 0.5, 0.001) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 1, 0.5, 0.001) FROM t", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it("presto -> snowflake: SELECT APPROX_PERCENTILE(a, 1, 0.5, 0.001) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 1, 0.5, 0.001) FROM t", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it("snowflake -> trino: SELECT APPROX_PERCENTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 0.5) FROM t", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it("snowflake -> presto: SELECT APPROX_PERCENTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 0.5) FROM t", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it("snowflake -> snowflake: SELECT APPROX_PERCENTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 0.5) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it("snowflake -> snowflake: SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRU...", () => {
    const result = transpile("SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT('key5', 'value5'), 'key1', 5), 'key2', 2.2), 'key3', 'value3')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT('key5', 'value5'), 'key1', 5), 'key2', 2.2), 'key3', 'value3')");
  });
  it.todo("snowflake -> duckdb: SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT(... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRU... (2)", () => {
    const result = transpile("SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT(), 'key1', 5), 'key2', 2.2), 'key3', 'value3')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT(), 'key1', 5), 'key2', 2.2), 'key3', 'value3')");
  });
  it.todo("snowflake -> duckdb: SELECT OBJECT_INSERT(OBJECT_INSERT(OBJECT_INSERT(OBJECT_CONSTRUCT(... (2) (unsupported syntax)");
  it.todo("SELECT ARRAY_CONSTRUCT('foo')::VARIANT[0] (unsupported syntax)");
  it("snowflake -> snowflake: SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:0...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> spark: SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> databricks: SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> redshift: SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> snowflake: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_Yor...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> spark: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', ...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> databricks: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_Yo...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> redshift: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')");
  });
  it("snowflake -> mysql: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', ...", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York', '2024-08-06 09:10:00.000')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT CONVERT_TZ('2024-08-06 09:10:00.000', 'America/Los_Angeles', 'America/New_York')");
  });
  it.todo("snowflake -> duckdb: SELECT CONVERT_TIMEZONE('America/Los_Angeles', 'America/New_York',... (unsupported syntax)");
  it("SELECT UUID_STRING(), UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    validateIdentity("SELECT UUID_STRING(), UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')");
  });
  it("snowflake -> snowflake: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')");
  });
  it("snowflake -> hive: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> spark2: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> spark: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> databricks: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> duckdb: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> presto: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> trino: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("UUID()");
  });
  it("snowflake -> postgres: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("GEN_RANDOM_UUID()");
  });
  it("snowflake -> bigquery: UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", () => {
    const result = transpile("UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d', 'foo')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("GENERATE_UUID()");
  });
  it.todo("TRY_TO_TIMESTAMP(foo) (assert_is check)");
  it.todo("TRY_TO_TIMESTAMP('12345') (assert_is check)");
  it("snowflake -> snowflake: SELECT TRY_TO_TIMESTAMP('2024-01-15 12:30:00.000')", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('2024-01-15 12:30:00.000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_CAST('2024-01-15 12:30:00.000' AS TIMESTAMP)");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIMESTAMP('2024-01-15 12:30:00.000')", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('2024-01-15 12:30:00.000')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TRY_CAST('2024-01-15 12:30:00.000' AS TIMESTAMP)");
  });
  it("snowflake -> snowflake: SELECT TRY_TO_TIMESTAMP('invalid')", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('invalid')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_CAST('invalid' AS TIMESTAMP)");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIMESTAMP('invalid')", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('invalid')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TRY_CAST('invalid' AS TIMESTAMP)");
  });
  it("snowflake -> snowflake: SELECT TRY_TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24...", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi...", () => {
    const result = transpile("SELECT TRY_TO_TIMESTAMP('04/05/2013 01:02:03', 'mm/DD/yyyy hh24:mi:ss')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(TRY_STRPTIME('04/05/2013 01:02:03', '%m/%d/%Y %H:%M:%S') AS TIMESTAMP)");
  });
  it("snowflake -> duckdb: EDITDISTANCE(col1, col2)", () => {
    const result = transpile("EDITDISTANCE(col1, col2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LEVENSHTEIN(col1, col2)");
  });
  it("snowflake -> snowflake: EDITDISTANCE(col1, col2)", () => {
    const result = transpile("EDITDISTANCE(col1, col2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("EDITDISTANCE(col1, col2)");
  });
  it("snowflake -> bigquery: EDITDISTANCE(col1, col2, 3)", () => {
    const result = transpile("EDITDISTANCE(col1, col2, 3)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("EDIT_DISTANCE(col1, col2, max_distance => 3)");
  });
  it("snowflake -> duckdb: EDITDISTANCE(col1, col2, 3)", () => {
    const result = transpile("EDITDISTANCE(col1, col2, 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN LEVENSHTEIN(col1, col2) IS NULL OR 3 IS NULL THEN NULL ELSE LEAST(LEVENSHTEIN(col1, col2), 3) END");
  });
  it("snowflake -> postgres: EDITDISTANCE(col1, col2, 3)", () => {
    const result = transpile("EDITDISTANCE(col1, col2, 3)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("LEVENSHTEIN_LESS_EQUAL(col1, col2, 3)");
  });
  it("snowflake -> snowflake: EDITDISTANCE(col1, col2, 3)", () => {
    const result = transpile("EDITDISTANCE(col1, col2, 3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("EDITDISTANCE(col1, col2, 3)");
  });
  it("MINHASH(100, col1)", () => {
    validateIdentity("MINHASH(100, col1)");
  });
  it("MINHASH(100, col1, col2)", () => {
    validateIdentity("MINHASH(100, col1, col2)");
  });
  it.todo("snowflake -> duckdb: MINHASH(4, col1) (unsupported syntax)");
  it("snowflake -> snowflake: MINHASH(4, col1)", () => {
    const result = transpile("MINHASH(4, col1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("MINHASH(4, col1)");
  });
  it("MINHASH_COMBINE(sig_col)", () => {
    validateIdentity("MINHASH_COMBINE(sig_col)");
  });
  it.todo("snowflake -> duckdb: MINHASH_COMBINE(sig_col) (unsupported clause)");
  it("snowflake -> snowflake: MINHASH_COMBINE(sig_col)", () => {
    const result = transpile("MINHASH_COMBINE(sig_col)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("MINHASH_COMBINE(sig_col)");
  });
  it("APPROXIMATE_SIMILARITY(sig_col)", () => {
    validateIdentity("APPROXIMATE_SIMILARITY(sig_col)");
  });
  it.todo("snowflake -> duckdb: APPROXIMATE_SIMILARITY(sig_col) (unsupported clause)");
  it("snowflake -> snowflake: APPROXIMATE_SIMILARITY(sig_col)", () => {
    const result = transpile("APPROXIMATE_SIMILARITY(sig_col)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("APPROXIMATE_SIMILARITY(sig_col)");
  });
  it("SELECT BITNOT(a)", () => {
    validateIdentity("SELECT BITNOT(a)");
  });
  it("SELECT BIT_NOT(a) -> SELECT BITNOT(a)", () => {
    validateIdentity("SELECT BIT_NOT(a)", "SELECT BITNOT(a)");
  });
  it("snowflake -> duckdb: SELECT BITNOT(-1)", () => {
    const result = transpile("SELECT BITNOT(-1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ~(-1)");
  });
  it("snowflake -> snowflake: SELECT BITNOT(-1)", () => {
    const result = transpile("SELECT BITNOT(-1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITNOT(-1)");
  });
  it("SELECT BITAND(a, b)", () => {
    validateIdentity("SELECT BITAND(a, b)");
  });
  it("SELECT BITAND(a, b, 'LEFT')", () => {
    validateIdentity("SELECT BITAND(a, b, 'LEFT')");
  });
  it("SELECT BIT_AND(a, b) -> SELECT BITAND(a, b)", () => {
    validateIdentity("SELECT BIT_AND(a, b)", "SELECT BITAND(a, b)");
  });
  it("SELECT BIT_AND(a, b, 'LEFT') -> SELECT BITAND(a, b, 'LEFT')", () => {
    validateIdentity("SELECT BIT_AND(a, b, 'LEFT')", "SELECT BITAND(a, b, 'LEFT')");
  });
  it("SELECT BITOR(a, b)", () => {
    validateIdentity("SELECT BITOR(a, b)");
  });
  it("SELECT BITOR(a, b, 'LEFT')", () => {
    validateIdentity("SELECT BITOR(a, b, 'LEFT')");
  });
  it("SELECT BIT_OR(a, b) -> SELECT BITOR(a, b)", () => {
    validateIdentity("SELECT BIT_OR(a, b)", "SELECT BITOR(a, b)");
  });
  it("SELECT BIT_OR(a, b, 'RIGHT') -> SELECT BITOR(a, b, 'RIGHT')", () => {
    validateIdentity("SELECT BIT_OR(a, b, 'RIGHT')", "SELECT BITOR(a, b, 'RIGHT')");
  });
  it("SELECT BITXOR(a, b)", () => {
    validateIdentity("SELECT BITXOR(a, b)");
  });
  it("SELECT BITXOR(a, b, 'LEFT')", () => {
    validateIdentity("SELECT BITXOR(a, b, 'LEFT')");
  });
  it("SELECT BIT_XOR(a, b) -> SELECT BITXOR(a, b)", () => {
    validateIdentity("SELECT BIT_XOR(a, b)", "SELECT BITXOR(a, b)");
  });
  it("SELECT BIT_XOR(a, b, 'LEFT') -> SELECT BITXOR(a, b, 'LEFT')", () => {
    validateIdentity("SELECT BIT_XOR(a, b, 'LEFT')", "SELECT BITXOR(a, b, 'LEFT')");
  });
  it("snowflake -> duckdb: SELECT BITOR(BITSHIFTLEFT(5, 16), BITSHIFTLEFT(3, 8))", () => {
    const result = transpile("SELECT BITOR(BITSHIFTLEFT(5, 16), BITSHIFTLEFT(3, 8))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT (CAST(5 AS INT128) << 16) | (CAST(3 AS INT128) << 8)");
  });
  it("snowflake -> snowflake: SELECT BITAND(BITSHIFTLEFT(255, 4), BITSHIFTLEFT(15, 2))", () => {
    const result = transpile("SELECT BITAND(BITSHIFTLEFT(255, 4), BITSHIFTLEFT(15, 2))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITAND(BITSHIFTLEFT(255, 4), BITSHIFTLEFT(15, 2))");
  });
  it("snowflake -> duckdb: SELECT BITAND(BITSHIFTLEFT(255, 4), BITSHIFTLEFT(15, 2))", () => {
    const result = transpile("SELECT BITAND(BITSHIFTLEFT(255, 4), BITSHIFTLEFT(15, 2))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT (CAST(255 AS INT128) << 4) & (CAST(15 AS INT128) << 2)");
  });
  it("snowflake -> snowflake: SELECT BITSHIFTLEFT(255, 4)", () => {
    const result = transpile("SELECT BITSHIFTLEFT(255, 4)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITSHIFTLEFT(255, 4)");
  });
  it("snowflake -> duckdb: SELECT BITSHIFTLEFT(255, 4)", () => {
    const result = transpile("SELECT BITSHIFTLEFT(255, 4)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(255 AS INT128) << 4");
  });
  it("snowflake -> snowflake: SELECT BITSHIFTRIGHT(255, 4)", () => {
    const result = transpile("SELECT BITSHIFTRIGHT(255, 4)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITSHIFTRIGHT(255, 4)");
  });
  it("snowflake -> duckdb: SELECT BITSHIFTRIGHT(255, 4)", () => {
    const result = transpile("SELECT BITSHIFTRIGHT(255, 4)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(255 AS INT128) >> 4");
  });
  it.todo("SELECT BITSHIFTLEFT(X'002A'::BINARY, 1) (unsupported syntax)");
  it.todo("SELECT BITSHIFTRIGHT(X'002A'::BINARY, 1) (unsupported syntax)");
  it("bigquery -> snowflake: BYTE_LENGTH('A')", () => {
    const result = transpile("BYTE_LENGTH('A')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("OCTET_LENGTH('A')");
  });
  it("snowflake -> snowflake: OCTET_LENGTH('A')", () => {
    const result = transpile("OCTET_LENGTH('A')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("OCTET_LENGTH('A')");
  });
  it.todo("CREATE TABLE t (id INT PRIMARY KEY AUTOINCREMENT) (DDL/DML not supported)");
  it("snowflake -> bigquery: SELECT HEX_DECODE_BINARY('65')", () => {
    const result = transpile("SELECT HEX_DECODE_BINARY('65')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT FROM_HEX('65')");
  });
  it("snowflake -> duckdb: SELECT HEX_DECODE_BINARY('65')", () => {
    const result = transpile("SELECT HEX_DECODE_BINARY('65')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT UNHEX('65')");
  });
  it("snowflake -> snowflake: SELECT HEX_DECODE_BINARY('65')", () => {
    const result = transpile("SELECT HEX_DECODE_BINARY('65')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT HEX_DECODE_BINARY('65')");
  });
  it("snowflake -> snowflake: DAYOFWEEKISO(foo)", () => {
    const result = transpile("DAYOFWEEKISO(foo)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFWEEKISO(foo)");
  });
  it("presto -> snowflake: DAY_OF_WEEK(foo)", () => {
    const result = transpile("DAY_OF_WEEK(foo)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFWEEKISO(foo)");
  });
  it("trino -> snowflake: DAY_OF_WEEK(foo)", () => {
    const result = transpile("DAY_OF_WEEK(foo)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFWEEKISO(foo)");
  });
  it("snowflake -> duckdb: DAYOFWEEKISO(foo)", () => {
    const result = transpile("DAYOFWEEKISO(foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ISODOW(foo)");
  });
  it("presto -> snowflake: DOW(foo)", () => {
    const result = transpile("DOW(foo)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFWEEKISO(foo)");
  });
  it("trino -> snowflake: DOW(foo)", () => {
    const result = transpile("DOW(foo)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFWEEKISO(foo)");
  });
  it("presto -> snowflake: DOY(foo)", () => {
    const result = transpile("DOY(foo)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFYEAR(foo)");
  });
  it("trino -> snowflake: DOY(foo)", () => {
    const result = transpile("DOY(foo)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("DAYOFYEAR(foo)");
  });
  it("snowflake -> snowflake: DAYOFYEAR(foo)", () => {
    const result = transpile("DAYOFYEAR(foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DAYOFYEAR(foo)");
  });
  it("TO_JSON(OBJECT_CONSTRUCT('name', 'Alice'))", () => {
    validateIdentity("TO_JSON(OBJECT_CONSTRUCT('name', 'Alice'))");
  });
  it("bigquery -> snowflake: SELECT CAST(1 AS BIGDECIMAL), CAST(1 AS BIGNUMERIC)", () => {
    const result = transpile("SELECT CAST(1 AS BIGDECIMAL), CAST(1 AS BIGNUMERIC)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST(1 AS DOUBLE), CAST(1 AS DOUBLE)");
  });
  it("snowflake -> snowflake: SELECT CAST(1 AS DOUBLE), CAST(1 AS DOUBLE)", () => {
    const result = transpile("SELECT CAST(1 AS DOUBLE), CAST(1 AS DOUBLE)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST(1 AS DOUBLE), CAST(1 AS DOUBLE)");
  });
  it("bigquery -> snowflake: SELECT EXTRACT(ISOWEEK FROM CAST('2013-12-25' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(ISOWEEK FROM CAST('2013-12-25' AS DATE))", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(WEEKISO, CAST('2013-12-25' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2013-12-25' AS DATE), '%V') AS INT)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2026-01-06' AS DATE), '%G') AS INT)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2026-01-06' AS DATE), '%G') AS INT)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(NANOSECOND, CAST('2026-01-06 11:45:00.12345678...", () => {
    const result = transpile("SELECT DATE_PART(NANOSECOND, CAST('2026-01-06 11:45:00.123456789' AS TIMESTAMPNTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(NANOSECOND, CAST('2026-01-06 11:45:00.123456789' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT DATE_PART(NANOSECOND, CAST('2026-01-06 11:45:00.123456789' ... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(YEAR FROM CAST('2026-01-06 11:45:00' AS TIMESTAM...", () => {
    const result = transpile("SELECT EXTRACT(YEAR FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAR, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(YEAR FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_N... (unsupported syntax)");
  it.todo("SELECT EXTRACT(QUARTER FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(MONTH FROM CAST('2026-01-06 11:45:00' AS TIMESTA...", () => {
    const result = transpile("SELECT EXTRACT(MONTH FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(MONTH, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(MONTH FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(WEEK FROM CAST('2026-01-06 11:45:00' AS TIMESTAM...", () => {
    const result = transpile("SELECT EXTRACT(WEEK FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(WEEK, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(WEEK FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_N... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06 11:45:00' AS TIMES...", () => {
    const result = transpile("SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(WEEKISO, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06 11:45:00' AS TIMESTAM... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(DAY FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP...", () => {
    const result = transpile("SELECT EXTRACT(DAY FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAY, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(DAY FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ)) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06 11:45:00' AS TI...", () => {
    const result = transpile("SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAY, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06 11:45:00' AS TIMES... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06 11:45:00' AS TIM...", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEK, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06 11:45:00' AS TIMEST... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06 11:45:00' AS ...", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEKISO, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06 11:45:00' AS TIM... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06 11:45:00' AS TIM...", () => {
    const result = transpile("SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFYEAR, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06 11:45:00' AS TIMEST... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06 11:45:00' AS TI...", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06 11:45:00' AS TIMES... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06 11:45:00' AS...", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06 11:45:00' AS TI... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(HOUR FROM CAST('2026-01-06 11:45:00' AS TIMESTAM...", () => {
    const result = transpile("SELECT EXTRACT(HOUR FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(HOUR, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(HOUR FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_N... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(MINUTE FROM CAST('2026-01-06 11:45:00' AS TIMEST...", () => {
    const result = transpile("SELECT EXTRACT(MINUTE FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(MINUTE, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(MINUTE FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(SECOND FROM CAST('2026-01-06 11:45:00' AS TIMEST...", () => {
    const result = transpile("SELECT EXTRACT(SECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(SECOND, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(SECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(NANOSECOND FROM CAST('2026-01-06 11:45:00.123456...", () => {
    const result = transpile("SELECT EXTRACT(NANOSECOND FROM CAST('2026-01-06 11:45:00.123456789' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(NANOSECOND, CAST('2026-01-06 11:45:00.123456789' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(NANOSECOND FROM CAST('2026-01-06 11:45:00.123456789... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(EPOCH_SECOND FROM CAST('2026-01-06 11:45:00' AS ...", () => {
    const result = transpile("SELECT EXTRACT(EPOCH_SECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_SECOND, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(EPOCH_SECOND FROM CAST('2026-01-06 11:45:00' AS TIM... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(EPOCH_MILLISECOND FROM CAST('2026-01-06 11:45:00...", () => {
    const result = transpile("SELECT EXTRACT(EPOCH_MILLISECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_MILLISECOND, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(EPOCH_MILLISECOND FROM CAST('2026-01-06 11:45:00' A... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(EPOCH_MICROSECOND FROM CAST('2026-01-06 11:45:00...", () => {
    const result = transpile("SELECT EXTRACT(EPOCH_MICROSECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_MICROSECOND, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(EPOCH_MICROSECOND FROM CAST('2026-01-06 11:45:00' A... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(EPOCH_NANOSECOND FROM CAST('2026-01-06 11:45:00'...", () => {
    const result = transpile("SELECT EXTRACT(EPOCH_NANOSECOND FROM CAST('2026-01-06 11:45:00' AS TIMESTAMP_NTZ))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_NANOSECOND, CAST('2026-01-06 11:45:00' AS TIMESTAMPNTZ))");
  });
  it.todo("snowflake -> duckdb: SELECT EXTRACT(EPOCH_NANOSECOND FROM CAST('2026-01-06 11:45:00' AS... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(YEAR FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAR FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAR, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(YEAR FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAR FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(YEAR FROM CAST('2026-01-06' AS DATE))");
  });
  it.todo("SELECT EXTRACT(QUARTER FROM CAST('2026-01-06' AS DATE)) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT(MONTH FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(MONTH FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(MONTH, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(MONTH FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(MONTH FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(MONTH FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(WEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(WEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(WEEK, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(WEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(WEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(WEEK FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(WEEKISO, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(WEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2026-01-06' AS DATE), '%V') AS INT)");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAY, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAY, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFMONTH FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(DAY FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEK, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(DAYOFWEEK FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEKISO, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFWEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(ISODOW FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFYEAR, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(DAYOFYEAR FROM CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEK, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEK FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2026-01-06' AS DATE), '%G') AS INT)");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(YEAROFWEEKISO, CAST('2026-01-06' AS DATE))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06' AS DATE))", () => {
    const result = transpile("SELECT EXTRACT(YEAROFWEEKISO FROM CAST('2026-01-06' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRFTIME(CAST('2026-01-06' AS DATE), '%G') AS INT)");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(HOUR FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(HOUR FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(HOUR, CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(HOUR FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(HOUR FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(HOUR FROM CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(MINUTE FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(MINUTE FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(MINUTE, CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(MINUTE FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(MINUTE FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(MINUTE FROM CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> snowflake: SELECT EXTRACT(SECOND FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(SECOND FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(SECOND, CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> duckdb: SELECT EXTRACT(SECOND FROM CAST('11:45:00.123456789' AS TIME))", () => {
    const result = transpile("SELECT EXTRACT(SECOND FROM CAST('11:45:00.123456789' AS TIME))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(SECOND FROM CAST('11:45:00.123456789' AS TIME))");
  });
  it("snowflake -> snowflake: SELECT ST_MAKEPOINT(10, 20)", () => {
    const result = transpile("SELECT ST_MAKEPOINT(10, 20)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ST_MAKEPOINT(10, 20)");
  });
  it("snowflake -> starrocks: SELECT ST_MAKEPOINT(10, 20)", () => {
    const result = transpile("SELECT ST_MAKEPOINT(10, 20)", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT ST_POINT(10, 20)");
  });
  it("snowflake -> snowflake: LAST_DAY(CAST('2023-04-15' AS DATE))", () => {
    const result = transpile("LAST_DAY(CAST('2023-04-15' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LAST_DAY(CAST('2023-04-15' AS DATE))");
  });
  it("snowflake -> duckdb: LAST_DAY(CAST('2023-04-15' AS DATE))", () => {
    const result = transpile("LAST_DAY(CAST('2023-04-15' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LAST_DAY(CAST('2023-04-15' AS DATE))");
  });
  it("snowflake -> snowflake: LAST_DAY(CAST('2023-04-15' AS DATE), MONTH)", () => {
    const result = transpile("LAST_DAY(CAST('2023-04-15' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LAST_DAY(CAST('2023-04-15' AS DATE), MONTH)");
  });
  it("snowflake -> duckdb: LAST_DAY(CAST('2023-04-15' AS DATE), MONTH)", () => {
    const result = transpile("LAST_DAY(CAST('2023-04-15' AS DATE), MONTH)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LAST_DAY(CAST('2023-04-15' AS DATE))");
  });
  it("snowflake -> snowflake: LAST_DAY(CAST('2024-06-15' AS DATE), YEAR)", () => {
    const result = transpile("LAST_DAY(CAST('2024-06-15' AS DATE), YEAR)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LAST_DAY(CAST('2024-06-15' AS DATE), YEAR)");
  });
  it("snowflake -> duckdb: LAST_DAY(CAST('2024-06-15' AS DATE), YEAR)", () => {
    const result = transpile("LAST_DAY(CAST('2024-06-15' AS DATE), YEAR)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MAKE_DATE(EXTRACT(YEAR FROM CAST('2024-06-15' AS DATE)), 12, 31)");
  });
  it("snowflake -> snowflake: LAST_DAY(CAST('2024-01-15' AS DATE), QUARTER)", () => {
    const result = transpile("LAST_DAY(CAST('2024-01-15' AS DATE), QUARTER)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LAST_DAY(CAST('2024-01-15' AS DATE), QUARTER)");
  });
  it.todo("snowflake -> duckdb: LAST_DAY(CAST('2024-01-15' AS DATE), QUARTER) (unsupported syntax)");
  it("snowflake -> snowflake: LAST_DAY(CAST('2025-12-15' AS DATE), WEEK)", () => {
    const result = transpile("LAST_DAY(CAST('2025-12-15' AS DATE), WEEK)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LAST_DAY(CAST('2025-12-15' AS DATE), WEEK)");
  });
  it("snowflake -> duckdb: LAST_DAY(CAST('2025-12-15' AS DATE), WEEK)", () => {
    const result = transpile("LAST_DAY(CAST('2025-12-15' AS DATE), WEEK)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(CAST('2025-12-15' AS DATE) + INTERVAL ((7 - EXTRACT(DAYOFWEEK FROM CAST('2025-12-15' AS DATE))) % 7) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT ST_DISTANCE(a, b)", () => {
    const result = transpile("SELECT ST_DISTANCE(a, b)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ST_DISTANCE(a, b)");
  });
  it("snowflake -> starrocks: SELECT ST_DISTANCE(a, b)", () => {
    const result = transpile("SELECT ST_DISTANCE(a, b)", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT ST_DISTANCE_SPHERE(ST_X(a), ST_Y(a), ST_X(b), ST_Y(b))");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(WEEKDAY_ISO, foo)", () => {
    const result = transpile("SELECT DATE_PART(WEEKDAY_ISO, foo)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEKISO, foo)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(DAYOFWEEKISO, foo)", () => {
    const result = transpile("SELECT DATE_PART(DAYOFWEEKISO, foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEKISO, foo)");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(DAYOFWEEKISO, foo)", () => {
    const result = transpile("SELECT DATE_PART(DAYOFWEEKISO, foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(ISODOW FROM foo)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART(DAYOFWEEK_ISO, foo)", () => {
    const result = transpile("SELECT DATE_PART(DAYOFWEEK_ISO, foo)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(DAYOFWEEKISO, foo)");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(DAYOFWEEK_ISO, foo)", () => {
    const result = transpile("SELECT DATE_PART(DAYOFWEEK_ISO, foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EXTRACT(ISODOW FROM foo)");
  });
  it.todo("ALTER TABLE foo ADD col1 VARCHAR(512), col2 VARCHAR(512) (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD col1 VARCHAR NOT NULL TAG (key1='value_1'), col... (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD IF NOT EXISTS col1 INT, col2 INT (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD IF NOT EXISTS col1 INT, IF NOT EXISTS col2 INT (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD col1 INT, IF NOT EXISTS col2 INT (DDL/DML not supported)");
  it.todo("ALTER TABLE IF EXISTS foo ADD IF NOT EXISTS col1 INT (DDL/DML not supported)");
  it.todo("snowflake -> duckdb: SELECT ADD_MONTHS('2023-01-31', 1) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ADD_MONTHS('2023-01-31', 1)", () => {
    const result = transpile("SELECT ADD_MONTHS('2023-01-31', 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ADD_MONTHS('2023-01-31', 1)");
  });
  it.todo("SELECT ADD_MONTHS('2023-01-31'::date, 1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2023-01-31'::timestamptz, 1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, 2.7) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, -2.3) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, 3.2::DECIMAL(10,2)) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-02-29'::DATE, 1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-31'::DATE, 1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-31'::DATE, -1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, 1) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS(NULL::DATE, 2) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, NULL) (unsupported syntax)");
  it.todo("SELECT ADD_MONTHS('2016-05-15'::DATE, 0) (unsupported syntax)");
  it("SELECT HOUR(CAST('08:50:57' AS TIME))", () => {
    validateIdentity("SELECT HOUR(CAST('08:50:57' AS TIME))");
  });
  it("SELECT MINUTE(CAST('08:50:57' AS TIME))", () => {
    validateIdentity("SELECT MINUTE(CAST('08:50:57' AS TIME))");
  });
  it("SELECT SECOND(CAST('08:50:57' AS TIME))", () => {
    validateIdentity("SELECT SECOND(CAST('08:50:57' AS TIME))");
  });
  it.todo("SELECT HOUR(CAST('2024-05-09 08:50:57' AS TIMESTAMP)) (unsupported syntax)");
  it.todo("SELECT MONTHNAME(CAST('2024-05-09' AS DATE)) (unsupported syntax)");
  it.todo("snowflake -> duckdb: SELECT DAYNAME(TO_DATE('2025-01-15')) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT DAYNAME(TO_DATE('2025-01-15'))", () => {
    const result = transpile("SELECT DAYNAME(TO_DATE('2025-01-15'))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DAYNAME(CAST('2025-01-15' AS DATE))");
  });
  it.todo("snowflake -> duckdb: SELECT DAYNAME(TO_TIMESTAMP('2025-02-28 10:30:45')) (unsupported syntax)");
  it.todo("snowflake -> snowflake: SELECT DAYNAME(TO_TIMESTAMP('2025-02-28 10:30:45')) (unsupported syntax)");
  it.todo("SELECT MONTHNAME(TO_DATE('2025-01-15')) (unsupported syntax)");
  it.todo("SELECT MONTHNAME(TO_TIMESTAMP('2025-02-28 10:30:45')) (unsupported syntax)");
  it("SELECT PREVIOUS_DAY(CAST('2024-05-09' AS DATE), 'MONDAY')", () => {
    validateIdentity("SELECT PREVIOUS_DAY(CAST('2024-05-09' AS DATE), 'MONDAY')");
  });
  it("SELECT TIME_FROM_PARTS(14, 30, 45)", () => {
    validateIdentity("SELECT TIME_FROM_PARTS(14, 30, 45)");
  });
  it("SELECT TIME_FROM_PARTS(14, 30, 45, 123)", () => {
    validateIdentity("SELECT TIME_FROM_PARTS(14, 30, 45, 123)");
  });
  it("SELECT MONTHS_BETWEEN(CAST('2019-03-15' AS DATE), CAST('2019-02-15' AS DATE))", () => {
    validateIdentity("SELECT MONTHS_BETWEEN(CAST('2019-03-15' AS DATE), CAST('2019-02-15' AS DATE))");
  });
  it.todo("SELECT MONTHS_BETWEEN(CAST('2019-03-01 02:00:00' AS TIMESTAMP), CAS... (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(CAST('2024-05-09 08:50:57.891' AS TIMESTAMP), 15,... (unsupported syntax)");
  it("SELECT TIME_SLICE(CAST('2024-05-09' AS DATE), 1, 'DAY')", () => {
    validateIdentity("SELECT TIME_SLICE(CAST('2024-05-09' AS DATE), 1, 'DAY')");
  });
  it.todo("SELECT TIME_SLICE(CAST('2024-05-09 08:50:57.891' AS TIMESTAMP), 1, ... (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(TIMESTAMP '2024-03-15 14:37:42', 1, 'HOUR') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(TIMESTAMP '2024-03-15 14:37:42', 1, 'HOUR', 'END') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(DATE '2024-03-15', 1, 'DAY') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(DATE '2024-03-15', 1, 'DAY', 'END') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(TIMESTAMP '2024-03-15 14:37:42', 15, 'MINUTE') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(TIMESTAMP '2024-03-15 14:37:42', 1, 'QUARTER') (unsupported syntax)");
  it.todo("SELECT TIME_SLICE(DATE '2024-03-15', 1, 'WEEK', 'END') (unsupported syntax)");
  it("snowflake -> snowflake: SELECT * FROM t1 FULL OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 FULL OUTER JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 FULL OUTER JOIN t2");
  });
  it.todo("snowflake -> duckdb: SELECT * FROM t1 FULL OUTER JOIN t2 (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2");
  });
  it("snowflake -> duckdb: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1, t2");
  });
  it("snowflake -> snowflake: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2");
  });
  it("snowflake -> duckdb: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1, t2");
  });
  it("snowflake -> snowflake: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2");
  });
  it("snowflake -> duckdb: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1, t2");
  });
  it("snowflake -> snowflake: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2");
  });
  it("snowflake -> duckdb: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1, t2");
  });
  it("snowflake -> snowflake: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2");
  });
  it("snowflake -> duckdb: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1, t2");
  });
  it("SELECT * EXCLUDE foo RENAME bar AS baz FROM tbl -> SELECT * EXCLUDE (foo) RENAME (bar A...", () => {
    validateIdentity("SELECT * EXCLUDE foo RENAME bar AS baz FROM tbl", "SELECT * EXCLUDE (foo) RENAME (bar AS baz) FROM tbl");
  });
  it.todo("bigquery -> snowflake: WITH foo AS (SELECT [1] AS arr_1) SELECT (SELECT unnested_arr FR... (cross-dialect transform)");
  it.todo("SELECT LIKE(col, 'pattern') (unsupported syntax)");
  it.todo("SELECT ILIKE(col, 'pattern') (unsupported syntax)");
  it.todo("SELECT LIKE(col, 'pattern', '\\\\') (unsupported syntax)");
  it.todo("SELECT ILIKE(col, 'pattern', '\\\\') (unsupported syntax)");
  it.todo("SELECT LIKE(col, 'pattern', '!') (unsupported syntax)");
  it.todo("SELECT ILIKE(col, 'pattern', '!') (unsupported syntax)");
  it.todo("test_snowflake: assertEqual call (4)");
  it("snowflake -> duckdb: SELECT BASE64_ENCODE(x)", () => {
    const result = transpile("SELECT BASE64_ENCODE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TO_BASE64(x)");
  });
  it("snowflake -> snowflake: SELECT BASE64_ENCODE(x)", () => {
    const result = transpile("SELECT BASE64_ENCODE(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_ENCODE(x)");
  });
  it.todo("snowflake -> duckdb: SELECT BASE64_ENCODE(x, 76) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT BASE64_ENCODE(x, 76)", () => {
    const result = transpile("SELECT BASE64_ENCODE(x, 76)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_ENCODE(x, 76)");
  });
  it.todo("snowflake -> duckdb: SELECT BASE64_ENCODE(x, 76, '+/=') (unsupported syntax)");
  it("snowflake -> snowflake: SELECT BASE64_ENCODE(x, 76, '+/=')", () => {
    const result = transpile("SELECT BASE64_ENCODE(x, 76, '+/=')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_ENCODE(x, 76, '+/=')");
  });
  it("snowflake -> snowflake: SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl')", () => {
    const result = transpile("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl')");
  });
  it("snowflake -> duckdb: SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl')", () => {
    const result = transpile("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT DECODE(FROM_BASE64('U25vd2ZsYWtl'))");
  });
  it("snowflake -> snowflake: SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl', '-_+')", () => {
    const result = transpile("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl', '-_+')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl', '-_+')");
  });
  it("snowflake -> duckdb: SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl', '-_+')", () => {
    const result = transpile("SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl', '-_+')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT DECODE(FROM_BASE64(REPLACE(REPLACE(REPLACE('U25vd2ZsYWtl', '-', '+'), '_', '/'), '+', '=')))");
  });
  it("snowflake -> snowflake: SELECT BASE64_DECODE_BINARY(x)", () => {
    const result = transpile("SELECT BASE64_DECODE_BINARY(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_DECODE_BINARY(x)");
  });
  it("snowflake -> duckdb: SELECT BASE64_DECODE_BINARY(x)", () => {
    const result = transpile("SELECT BASE64_DECODE_BINARY(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT FROM_BASE64(x)");
  });
  it("snowflake -> snowflake: SELECT BASE64_DECODE_BINARY(x, '-_+')", () => {
    const result = transpile("SELECT BASE64_DECODE_BINARY(x, '-_+')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BASE64_DECODE_BINARY(x, '-_+')");
  });
  it("snowflake -> duckdb: SELECT BASE64_DECODE_BINARY(x, '-_+')", () => {
    const result = transpile("SELECT BASE64_DECODE_BINARY(x, '-_+')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT FROM_BASE64(REPLACE(REPLACE(REPLACE(x, '-', '+'), '_', '/'), '+', '='))");
  });
  it("SELECT TRY_HEX_DECODE_BINARY('48656C6C6F')", () => {
    validateIdentity("SELECT TRY_HEX_DECODE_BINARY('48656C6C6F')");
  });
  it("SELECT TRY_HEX_DECODE_STRING('48656C6C6F')", () => {
    validateIdentity("SELECT TRY_HEX_DECODE_STRING('48656C6C6F')");
  });
  it.todo("presto -> snowflake: SELECT CONTAINS(ARRAY['1'], '1') (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ARRAY_CONTAINS(CAST('1' AS VARIANT), ['1'])", () => {
    const result = transpile("SELECT ARRAY_CONTAINS(CAST('1' AS VARIANT), ['1'])", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ARRAY_CONTAINS(CAST('1' AS VARIANT), ['1'])");
  });
  it.todo("presto -> snowflake: SELECT CONTAINS(ARRAY[DATE '2020-10-10'], DATE '2020-10-10') (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ARRAY_CONTAINS(CAST(CAST('2020-10-10' AS DATE) AS VARIAN...", () => {
    const result = transpile("SELECT ARRAY_CONTAINS(CAST(CAST('2020-10-10' AS DATE) AS VARIANT), [CAST('2020-10-10' AS DATE)])", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ARRAY_CONTAINS(CAST(CAST('2020-10-10' AS DATE) AS VARIANT), [CAST('2020-10-10' AS DATE)])");
  });
  it("SELECT ARRAY_CONTAINS(1, [1])", () => {
    validateIdentity("SELECT ARRAY_CONTAINS(1, [1])");
  });
  it.todo("SELECT x'ABCD' (unsupported syntax)");
  it.todo("SET a = 1 (command not supported)");
  it("snowflake -> snowflake: CAST(6.43 AS FLOAT)", () => {
    const result = transpile("CAST(6.43 AS FLOAT)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CAST(6.43 AS DOUBLE)");
  });
  it("snowflake -> duckdb: CAST(6.43 AS FLOAT)", () => {
    const result = transpile("CAST(6.43 AS FLOAT)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(6.43 AS DOUBLE)");
  });
  it("snowflake -> snowflake: UNIFORM(1, 10, RANDOM(5))", () => {
    const result = transpile("UNIFORM(1, 10, RANDOM(5))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("UNIFORM(1, 10, RANDOM(5))");
  });
  it.todo("snowflake -> databricks: UNIFORM(1, 10, RANDOM(5)) (cross-dialect transform)");
  it.todo("snowflake -> duckdb: UNIFORM(1, 10, RANDOM(5)) (cross-dialect transform)");
  it("snowflake -> snowflake: UNIFORM(1, 10, RANDOM())", () => {
    const result = transpile("UNIFORM(1, 10, RANDOM())", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("UNIFORM(1, 10, RANDOM())");
  });
  it.todo("snowflake -> databricks: UNIFORM(1, 10, RANDOM()) (cross-dialect transform)");
  it.todo("snowflake -> duckdb: UNIFORM(1, 10, RANDOM()) (cross-dialect transform)");
  it("snowflake -> snowflake: UNIFORM(1, 10, 5)", () => {
    const result = transpile("UNIFORM(1, 10, 5)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("UNIFORM(1, 10, 5)");
  });
  it("snowflake -> databricks: UNIFORM(1, 10, 5)", () => {
    const result = transpile("UNIFORM(1, 10, 5)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("UNIFORM(1, 10, 5)");
  });
  it("snowflake -> duckdb: UNIFORM(1, 10, 5)", () => {
    const result = transpile("UNIFORM(1, 10, 5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(FLOOR(1 + (ABS(HASH(5)) % 1000000) / 1000000.0 * (10 - 1 + 1)) AS BIGINT)");
  });
  it("snowflake -> snowflake: NORMAL(0, 1, 42)", () => {
    const result = transpile("NORMAL(0, 1, 42)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("NORMAL(0, 1, 42)");
  });
  it("snowflake -> duckdb: NORMAL(0, 1, 42)", () => {
    const result = transpile("NORMAL(0, 1, 42)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("0 + (1 * SQRT(-2 * LN(GREATEST((ABS(HASH(42)) % 1000000) / 1000000.0, 1e-10))) * COS(2 * PI() * (ABS(HASH(42 + 1)) % 1000000) / 1000000.0))");
  });
  it("snowflake -> snowflake: NORMAL(10.5, 2.5, RANDOM())", () => {
    const result = transpile("NORMAL(10.5, 2.5, RANDOM())", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("NORMAL(10.5, 2.5, RANDOM())");
  });
  it.todo("snowflake -> duckdb: NORMAL(10.5, 2.5, RANDOM()) (cross-dialect transform)");
  it("snowflake -> snowflake: NORMAL(10.5, 2.5, RANDOM(5))", () => {
    const result = transpile("NORMAL(10.5, 2.5, RANDOM(5))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("NORMAL(10.5, 2.5, RANDOM(5))");
  });
  it.todo("snowflake -> duckdb: NORMAL(10.5, 2.5, RANDOM(5)) (cross-dialect transform)");
  it("snowflake -> snowflake: SYSDATE()", () => {
    const result = transpile("SYSDATE()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SYSDATE()");
  });
  it.todo("snowflake -> duckdb: SYSDATE() (unsupported syntax)");
  it("SYSTIMESTAMP() -> CURRENT_TIMESTAMP()", () => {
    validateIdentity("SYSTIMESTAMP()", "CURRENT_TIMESTAMP()");
  });
  it("GETDATE() -> CURRENT_TIMESTAMP()", () => {
    validateIdentity("GETDATE()", "CURRENT_TIMESTAMP()");
  });
  it("LOCALTIMESTAMP -> CURRENT_TIMESTAMP", () => {
    validateIdentity("LOCALTIMESTAMP", "CURRENT_TIMESTAMP");
  });
  it("LOCALTIMESTAMP() -> CURRENT_TIMESTAMP()", () => {
    validateIdentity("LOCALTIMESTAMP()", "CURRENT_TIMESTAMP()");
  });
  it("LOCALTIMESTAMP(3) -> CURRENT_TIMESTAMP(3)", () => {
    validateIdentity("LOCALTIMESTAMP(3)", "CURRENT_TIMESTAMP(3)");
  });
  it("snowflake -> snowflake: SELECT CURRENT_TIME(4)", () => {
    const result = transpile("SELECT CURRENT_TIME(4)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CURRENT_TIME(4)");
  });
  it("snowflake -> duckdb: SELECT CURRENT_TIME(4)", () => {
    const result = transpile("SELECT CURRENT_TIME(4)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LOCALTIME");
  });
  it("snowflake -> snowflake: SELECT CURRENT_TIME", () => {
    const result = transpile("SELECT CURRENT_TIME", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CURRENT_TIME");
  });
  it("snowflake -> duckdb: SELECT CURRENT_TIME", () => {
    const result = transpile("SELECT CURRENT_TIME", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LOCALTIME");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2026, 1, 100)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 1, 100)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2026, 1, 100)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2026, 1, 100)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 1, 100)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2026, 1, 1) + INTERVAL (1 - 1) MONTH + INTERVAL (100 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2026, 14, 32)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 14, 32)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2026, 14, 32)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2026, 14, 32)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 14, 32)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2026, 1, 1) + INTERVAL (14 - 1) MONTH + INTERVAL (32 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2026, 0, 0)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 0, 0)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2026, 0, 0)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2026, 0, 0)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, 0, 0)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2026, 1, 1) + INTERVAL (0 - 1) MONTH + INTERVAL (0 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2026, -14, -32)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, -14, -32)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2026, -14, -32)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2026, -14, -32)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, -14, -32)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2026, 1, 1) + INTERVAL (-14 - 1) MONTH + INTERVAL (-32 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2024, 1, 60)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2024, 1, 60)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2024, 1, 60)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2024, 1, 60)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2024, 1, 60)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2024, 1, 1) + INTERVAL (1 - 1) MONTH + INTERVAL (60 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2026, NULL, 100)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, NULL, 100)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2026, NULL, 100)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2026, NULL, 100)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2026, NULL, 100)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2026, 1, 1) + INTERVAL (NULL - 1) MONTH + INTERVAL (100 - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(2024 + 2, 1 + 2, 2 + 3)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2024 + 2, 1 + 2, 2 + 3)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(2024 + 2, 1 + 2, 2 + 3)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(2024 + 2, 1 + 2, 2 + 3)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(2024 + 2, 1 + 2, 2 + 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(2024 + 2, 1, 1) + INTERVAL ((1 + 2) - 1) MONTH + INTERVAL ((2 + 3) - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT DATE_FROM_PARTS(year, month, date)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(year, month, date)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_FROM_PARTS(year, month, date)");
  });
  it("snowflake -> duckdb: SELECT DATE_FROM_PARTS(year, month, date)", () => {
    const result = transpile("SELECT DATE_FROM_PARTS(year, month, date)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(MAKE_DATE(year, 1, 1) + INTERVAL (month - 1) MONTH + INTERVAL (date - 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: EQUAL_NULL(a, b)", () => {
    const result = transpile("EQUAL_NULL(a, b)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("EQUAL_NULL(a, b)");
  });
  it("snowflake -> duckdb: EQUAL_NULL(a, b)", () => {
    const result = transpile("EQUAL_NULL(a, b)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("a IS NOT DISTINCT FROM b");
  });
  it("snowflake -> snowflake: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CURRENT_VERSION()");
  });
  it("snowflake -> databricks: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT CURRENT_VERSION()");
  });
  it("snowflake -> spark: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> mysql: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> singlestore: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "singlestore" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> starrocks: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT CURRENT_VERSION()");
  });
  it("snowflake -> postgres: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> redshift: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> clickhouse: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> trino: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("snowflake -> duckdb: SELECT CURRENT_VERSION()", () => {
    const result = transpile("SELECT CURRENT_VERSION()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT VERSION()");
  });
  it("SELECT CURRENT_DATABASE() (2)", () => {
    validateIdentity("SELECT CURRENT_DATABASE()");
  });
  it("SELECT CURRENT_SCHEMA()", () => {
    validateIdentity("SELECT CURRENT_SCHEMA()");
  });
});

describe("Snowflake: null_treatment", () => {
  it.todo("SELECT FIRST_VALUE(TABLE1.COLUMN1) OVER (PARTITION BY RANDOM_COLUMN... (unsupported clause)");
  it.todo("SELECT FIRST_VALUE(TABLE1.COLUMN1 RESPECT NULLS) OVER (PARTITION BY... (unsupported clause)");
  it.todo("SELECT FIRST_VALUE(TABLE1.COLUMN1) RESPECT NULLS OVER (PARTITION BY... (unsupported clause)");
  it.todo("SELECT FIRST_VALUE(TABLE1.COLUMN1 IGNORE NULLS) OVER (PARTITION BY ... (unsupported clause)");
  it.todo("SELECT FIRST_VALUE(TABLE1.COLUMN1) IGNORE NULLS OVER (PARTITION BY ... (unsupported clause)");
  it.todo("bigquery -> snowflake: SELECT * FROM foo WHERE 'str' IN UNNEST(vals) (cross-dialect transform)");
  it("snowflake -> snowflake: SELECT * FROM foo WHERE 'str' IN (SELECT value FROM TABLE(FLATT...", () => {
    const result = transpile("SELECT * FROM foo WHERE 'str' IN (SELECT value FROM TABLE(FLATTEN(INPUT => vals)) AS _u(seq, key, path, index, value, this))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * FROM foo WHERE 'str' IN (SELECT value FROM TABLE(FLATTEN(INPUT => vals)) AS _u(seq, key, path, index, value, this))");
  });
});

describe("Snowflake: staged_files", () => {
  it.todo("test_staged_files: assertEqual call");
  it('SELECT * FROM @"mystage"', () => {
    validateIdentity('SELECT * FROM @"mystage"');
  });
  it('SELECT * FROM @"myschema"."mystage"/file.gz', () => {
    validateIdentity('SELECT * FROM @"myschema"."mystage"/file.gz');
  });
  it('SELECT * FROM @"my_DB"."schEMA1".mystage/file.gz', () => {
    validateIdentity('SELECT * FROM @"my_DB"."schEMA1".mystage/file.gz');
  });
  it("SELECT metadata$filename FROM @s1/", () => {
    validateIdentity("SELECT metadata$filename FROM @s1/");
  });
  it("SELECT * FROM @~", () => {
    validateIdentity("SELECT * FROM @~");
  });
  it("SELECT * FROM @~/some/path/to/file.csv", () => {
    validateIdentity("SELECT * FROM @~/some/path/to/file.csv");
  });
  it("SELECT * FROM @mystage", () => {
    validateIdentity("SELECT * FROM @mystage");
  });
  it("SELECT * FROM '@mystage'", () => {
    validateIdentity("SELECT * FROM '@mystage'");
  });
  it("SELECT * FROM @namespace.mystage/path/to/file.json.gz", () => {
    validateIdentity("SELECT * FROM @namespace.mystage/path/to/file.json.gz");
  });
  it("SELECT * FROM @namespace.%table_name/path/to/file.json.gz", () => {
    validateIdentity("SELECT * FROM @namespace.%table_name/path/to/file.json.gz");
  });
  it.todo("SELECT * FROM '@external/location' (FILE_FORMAT => 'path.to.csv') (unsupported syntax)");
  it.todo("PUT file:///dir/tmp.csv @%table (check_command_warning)");
  it("SELECT * FROM (SELECT a FROM @foo)", () => {
    validateIdentity("SELECT * FROM (SELECT a FROM @foo)");
  });
  it.todo("SELECT * FROM (SELECT * FROM '@external/location' (FILE_FORMAT => '... (unsupported syntax)");
  it("SELECT * FROM @foo/bar (FILE_FORMAT => ds_sandbox.test.my_csv_format, PATTERN => 'test'...", () => {
    validateIdentity("SELECT * FROM @foo/bar (FILE_FORMAT => ds_sandbox.test.my_csv_format, PATTERN => 'test') AS bla");
  });
  it("SELECT t.$1, t.$2 FROM @mystage1 (FILE_FORMAT => 'myformat', PATTERN => '.*data.*[.]csv...", () => {
    validateIdentity("SELECT t.$1, t.$2 FROM @mystage1 (FILE_FORMAT => 'myformat', PATTERN => '.*data.*[.]csv.gz') AS t");
  });
  it("SELECT parse_json($1):a.b FROM @mystage2/data1.json.gz -> SELECT GET_PATH(PARSE_JSON($1...", () => {
    validateIdentity("SELECT parse_json($1):a.b FROM @mystage2/data1.json.gz", "SELECT GET_PATH(PARSE_JSON($1), 'a.b') FROM @mystage2/data1.json.gz");
  });
  it("SELECT * FROM @mystage t (c1) -> SELECT * FROM @mystage AS t(c1)", () => {
    validateIdentity("SELECT * FROM @mystage t (c1)", "SELECT * FROM @mystage AS t(c1)");
  });
  it("SELECT * FROM @foo/bar (PATTERN => 'test', FILE_FORMAT => ds_sandbox.test.my_csv_format...", () => {
    validateIdentity("SELECT * FROM @foo/bar (PATTERN => 'test', FILE_FORMAT => ds_sandbox.test.my_csv_format) AS bla", "SELECT * FROM @foo/bar (FILE_FORMAT => ds_sandbox.test.my_csv_format, PATTERN => 'test') AS bla");
  });
  it("SELECT * FROM @test.public.thing/location/somefile.csv( FILE_FORMAT => 'fmt' ) -> SELEC...", () => {
    validateIdentity("SELECT * FROM @test.public.thing/location/somefile.csv( FILE_FORMAT => 'fmt' )", "SELECT * FROM @test.public.thing/location/somefile.csv (FILE_FORMAT => 'fmt')");
  });
});

describe("Snowflake: sample", () => {
  it.todo("SELECT * FROM testtable TABLESAMPLE BERNOULLI (20.3) (unsupported clause)");
  it.todo("SELECT * FROM testtable TABLESAMPLE SYSTEM (3) SEED (82) (unsupported clause)");
  it.todo("SELECT a FROM test PIVOT(SUM(x) FOR y IN ('z', 'q')) AS x TABLESAMP... (unsupported clause)");
  it.todo("SELECT i, j FROM table1 AS t1 INNER JOIN table2 AS t2 TABLESAMPLE B... (unsupported clause)");
  it.todo("SELECT * FROM (SELECT * FROM t1 JOIN t2 ON t1.a = t2.c) TABLESAMPLE... (unsupported clause)");
  it.todo("SELECT * FROM testtable TABLESAMPLE (10 ROWS) (unsupported clause)");
  it.todo("SELECT * FROM testtable TABLESAMPLE (100) (unsupported clause)");
  it.todo("SELECT * FROM testtable SAMPLE (10) (unsupported clause)");
  it.todo("SELECT * FROM testtable SAMPLE ROW (0) (unsupported clause)");
  it.todo("SELECT a FROM test SAMPLE BLOCK (0.5) SEED (42) (unsupported clause)");
  it.todo("SELECT user_id, value FROM table_name SAMPLE BERNOULLI ($s) SEED (0) (unsupported clause)");
  it.todo("SELECT * FROM example TABLESAMPLE BERNOULLI (3) SEED (82) (unsupported clause)");
  it.todo("SELECT * FROM test AS _tmp TABLESAMPLE (5) (unsupported clause)");
  it.todo("\n            SELECT i, j\n                FROM\n                     ... (unsupported clause)");
  it.todo("SELECT * FROM testtable SAMPLE BLOCK (0.012) REPEATABLE (99992) (unsupported clause)");
  it.todo("SELECT * FROM (SELECT * FROM t1 join t2 on t1.a = t2.c) SAMPLE (1) (unsupported clause)");
  it("snowflake -> snowflake: TO_DOUBLE(expr)", () => {
    const result = transpile("TO_DOUBLE(expr)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_DOUBLE(expr)");
  });
  it("snowflake -> duckdb: TO_DOUBLE(expr)", () => {
    const result = transpile("TO_DOUBLE(expr)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(expr AS DOUBLE)");
  });
  it.todo("TO_DOUBLE(expr, fmt) (UnsupportedError in write)");
});

describe("Snowflake: timestamps", () => {
  it("SELECT CAST('12:00:00' AS TIME)", () => {
    validateIdentity("SELECT CAST('12:00:00' AS TIME)");
  });
  it("SELECT DATE_PART(month, a)", () => {
    validateIdentity("SELECT DATE_PART(month, a)");
  });
  it.todo("CAST(a AS TIMESTAMP) (unsupported syntax)");
  it.todo("CAST(a AS TIMESTAMPLTZ) (unsupported syntax)");
  it("CAST(a AS TIMESTAMPNTZ)", () => {
    validateIdentity("CAST(a AS TIMESTAMPNTZ)");
  });
  it("CAST(a AS TIMESTAMP_NTZ) -> CAST(a AS TIMESTAMPNTZ)", () => {
    validateIdentity("CAST(a AS TIMESTAMP_NTZ)", "CAST(a AS TIMESTAMPNTZ)");
  });
  it("CAST(a AS TIMESTAMP_LTZ) -> CAST(a AS TIMESTAMPLTZ)", () => {
    validateIdentity("CAST(a AS TIMESTAMP_LTZ)", "CAST(a AS TIMESTAMPLTZ)");
  });
  it.todo("SELECT a::TIMESTAMP_LTZ(9) (unsupported syntax)");
  it.todo("SELECT a::TIMESTAMPLTZ (unsupported syntax)");
  it.todo("SELECT a::TIMESTAMP WITH LOCAL TIME ZONE (unsupported syntax)");
  it("snowflake -> snowflake: SELECT EXTRACT('month', a)", () => {
    const result = transpile("SELECT EXTRACT('month', a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART('month', a)");
  });
  it("snowflake -> snowflake: SELECT DATE_PART('month', a)", () => {
    const result = transpile("SELECT DATE_PART('month', a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART('month', a)");
  });
  it.todo("SELECT DATE_PART(month, a::DATETIME) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT DATE_PART(epoch_second, foo) as ddate from table_name", () => {
    const result = transpile("SELECT DATE_PART(epoch_second, foo) as ddate from table_name", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_SECOND, foo) AS ddate FROM table_name");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(epoch_second, foo) as ddate from table_name", () => {
    const result = transpile("SELECT DATE_PART(epoch_second, foo) as ddate from table_name", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(EPOCH(foo) AS BIGINT) AS ddate FROM table_name");
  });
  it.todo("snowflake -> presto: SELECT DATE_PART(epoch_second, foo) as ddate from table_name (unsupported syntax)");
  it("snowflake -> snowflake: SELECT DATE_PART(epoch_milliseconds, foo) as ddate from table_name", () => {
    const result = transpile("SELECT DATE_PART(epoch_milliseconds, foo) as ddate from table_name", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT DATE_PART(EPOCH_MILLISECOND, foo) AS ddate FROM table_name");
  });
  it("snowflake -> duckdb: SELECT DATE_PART(epoch_milliseconds, foo) as ddate from table_name", () => {
    const result = transpile("SELECT DATE_PART(epoch_milliseconds, foo) as ddate from table_name", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT EPOCH_MS(foo) AS ddate FROM table_name");
  });
  it.todo("snowflake -> presto: SELECT DATE_PART(epoch_milliseconds, foo) as ddate from table_name (unsupported syntax)");
  it("snowflake -> snowflake: TIMESTAMPADD(DAY, 5, CAST('2008-12-25' AS DATE))", () => {
    const result = transpile("TIMESTAMPADD(DAY, 5, CAST('2008-12-25' AS DATE))", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("DATEADD(DAY, 5, CAST('2008-12-25' AS DATE))");
  });
  it.todo("snowflake -> bigquery: DATEADD(DAY, 5, CAST('2008-12-25' AS DATE)) (unsupported syntax)");
  it("snowflake -> snowflake: DATEADD(DAY, 5, CAST('2008-12-25' AS DATE))", () => {
    const result = transpile("DATEADD(DAY, 5, CAST('2008-12-25' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEADD(DAY, 5, CAST('2008-12-25' AS DATE))");
  });
  it("DATEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))", () => {
    validateIdentity("DATEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))");
  });
  it("TIMEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE)) -> DATEDIFF(DAY, ...", () => {
    validateIdentity("TIMEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))", "DATEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))");
  });
  it("TIMESTAMPDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE)) -> DATEDIFF(...", () => {
    validateIdentity("TIMESTAMPDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))", "DATEDIFF(DAY, CAST('2007-12-25' AS DATE), CAST('2008-12-25' AS DATE))");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(WEEK, '2024-12-13', '2024-12-17') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(WEEK, '2024-12-13', '2024-12-17')", () => {
    const result = transpile("DATEDIFF(WEEK, '2024-12-13', '2024-12-17')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(WEEK, '2024-12-13', '2024-12-17')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(WEEK, '2024-12-15', '2024-12-16') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(WEEK, '2024-12-15', '2024-12-16')", () => {
    const result = transpile("DATEDIFF(WEEK, '2024-12-15', '2024-12-16')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(WEEK, '2024-12-15', '2024-12-16')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(YEAR, '2020-01-15', '2023-06-20') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(YEAR, '2020-01-15', '2023-06-20')", () => {
    const result = transpile("DATEDIFF(YEAR, '2020-01-15', '2023-06-20')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(YEAR, '2020-01-15', '2023-06-20')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(MONTH, '2020-01-15', '2023-06-20') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(MONTH, '2020-01-15', '2023-06-20')", () => {
    const result = transpile("DATEDIFF(MONTH, '2020-01-15', '2023-06-20')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(MONTH, '2020-01-15', '2023-06-20')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(QUARTER, '2020-01-15', '2023-06-20') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(QUARTER, '2020-01-15', '2023-06-20')", () => {
    const result = transpile("DATEDIFF(QUARTER, '2020-01-15', '2023-06-20')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(QUARTER, '2020-01-15', '2023-06-20')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 ... (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-...", () => {
    const result = transpile("DATEDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 10:00:00.123456789')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 10:00:00.123456789')");
  });
  it.todo("snowflake -> duckdb: DATEDIFF(NANOSECOND, start_time, end_time) (cross-dialect transform)");
  it("snowflake -> snowflake: DATEDIFF(NANOSECOND, start_time, end_time)", () => {
    const result = transpile("DATEDIFF(NANOSECOND, start_time, end_time)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(NANOSECOND, start_time, end_time)");
  });
  it.todo("snowflake -> duckdb: DATEADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')", () => {
    const result = transpile("DATEADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')");
  });
  it.todo("snowflake -> duckdb: DATEADD(NANOSECOND, nano_offset, timestamp_col) (cross-dialect transform)");
  it("snowflake -> snowflake: DATEADD(NANOSECOND, nano_offset, timestamp_col)", () => {
    const result = transpile("DATEADD(NANOSECOND, nano_offset, timestamp_col)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEADD(NANOSECOND, nano_offset, timestamp_col)");
  });
  it.todo("snowflake -> duckdb: DATEADD(NANOSECOND, -123456789, '2023-01-01 10:00:00.500000000') (cross-dialect transform)");
  it("snowflake -> snowflake: DATEADD(NANOSECOND, -123456789, '2023-01-01 10:00:00.500000000')", () => {
    const result = transpile("DATEADD(NANOSECOND, -123456789, '2023-01-01 10:00:00.500000000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEADD(NANOSECOND, -123456789, '2023-01-01 10:00:00.500000000')");
  });
  it("snowflake -> duckdb: TIMESTAMPDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-0...", () => {
    const result = transpile("TIMESTAMPDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 10:00:00.123456789')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EPOCH_NS(CAST('2023-01-01 10:00:00.123456789' AS TIMESTAMP_NS)) - EPOCH_NS(CAST('2023-01-01 10:00:00.000000000' AS TIMESTAMP_NS))");
  });
  it("snowflake -> snowflake: TIMESTAMPDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '202...", () => {
    const result = transpile("TIMESTAMPDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 10:00:00.123456789')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEDIFF(NANOSECOND, '2023-01-01 10:00:00.000000000', '2023-01-01 10:00:00.123456789')");
  });
  it("snowflake -> duckdb: TIMESTAMPADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')", () => {
    const result = transpile("TIMESTAMPADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MAKE_TIMESTAMP_NS(EPOCH_NS(CAST('2023-01-01 10:00:00.000000000' AS TIMESTAMP_NS)) + 123456789)");
  });
  it("snowflake -> snowflake: TIMESTAMPADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000...", () => {
    const result = transpile("TIMESTAMPADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATEADD(NANOSECOND, 123456789, '2023-01-01 10:00:00.000000000')");
  });
  it("DATEADD(y, 5, x) -> DATEADD(YEAR, 5, x)", () => {
    validateIdentity("DATEADD(y, 5, x)", "DATEADD(YEAR, 5, x)");
  });
  it("DATEADD(y, 5, x) -> DATEADD(YEAR, 5, x) (2)", () => {
    validateIdentity("DATEADD(y, 5, x)", "DATEADD(YEAR, 5, x)");
  });
  it("DATE_PART(yyy, x) -> DATE_PART(YEAR, x)", () => {
    validateIdentity("DATE_PART(yyy, x)", "DATE_PART(YEAR, x)");
  });
  it("DATE_TRUNC(yr, x) -> DATE_TRUNC('YEAR', x)", () => {
    validateIdentity("DATE_TRUNC(yr, x)", "DATE_TRUNC('YEAR', x)");
  });
  it("snowflake -> snowflake: DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))", () => {
    const result = transpile("DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))");
  });
  it("snowflake -> duckdb: DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))", () => {
    const result = transpile("DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST('2024-06-15' AS DATE))");
  });
  it.todo("DATE_TRUNC('HOUR', CAST('2026-01-01 00:00:00' AS TIMESTAMP)) (unsupported syntax)");
  it.todo("DATE_TRUNC(YEAR, TIMESTAMP '2026-01-01 00:00:00') (unsupported syntax)");
  it.todo("DATE_TRUNC(MONTH, CAST('2024-06-15 14:23:45' AS TIMESTAMPTZ)) (unsupported syntax)");
  it("snowflake -> snowflake: DATE_TRUNC('WEEK', CURRENT_DATE)", () => {
    const result = transpile("DATE_TRUNC('WEEK', CURRENT_DATE)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CURRENT_DATE)");
  });
  it("snowflake -> duckdb: DATE_TRUNC('WEEK', CURRENT_DATE)", () => {
    const result = transpile("DATE_TRUNC('WEEK', CURRENT_DATE)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CURRENT_DATE)");
  });
  it("snowflake -> snowflake: DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE))", () => {
    const result = transpile("DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE))");
  });
  it("snowflake -> duckdb: DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE))", () => {
    const result = transpile("DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(DATE_TRUNC('HOUR', CAST('2026-01-01' AS DATE)) AS DATE)");
  });
  it("snowflake -> snowflake: DATE_TRUNC('HOUR', CAST('14:23:45.123456' AS TIME))", () => {
    const result = transpile("DATE_TRUNC('HOUR', CAST('14:23:45.123456' AS TIME))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('HOUR', CAST('14:23:45.123456' AS TIME))");
  });
  it("snowflake -> duckdb: DATE_TRUNC('HOUR', CAST('14:23:45.123456' AS TIME))", () => {
    const result = transpile("DATE_TRUNC('HOUR', CAST('14:23:45.123456' AS TIME))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(DATE_TRUNC('HOUR', CAST('1970-01-01' AS DATE) + CAST('14:23:45.123456' AS TIME)) AS TIME)");
  });
  it("snowflake -> duckdb: DATE(x)", () => {
    const result = transpile("DATE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it("snowflake -> snowflake: DATE(x)", () => {
    const result = transpile("DATE(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_DATE(x)");
  });
  it("snowflake -> snowflake: DATE('01-01-2000', 'MM-DD-YYYY')", () => {
    const result = transpile("DATE('01-01-2000', 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_DATE('01-01-2000', 'mm-DD-yyyy')");
  });
  it("snowflake -> duckdb: DATE('01-01-2000', 'MM-DD-YYYY')", () => {
    const result = transpile("DATE('01-01-2000', 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(STRPTIME('01-01-2000', '%m-%d-%Y') AS DATE)");
  });
  it("SELECT TO_TIME(x) FROM t", () => {
    validateIdentity("SELECT TO_TIME(x) FROM t");
  });
  it("snowflake -> bigquery: SELECT TO_TIME('12:05:00')", () => {
    const result = transpile("SELECT TO_TIME('12:05:00')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT CAST('12:05:00' AS TIME)");
  });
  it("snowflake -> snowflake: SELECT TO_TIME('12:05:00')", () => {
    const result = transpile("SELECT TO_TIME('12:05:00')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST('12:05:00' AS TIME)");
  });
  it("snowflake -> duckdb: SELECT TO_TIME('12:05:00')", () => {
    const result = transpile("SELECT TO_TIME('12:05:00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST('12:05:00' AS TIME)");
  });
  it.todo("SELECT TO_TIME('2024-01-15 14:30:00'::TIMESTAMP) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT TO_TIME(CONVERT_TIMEZONE('UTC', 'US/Pacific', '2024-08-0...", () => {
    const result = transpile("SELECT TO_TIME(CONVERT_TIMEZONE('UTC', 'US/Pacific', '2024-08-06 09:10:00.000')) AS pst_time", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIME(CONVERT_TIMEZONE('UTC', 'US/Pacific', '2024-08-06 09:10:00.000')) AS pst_time");
  });
  it.todo("snowflake -> duckdb: SELECT TO_TIME(CONVERT_TIMEZONE('UTC', 'US/Pacific', '2024-08-06 0... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT TO_TIME('11.15.00', 'hh24.mi.ss')", () => {
    const result = transpile("SELECT TO_TIME('11.15.00', 'hh24.mi.ss')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIME('11.15.00', 'hh24.mi.ss')");
  });
  it("snowflake -> duckdb: SELECT TO_TIME('11.15.00', 'hh24.mi.ss')", () => {
    const result = transpile("SELECT TO_TIME('11.15.00', 'hh24.mi.ss')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRPTIME('11.15.00', '%H.%M.%S') AS TIME)");
  });
  it("snowflake -> duckdb: SELECT TO_TIME('093000', 'HH24MISS')", () => {
    const result = transpile("SELECT TO_TIME('093000', 'HH24MISS')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(STRPTIME('093000', '%H%M%S') AS TIME)");
  });
  it("snowflake -> snowflake: SELECT TO_TIME('093000', 'HH24MISS')", () => {
    const result = transpile("SELECT TO_TIME('093000', 'HH24MISS')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TO_TIME('093000', 'hh24miss')");
  });
  it("snowflake -> snowflake: SELECT TRY_TO_TIME('093000', 'HH24MISS')", () => {
    const result = transpile("SELECT TRY_TO_TIME('093000', 'HH24MISS')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_TO_TIME('093000', 'hh24miss')");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIME('093000', 'HH24MISS')", () => {
    const result = transpile("SELECT TRY_TO_TIME('093000', 'HH24MISS')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TRY_CAST(TRY_STRPTIME('093000', '%H%M%S') AS TIME)");
  });
  it("snowflake -> snowflake: SELECT TRY_TO_TIME('11.15.00')", () => {
    const result = transpile("SELECT TRY_TO_TIME('11.15.00')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_CAST('11.15.00' AS TIME)");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIME('11.15.00')", () => {
    const result = transpile("SELECT TRY_TO_TIME('11.15.00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TRY_CAST('11.15.00' AS TIME)");
  });
  it("snowflake -> snowflake: SELECT TRY_TO_TIME('11.15.00', 'hh24.mi.ss')", () => {
    const result = transpile("SELECT TRY_TO_TIME('11.15.00', 'hh24.mi.ss')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT TRY_TO_TIME('11.15.00', 'hh24.mi.ss')");
  });
  it("snowflake -> duckdb: SELECT TRY_TO_TIME('11.15.00', 'hh24.mi.ss')", () => {
    const result = transpile("SELECT TRY_TO_TIME('11.15.00', 'hh24.mi.ss')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT TRY_CAST(TRY_STRPTIME('11.15.00', '%H.%M.%S') AS TIME)");
  });
});

describe("Snowflake: to_date", () => {
  it.todo("TO_DATE('12345') (assert_is check)");
  it.todo("TO_DATE(x) (assert_is check)");
  it("snowflake -> snowflake: TO_DATE('01-01-2000', 'MM-DD-YYYY')", () => {
    const result = transpile("TO_DATE('01-01-2000', 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_DATE('01-01-2000', 'mm-DD-yyyy')");
  });
  it.todo("snowflake -> duckdb: TO_DATE('01-01-2000', 'MM-DD-YYYY') (cross-dialect transform)");
  it("snowflake -> snowflake: TO_DATE(x, 'MM-DD-YYYY')", () => {
    const result = transpile("TO_DATE(x, 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_DATE(x, 'mm-DD-yyyy')");
  });
  it.todo("snowflake -> duckdb: TO_DATE(x, 'MM-DD-YYYY') (cross-dialect transform)");
  it("SELECT TO_DATE('2019-02-28') + INTERVAL '1 day, 1 year' -> SELECT CAST('2019-02-28' AS ...", () => {
    validateIdentity("SELECT TO_DATE('2019-02-28') + INTERVAL '1 day, 1 year'", "SELECT CAST('2019-02-28' AS DATE) + INTERVAL '1 day, 1 year'");
  });
  it.todo("TRY_TO_DATE(x) (assert_is check)");
  it("snowflake -> snowflake: TRY_TO_DATE('2024-01-31')", () => {
    const result = transpile("TRY_TO_DATE('2024-01-31')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_CAST('2024-01-31' AS DATE)");
  });
  it("snowflake -> duckdb: TRY_TO_DATE('2024-01-31')", () => {
    const result = transpile("TRY_TO_DATE('2024-01-31')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST('2024-01-31' AS DATE)");
  });
  it("TRY_TO_DATE('2024-01-31', 'AUTO')", () => {
    validateIdentity("TRY_TO_DATE('2024-01-31', 'AUTO')");
  });
  it("snowflake -> snowflake: TRY_TO_DATE('01-01-2000', 'MM-DD-YYYY')", () => {
    const result = transpile("TRY_TO_DATE('01-01-2000', 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_TO_DATE('01-01-2000', 'mm-DD-yyyy')");
  });
  it("snowflake -> duckdb: TRY_TO_DATE('01-01-2000', 'MM-DD-YYYY')", () => {
    const result = transpile("TRY_TO_DATE('01-01-2000', 'MM-DD-YYYY')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(CAST(TRY_STRPTIME('01-01-2000', '%m-%d-%Y') AS TIMESTAMP) AS DATE)");
  });
  it.todo("test_to_date: unresolvable SQL string");
  it.todo("test_to_date: unresolvable SQL string (2)");
  it.todo("test_to_date: unresolvable SQL string (3)");
  it.todo("test_to_date: unresolvable SQL string (4)");
  it.todo("test_to_date: unresolvable SQL string (5)");
  it.todo("test_to_date: unresolvable SQL string (6)");
  it.todo("test_to_date: unresolvable SQL string (7)");
  it.todo("test_to_date: unresolvable SQL string (8)");
  it.todo("test_to_date: unresolvable SQL string (9)");
  it("snowflake -> snowflake: TRY_TO_DATE('2013-04-28T20:57:01.888', 'yyyy-mm-DDThh24:mi:ss.ff')", () => {
    const result = transpile("TRY_TO_DATE('2013-04-28T20:57:01.888', 'yyyy-mm-DDThh24:mi:ss.ff')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_TO_DATE('2013-04-28T20:57:01.888', 'yyyy-mm-DDThh24:mi:ss.ff9')");
  });
  it.todo("snowflake -> duckdb: TRY_TO_DATE('2013-04-28T20:57:01.888', 'yyyy-mm-DDThh24:mi:ss.ff') (unsupported syntax)");
  it(`snowflake -> snowflake: TRY_TO_DATE('2013-04-28T20:57', 'YYYY-MM-DD"T"HH24:MI:SS')`, () => {
    const result = transpile(`TRY_TO_DATE('2013-04-28T20:57', 'YYYY-MM-DD"T"HH24:MI:SS')`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_TO_DATE('2013-04-28T20:57', 'yyyy-mm-DDThh24:mi:ss')");
  });
  it(`snowflake -> duckdb: TRY_TO_DATE('2013-04-28T20:57', 'YYYY-MM-DD"T"HH24:MI:SS')`, () => {
    const result = transpile(`TRY_TO_DATE('2013-04-28T20:57', 'YYYY-MM-DD"T"HH24:MI:SS')`, { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(CAST(TRY_STRPTIME('2013-04-28T20:57', '%Y-%m-%dT%H:%M:%S') AS TIMESTAMP) AS DATE)");
  });
});

describe("Snowflake: trunc", () => {
  it.todo("TRUNC(3.14159, 2) (assert_is check)");
  it.todo("TRUNC(price, 0) (assert_is check)");
  it.todo("TRUNC(3.14159) (assert_is check)");
  it.todo("TRUNC(col) (assert_is check)");
  it.todo("test_trunc: parse_one call");
  it.todo("test_trunc: parse_one call (2)");
  it.todo("test_trunc: parse_one call (3)");
  it.todo("TRUNC(foo, bar) (assert_is check)");
  it.todo("TRUNC(3.14159, 2) (DDL/DML in read/write)");
  it.todo("TRUNC(3.14159) (DDL/DML in read/write)");
  it.todo("TRUNC(price, 2) (DDL/DML in read/write)");
});

describe("Snowflake: semi_structured_types", () => {
  it("SELECT CAST(a AS VARIANT)", () => {
    validateIdentity("SELECT CAST(a AS VARIANT)");
  });
  it("SELECT CAST(a AS ARRAY)", () => {
    validateIdentity("SELECT CAST(a AS ARRAY)");
  });
  it.todo("SELECT a::VARIANT (unsupported syntax)");
  it("snowflake -> snowflake: ARRAY_CONSTRUCT(0, 1, 2)", () => {
    const result = transpile("ARRAY_CONSTRUCT(0, 1, 2)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("[0, 1, 2]");
  });
  it("snowflake -> bigquery: ARRAY_CONSTRUCT(0, 1, 2)", () => {
    const result = transpile("ARRAY_CONSTRUCT(0, 1, 2)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("[0, 1, 2]");
  });
  it("snowflake -> duckdb: ARRAY_CONSTRUCT(0, 1, 2)", () => {
    const result = transpile("ARRAY_CONSTRUCT(0, 1, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("[0, 1, 2]");
  });
  it.todo("snowflake -> presto: ARRAY_CONSTRUCT(0, 1, 2) (unsupported syntax)");
  it.todo("snowflake -> spark: ARRAY_CONSTRUCT(0, 1, 2) (unsupported syntax)");
  it("snowflake -> snowflake: ARRAYS_ZIP([1, 2], [3, 4], [4, 5])", () => {
    const result = transpile("ARRAYS_ZIP([1, 2], [3, 4], [4, 5])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAYS_ZIP([1, 2], [3, 4], [4, 5])");
  });
  it("snowflake -> duckdb: ARRAYS_ZIP([1, 2], [3, 4], [4, 5])", () => {
    const result = transpile("ARRAYS_ZIP([1, 2], [3, 4], [4, 5])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN [1, 2] IS NULL OR [3, 4] IS NULL OR [4, 5] IS NULL THEN NULL WHEN LENGTH([1, 2]) = 0 AND LENGTH([3, 4]) = 0 AND LENGTH([4, 5]) = 0 THEN [{'$1': NULL, '$2': NULL, '$3': NULL}] ELSE LIST_TRANSFORM(RANGE(0, CASE WHEN LENGTH([1, 2]) IS NULL OR LENGTH([3, 4]) IS NULL OR LENGTH([4, 5]) IS NULL THEN NULL ELSE GREATEST(LENGTH([1, 2]), LENGTH([3, 4]), LENGTH([4, 5])) END), __i -> {'$1': COALESCE([1, 2], [])[__i + 1], '$2': COALESCE([3, 4], [])[__i + 1], '$3': COALESCE([4, 5], [])[__i + 1]}) END");
  });
  it("snowflake -> snowflake: ARRAYS_ZIP([1, 2, 3])", () => {
    const result = transpile("ARRAYS_ZIP([1, 2, 3])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAYS_ZIP([1, 2, 3])");
  });
  it("snowflake -> duckdb: ARRAYS_ZIP([1, 2, 3])", () => {
    const result = transpile("ARRAYS_ZIP([1, 2, 3])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL WHEN LENGTH([1, 2, 3]) = 0 THEN [{'$1': NULL}] ELSE LIST_TRANSFORM(RANGE(0, LENGTH([1, 2, 3])), __i -> {'$1': COALESCE([1, 2, 3], [])[__i + 1]}) END");
  });
  it.todo("SELECT a::OBJECT (unsupported syntax)");
});

describe("Snowflake: next_day", () => {
  it("snowflake -> snowflake: SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), 'Monday')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), 'Monday')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), 'Monday')");
  });
  it("snowflake -> duckdb: SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), 'Monday')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), 'Monday')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(CAST('2024-01-01' AS DATE) + INTERVAL ((((1 - ISODOW(CAST('2024-01-01' AS DATE))) + 6) % 7) + 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'Friday')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'Friday')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'Friday')");
  });
  it("snowflake -> duckdb: SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'Friday')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'Friday')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(CAST('2024-01-05' AS DATE) + INTERVAL ((((5 - ISODOW(CAST('2024-01-05' AS DATE))) + 6) % 7) + 1) DAY AS DATE)");
  });
  it("snowflake -> snowflake: SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'WE')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'WE')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'WE')");
  });
  it("snowflake -> duckdb: SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'WE')", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-05' AS DATE), 'WE')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(CAST('2024-01-05' AS DATE) + INTERVAL ((((3 - ISODOW(CAST('2024-01-05' AS DATE))) + 6) % 7) + 1) DAY AS DATE)");
  });
  it.todo("SELECT NEXT_DAY(CAST('2024-01-01 10:30:45' AS TIMESTAMP), 'Friday') (unsupported syntax)");
  it("snowflake -> snowflake: SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), day_column)", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), day_column)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), day_column)");
  });
  it("snowflake -> duckdb: SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), day_column)", () => {
    const result = transpile("SELECT NEXT_DAY(CAST('2024-01-01' AS DATE), day_column)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(CAST('2024-01-01' AS DATE) + INTERVAL ((((CASE WHEN STARTS_WITH(UPPER(day_column), 'MO') THEN 1 WHEN STARTS_WITH(UPPER(day_column), 'TU') THEN 2 WHEN STARTS_WITH(UPPER(day_column), 'WE') THEN 3 WHEN STARTS_WITH(UPPER(day_column), 'TH') THEN 4 WHEN STARTS_WITH(UPPER(day_column), 'FR') THEN 5 WHEN STARTS_WITH(UPPER(day_column), 'SA') THEN 6 WHEN STARTS_WITH(UPPER(day_column), 'SU') THEN 7 END - ISODOW(CAST('2024-01-01' AS DATE))) + 6) % 7) + 1) DAY AS DATE)");
  });
});

describe("Snowflake: previous_day", () => {
  it.todo("SELECT PREVIOUS_DAY(DATE '2024-01-15', 'Monday') (unsupported syntax)");
  it.todo("SELECT PREVIOUS_DAY(DATE '2024-01-15', 'Fr') (unsupported syntax)");
  it.todo("SELECT PREVIOUS_DAY(TIMESTAMP '2024-01-15 10:30:45', 'Monday') (unsupported syntax)");
  it.todo("SELECT PREVIOUS_DAY(DATE '2024-01-15', day_column) (unsupported syntax)");
});

describe("Snowflake: historical_data", () => {
  it("SELECT * FROM my_table AT (STATEMENT => $query_id_var)", () => {
    validateIdentity("SELECT * FROM my_table AT (STATEMENT => $query_id_var)");
  });
  it("SELECT * FROM my_table AT (OFFSET => -60 * 5)", () => {
    validateIdentity("SELECT * FROM my_table AT (OFFSET => -60 * 5)");
  });
  it("SELECT * FROM my_table BEFORE (STATEMENT => $query_id_var)", () => {
    validateIdentity("SELECT * FROM my_table BEFORE (STATEMENT => $query_id_var)");
  });
  it("SELECT * FROM my_table BEFORE (OFFSET => -60 * 5)", () => {
    validateIdentity("SELECT * FROM my_table BEFORE (OFFSET => -60 * 5)");
  });
  it.todo("CREATE SCHEMA restored_schema CLONE my_schema AT (OFFSET => -3600) (DDL/DML not supported)");
  it.todo("CREATE TABLE restored_table CLONE my_table AT (TIMESTAMP => CAST('S... (DDL/DML not supported)");
  it.todo("CREATE DATABASE restored_db CLONE my_db BEFORE (STATEMENT => '8e5d0... (DDL/DML not supported)");
  it("SELECT * FROM my_table AT (TIMESTAMP => TO_TIMESTAMP(1432669154242, 3))", () => {
    validateIdentity("SELECT * FROM my_table AT (TIMESTAMP => TO_TIMESTAMP(1432669154242, 3))");
  });
  it("SELECT * FROM my_table AT (OFFSET => -60 * 5) AS T WHERE T.flag = 'valid'", () => {
    validateIdentity("SELECT * FROM my_table AT (OFFSET => -60 * 5) AS T WHERE T.flag = 'valid'");
  });
  it("SELECT * FROM my_table AT (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726')", () => {
    validateIdentity("SELECT * FROM my_table AT (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726')");
  });
  it("SELECT * FROM my_table BEFORE (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726')", () => {
    validateIdentity("SELECT * FROM my_table BEFORE (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726')");
  });
  it.todo("SELECT * FROM my_table AT (TIMESTAMP => 'Fri, 01 May 2015 16:20:00 ... (unsupported syntax)");
  it.todo("SELECT * FROM my_table AT(TIMESTAMP => 'Fri, 01 May 2015 16:20:00 -... (unsupported syntax)");
  it.todo("SELECT * FROM my_table BEFORE (TIMESTAMP => 'Fri, 01 May 2015 16:20... (unsupported syntax)");
  it("\n            SELECT oldt.* , newt.*\n            FROM my_table BEFORE(STATEMENT => '8e5d...", () => {
    validateIdentity("\n            SELECT oldt.* , newt.*\n            FROM my_table BEFORE(STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS oldt\n            FULL OUTER JOIN my_table AT(STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS newt\n            ON oldt.id = newt.id\n            WHERE oldt.id IS NULL OR newt.id IS NULL;\n            ", "SELECT oldt.*, newt.* FROM my_table BEFORE (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS oldt FULL OUTER JOIN my_table AT (STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS newt ON oldt.id = newt.id WHERE oldt.id IS NULL OR newt.id IS NULL");
  });
  it("SELECT * FROM foo AT -> SELECT * FROM foo AS AT", () => {
    validateIdentity("SELECT * FROM foo AT", "SELECT * FROM foo AS AT");
  });
  it("SELECT * FROM foo AT(col) -> SELECT * FROM foo AS AT(col)", () => {
    validateIdentity("SELECT * FROM foo AT(col)", "SELECT * FROM foo AS AT(col)");
  });
  it("SELECT * FROM foo BEFORE -> SELECT * FROM foo AS BEFORE", () => {
    validateIdentity("SELECT * FROM foo BEFORE", "SELECT * FROM foo AS BEFORE");
  });
  it("SELECT * FROM foo BEFORE(col) -> SELECT * FROM foo AS BEFORE(col)", () => {
    validateIdentity("SELECT * FROM foo BEFORE(col)", "SELECT * FROM foo AS BEFORE(col)");
  });
  it("SELECT * FROM foo END -> SELECT * FROM foo AS END", () => {
    validateIdentity("SELECT * FROM foo END", "SELECT * FROM foo AS END");
  });
  it("SELECT * FROM foo END(col) -> SELECT * FROM foo AS END(col)", () => {
    validateIdentity("SELECT * FROM foo END(col)", "SELECT * FROM foo AS END(col)");
  });
  it("SELECT * FROM foo CHANGES -> SELECT * FROM foo AS CHANGES", () => {
    validateIdentity("SELECT * FROM foo CHANGES", "SELECT * FROM foo AS CHANGES");
  });
  it("SELECT * FROM foo CHANGES(col) -> SELECT * FROM foo AS CHANGES(col)", () => {
    validateIdentity("SELECT * FROM foo CHANGES(col)", "SELECT * FROM foo AS CHANGES(col)");
  });
});

describe("Snowflake: ddl", () => {
  it.todo("CREATE TABLE t (id INT WITH MASKING POLICY p.q.r) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT WITH MASKING POLICY p USING (c1, c2, c3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT WITH PROJECTION POLICY p.q.r) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT WITH TAG (key1='value_1', key2='value_2')) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT MASKING POLICY p.q.r) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT MASKING POLICY p USING (c1, c2, c3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT PROJECTION POLICY p.q.r) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT TAG (key1='value_1', key2='value_2')) (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE TABLE foo COPY GRANTS USING TEMPLATE (SELECT 1) (DDL/DML not supported)");
  it.todo("USE SECONDARY ROLES ALL (command not supported)");
  it.todo("USE SECONDARY ROLES NONE (command not supported)");
  it.todo("USE SECONDARY ROLES a, b, c (command not supported)");
  it.todo("CREATE SECURE VIEW table1 AS (SELECT a FROM table2) (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE VIEW foo (uid) COPY GRANTS AS (SELECT 1) (DDL/DML not supported)");
  it.todo("CREATE TABLE geospatial_table (id INT, g GEOGRAPHY) (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW a COMMENT='...' AS SELECT 1 FROM x (DDL/DML not supported)");
  it.todo("CREATE DATABASE mytestdb_clone CLONE mytestdb (DDL/DML not supported)");
  it.todo("CREATE SCHEMA mytestschema_clone CLONE testschema (DDL/DML not supported)");
  it.todo("CREATE TABLE IDENTIFIER('foo') (COLUMN1 VARCHAR, COLUMN2 VARCHAR) (DDL/DML not supported)");
  it.todo("CREATE TABLE IDENTIFIER($foo) (col1 VARCHAR, col2 VARCHAR) (DDL/DML not supported)");
  it.todo("CREATE TAG cost_center ALLOWED_VALUES 'a', 'b' (DDL/DML not supported)");
  it.todo("CREATE STAGE stage1 FILE_FORMAT='format1' (DDL/DML not supported)");
  it.todo("CREATE STAGE stage1 FILE_FORMAT=(FORMAT_NAME=stage1.format1) (DDL/DML not supported)");
  it.todo("CREATE STAGE stage1 FILE_FORMAT=(FORMAT_NAME='stage1.format1') (DDL/DML not supported)");
  it.todo("CREATE STAGE stage1 FILE_FORMAT=schema1.format1 (DDL/DML not supported)");
  it.todo("test_ddl: parse_one call");
  it.todo("CREATE STAGE s1 URL='s3://bucket-123' FILE_FORMAT=(TYPE='JSON') CRE... (DDL/DML not supported)");
  it.todo("CREATE DYNAMIC TABLE product (pre_tax_profit, taxes, after_tax_prof... (DDL/DML not supported)");
  it.todo("ALTER TABLE db_name.schmaName.tblName ADD COLUMN_1 VARCHAR NOT NULL... (DDL/DML not supported)");
  it.todo("DROP FUNCTION my_udf (OBJECT(city VARCHAR, zipcode DECIMAL(38, 0), ... (DDL/DML not supported)");
  it.todo("CREATE TABLE orders_clone_restore CLONE orders AT (TIMESTAMP => TO_... (DDL/DML not supported)");
  it.todo("CREATE TABLE orders_clone_restore CLONE orders BEFORE (STATEMENT =>... (DDL/DML not supported)");
  it.todo("CREATE SCHEMA mytestschema_clone_restore CLONE testschema BEFORE (T... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE TABLE EXAMPLE_DB.DEMO.USERS (ID DECIMAL(38, 0) NO... (DDL/DML not supported)");
  it.todo("CREATE ICEBERG TABLE my_iceberg_table (amount ARRAY(INT)) CATALOG='... (DDL/DML not supported)");
  it.todo('CREATE OR REPLACE FUNCTION ibis_udfs.public.object_values("obj" OBJ... (DDL/DML not supported)');
  it.todo('CREATE OR REPLACE FUNCTION ibis_udfs.public.object_values("obj" OBJ... (DDL/DML not supported) (2)');
  it.todo("CREATE OR REPLACE TABLE TEST (SOME_REF DECIMAL(38, 0) NOT NULL FORE... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE FUNCTION my_udf(location OBJECT(city VARCHAR, zip... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE FUNCTION my_udtf(foo BOOLEAN) RETURNS TABLE(col1 ... (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE seq1 WITH START=1, INCREMENT=1 ORDER (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE seq1 WITH START=1 INCREMENT=1 ORDER (DDL/DML not supported)");
  it.todo("create external table et2(\n  col1 date as (parse_json(metadata$exte... (DDL/DML not supported)");
  it.todo("CREATE TABLE orders_clone CLONE orders (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE TRANSIENT TABLE a (id INT) (DDL/DML not supported)");
  it.todo("CREATE TABLE a (b INT) (DDL/DML not supported)");
  it.todo("CREATE TABLE a TAG (key1='value_1', key2='value_2') (DDL/DML not supported)");
  it.todo("CREATE TABLE a TAG (key1='value_1') (DDL/DML not supported)");
  it.todo("ALTER TABLE a ALTER COLUMN my_column SET NOT NULL (DDL/DML not supported)");
  it.todo("ALTER TABLE a ALTER COLUMN my_column DROP NOT NULL (DDL/DML not supported)");
});

describe("Snowflake: user_defined_functions", () => {
  it.todo("CREATE FUNCTION a(x DATE, y BIGINT) RETURNS ARRAY LANGUAGE JAVASCRI... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION a() RETURNS TABLE (b INT) AS 'SELECT 1' (DDL/DML not supported)");
  it.todo("CREATE FUNCTION a() RETURNS INT IMMUTABLE AS 'SELECT 1' (DDL/DML not supported)");
});

describe("Snowflake: stored_procedures", () => {
  it.todo("CALL a.b.c(x, y) (check_command_warning)");
  it.todo("CREATE PROCEDURE a.b.c(x INT, y VARIANT) RETURNS OBJECT EXECUTE AS ... (DDL/DML not supported)");
});

describe("Snowflake: table_function", () => {
  it("SELECT * FROM TABLE('MYTABLE')", () => {
    validateIdentity("SELECT * FROM TABLE('MYTABLE')");
  });
  it("SELECT * FROM TABLE($MYVAR)", () => {
    validateIdentity("SELECT * FROM TABLE($MYVAR)");
  });
  it("SELECT * FROM TABLE(?)", () => {
    validateIdentity("SELECT * FROM TABLE(?)");
  });
  it("SELECT * FROM TABLE(:BINDING)", () => {
    validateIdentity("SELECT * FROM TABLE(:BINDING)");
  });
  it("SELECT * FROM TABLE($MYVAR) WHERE COL1 = 10", () => {
    validateIdentity("SELECT * FROM TABLE($MYVAR) WHERE COL1 = 10");
  });
  it("SELECT * FROM TABLE('t1') AS f", () => {
    validateIdentity("SELECT * FROM TABLE('t1') AS f");
  });
  it("SELECT * FROM (TABLE('t1') CROSS JOIN TABLE('t2'))", () => {
    validateIdentity("SELECT * FROM (TABLE('t1') CROSS JOIN TABLE('t2'))");
  });
  it.todo("SELECT * FROM TABLE('t1'), LATERAL (SELECT * FROM t2) (unsupported clause)");
  it("SELECT * FROM TABLE('t1') UNION ALL SELECT * FROM TABLE('t2')", () => {
    validateIdentity("SELECT * FROM TABLE('t1') UNION ALL SELECT * FROM TABLE('t2')");
  });
  it.todo("SELECT * FROM TABLE('t1') TABLESAMPLE BERNOULLI (20.3) (unsupported clause)");
  it(`SELECT * FROM TABLE('MYDB."MYSCHEMA"."MYTABLE"')`, () => {
    validateIdentity(`SELECT * FROM TABLE('MYDB."MYSCHEMA"."MYTABLE"')`);
  });
  it.todo('SELECT * FROM TABLE($$MYDB. "MYSCHEMA"."MYTABLE"$$) (unsupported syntax)');
});

describe("Snowflake: flatten", () => {
  it.todo("test_flatten: assertEqual call");
  it.todo("\n            select\n              dag_report.acct_id,\n             ... (pretty=True not supported)");
  it.todo("\n            SELECT\n              uc.user_id,\n              uc.star... (pretty=True not supported)");
  it("snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('[1, ,77]'))) f", () => {
    const result = transpile("SELECT * FROM TABLE(FLATTEN(input => parse_json('[1, ,77]'))) f", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('[1, ,77]'))) AS f");
  });
  it(`snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[7...`, () => {
    const result = transpile(`SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[77,88]}'), outer => true)) f`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('{"a":1, "b":[77,88]}'), outer => TRUE)) AS f`);
  });
  it(`snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[7... (2)`, () => {
    const result = transpile(`SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[77,88]}'), path => 'b')) f`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('{"a":1, "b":[77,88]}'), path => 'b')) AS f`);
  });
  it("snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('[]'))) f", () => {
    const result = transpile("SELECT * FROM TABLE(FLATTEN(input => parse_json('[]'))) f", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('[]'))) AS f");
  });
  it("snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('[]'), outer =>...", () => {
    const result = transpile("SELECT * FROM TABLE(FLATTEN(input => parse_json('[]'), outer => true)) f", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('[]'), outer => TRUE)) AS f");
  });
  it(`snowflake -> snowflake: SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[7... (3)`, () => {
    const result = transpile(`SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[77,88], "c": {"d":"X"}}'))) f`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT * FROM TABLE(FLATTEN(input => PARSE_JSON('{"a":1, "b":[77,88], "c": {"d":"X"}}'))) AS f`);
  });
  it.todo(`SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[77,88... (unsupported syntax)`);
  it.todo(`SELECT * FROM TABLE(FLATTEN(input => parse_json('{"a":1, "b":[77,88... (unsupported syntax) (2)`);
  it.todo('\n            SELECT id as "ID",\n              f.value AS "Contact",... (pretty=True not supported)');
  it.todo('\n            SELECT id as "ID",\n              value AS "Contact"\n  ... (pretty=True not supported)');
});

describe("Snowflake: minus", () => {
  it("oracle -> snowflake: SELECT 1 MINUS SELECT 1", () => {
    const result = transpile("SELECT 1 MINUS SELECT 1", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 1 EXCEPT SELECT 1");
  });
  it("snowflake -> snowflake: SELECT 1 MINUS SELECT 1", () => {
    const result = transpile("SELECT 1 MINUS SELECT 1", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 1 EXCEPT SELECT 1");
  });
});

describe("Snowflake: values", () => {
  it.todo("test_values: assertEqual call");
  it.todo('SELECT "c0", "c1" FROM (VALUES (1, 2), (3, 4)) AS "t0"("c0", "c1") (unsupported syntax)');
  it.todo(`SELECT $1 AS "_1" FROM VALUES ('a'), ('b') (unsupported syntax)`);
  it.todo("duckdb -> snowflake: SELECT * FROM (VALUES ({'a': 1})) AS t(x) (unsupported syntax)");
  it.todo("duckdb -> snowflake: SELECT * FROM (VALUES ({'a': 1}), ({'a': 2})) AS t(x) (unsupported syntax)");
});

describe("Snowflake: describe", () => {
  it.todo("DESCRIBE SEMANTIC VIEW TPCDS_SEMANTIC_VIEW_SM (command not supported)");
  it("DESC SEMANTIC VIEW TPCDS_SEMANTIC_VIEW_SM -> DESCRIBE SEMANTIC VIEW TPCDS_SEMANTIC_VIEW_SM", () => {
    validateIdentity("DESC SEMANTIC VIEW TPCDS_SEMANTIC_VIEW_SM", "DESCRIBE SEMANTIC VIEW TPCDS_SEMANTIC_VIEW_SM");
  });
  it.todo("DESCRIBE TABLE db.table (command not supported)");
  it.todo("DESCRIBE db.table (command not supported)");
  it.todo("snowflake -> snowflake: DESC TABLE db.table (command not supported)");
  it.todo("snowflake -> spark: DESC TABLE db.table (command not supported)");
  it.todo("snowflake -> snowflake: DESC VIEW db.table (command not supported)");
  it.todo("snowflake -> spark: DESC VIEW db.table (command not supported)");
  it("bigquery -> snowflake: ENDS_WITH('abc', 'c')", () => {
    const result = transpile("ENDS_WITH('abc', 'c')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("clickhouse -> snowflake: endsWith('abc', 'c')", () => {
    const result = transpile("endsWith('abc', 'c')", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("databricks -> snowflake: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("duckdb -> snowflake: ENDS_WITH('abc', 'c')", () => {
    const result = transpile("ENDS_WITH('abc', 'c')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("presto -> snowflake: ENDS_WITH('abc', 'c')", () => {
    const result = transpile("ENDS_WITH('abc', 'c')", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("spark -> snowflake: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("snowflake -> bigquery: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("ENDS_WITH('abc', 'c')");
  });
  it("snowflake -> clickhouse: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("endsWith('abc', 'c')");
  });
  it("snowflake -> databricks: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("snowflake -> duckdb: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ENDS_WITH('abc', 'c')");
  });
  it("snowflake -> presto: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ENDS_WITH('abc', 'c')");
  });
  it("snowflake -> snowflake: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
  it("snowflake -> spark: ENDSWITH('abc', 'c')", () => {
    const result = transpile("ENDSWITH('abc', 'c')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ENDSWITH('abc', 'c')");
  });
});

describe("Snowflake: regexp_substr", () => {
  it("snowflake -> bigquery: REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern, pos, occ)");
  });
  it("snowflake -> hive: REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern, group)");
  });
  it("snowflake -> presto: REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe('REGEXP_EXTRACT(subject, pattern, "group")');
  });
  it("snowflake -> snowflake: REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)");
  });
  it("snowflake -> spark: REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, pos, occ, params, group)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern, group)");
  });
  it("bigquery -> snowflake: REGEXP_EXTRACT(subject, pattern)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern)");
  });
  it("snowflake -> bigquery: REGEXP_SUBSTR(subject, pattern)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern)");
  });
  it("snowflake -> snowflake: REGEXP_SUBSTR(subject, pattern)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern)");
  });
  it("hive -> snowflake: REGEXP_EXTRACT(subject, pattern)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)");
  });
  it("spark2 -> snowflake: REGEXP_EXTRACT(subject, pattern)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)");
  });
  it("spark -> snowflake: REGEXP_EXTRACT(subject, pattern)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)");
  });
  it("databricks -> snowflake: REGEXP_EXTRACT(subject, pattern)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)");
  });
  it("snowflake -> hive: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern)");
  });
  it("snowflake -> spark2: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern)");
  });
  it("snowflake -> spark: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern)");
  });
  it("snowflake -> databricks: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("REGEXP_EXTRACT(subject, pattern)");
  });
  it("snowflake -> snowflake: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', 1)");
  });
  it("duckdb -> snowflake: REGEXP_EXTRACT(subject, pattern, group)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern, group)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)");
  });
  it("hive -> snowflake: REGEXP_EXTRACT(subject, pattern, group)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern, group)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)");
  });
  it("presto -> snowflake: REGEXP_EXTRACT(subject, pattern, group)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern, group)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)");
  });
  it("snowflake -> snowflake: REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)", () => {
    const result = transpile("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)");
  });
  it("spark -> snowflake: REGEXP_EXTRACT(subject, pattern, group)", () => {
    const result = transpile("REGEXP_EXTRACT(subject, pattern, group)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_SUBSTR(subject, pattern, 1, 1, 'c', group)");
  });
  it("REGEXP_SUBSTR_ALL(subject, pattern, pos, occ, param, group) -> REGEXP_EXTRACT_ALL(subje...", () => {
    validateIdentity("REGEXP_SUBSTR_ALL(subject, pattern, pos, occ, param, group)", "REGEXP_EXTRACT_ALL(subject, pattern, pos, occ, param, group)");
  });
  it("SELECT SEARCH((play, line), 'dream')", () => {
    validateIdentity("SELECT SEARCH((play, line), 'dream')");
  });
  it("SELECT SEARCH(line, 'king', ANALYZER => 'UNICODE_ANALYZER')", () => {
    validateIdentity("SELECT SEARCH(line, 'king', ANALYZER => 'UNICODE_ANALYZER')");
  });
  it.todo("SELECT SEARCH(character, 'king queen', SEARCH_MODE => 'AND') (unsupported syntax)");
  it("SELECT SEARCH(line, 'king', ANALYZER => 'UNICODE_ANALYZER', SEARCH_MODE => 'OR')", () => {
    validateIdentity("SELECT SEARCH(line, 'king', ANALYZER => 'UNICODE_ANALYZER', SEARCH_MODE => 'OR')");
  });
  it.todo("test_regexp_substr: assertEqual call");
  it.todo("test_regexp_substr: assertIsNone call");
  it.todo("test_regexp_substr: assertIsNone call (2)");
  it.todo("test_regexp_substr: assertIsNotNone call");
  it.todo("test_regexp_substr: assertIsNone call (3)");
  it.todo("test_regexp_substr: assertIsNone call (4)");
  it.todo("test_regexp_substr: assertIsNotNone call (2)");
  it.todo("test_regexp_substr: assertEqual call (2)");
  it.todo("test_regexp_substr: assertIsNotNone call (3)");
  it.todo("test_regexp_substr: assertIsNotNone call (4)");
  it("SELECT REGEXP_COUNT('hello world', 'l ')", () => {
    validateIdentity("SELECT REGEXP_COUNT('hello world', 'l ')");
  });
  it("SELECT REGEXP_COUNT('hello world', 'l', 1)", () => {
    validateIdentity("SELECT REGEXP_COUNT('hello world', 'l', 1)");
  });
  it("SELECT REGEXP_COUNT('hello world', 'l', 1, 'i')", () => {
    validateIdentity("SELECT REGEXP_COUNT('hello world', 'l', 1, 'i')");
  });
});

describe("Snowflake: regexp_replace", () => {
  it("snowflake -> bigquery: REGEXP_REPLACE(subject, pattern)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, '')");
  });
  it("snowflake -> duckdb: REGEXP_REPLACE(subject, pattern)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, '', 'g')");
  });
  it("snowflake -> hive: REGEXP_REPLACE(subject, pattern)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, '')");
  });
  it("snowflake -> snowflake: REGEXP_REPLACE(subject, pattern)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, '')");
  });
  it("snowflake -> spark: REGEXP_REPLACE(subject, pattern)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, '')");
  });
  it("bigquery -> snowflake: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("duckdb -> snowflake: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("hive -> snowflake: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("spark -> snowflake: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> bigquery: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> duckdb: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 'g')");
  });
  it("snowflake -> postgres: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 'g')");
  });
  it("snowflake -> hive: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> snowflake: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> spark: REGEXP_REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("spark -> snowflake: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position)");
  });
  it("snowflake -> bigquery: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> duckdb: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 'g')");
  });
  it("snowflake -> postgres: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position, 'g')");
  });
  it("snowflake -> hive: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> snowflake: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position)");
  });
  it("snowflake -> spark: REGEXP_REPLACE(subject, pattern, replacement, position)", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position)");
  });
  it("snowflake -> bigquery: REGEXP_REPLACE(subject, pattern, replacement, position, occurren...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> duckdb: REGEXP_REPLACE(subject, pattern, replacement, position, occurrence...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 'c')");
  });
  it("snowflake -> postgres: REGEXP_REPLACE(subject, pattern, replacement, position, occurren...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')");
  });
  it("snowflake -> hive: REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, ...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> snowflake: REGEXP_REPLACE(subject, pattern, replacement, position, occurre...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')");
  });
  it("snowflake -> spark: REGEXP_REPLACE(subject, pattern, replacement, position, occurrence,...", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, position, occurrence, 'c')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, position)");
  });
  it("snowflake -> snowflake: REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')");
  });
  it("snowflake -> duckdb: REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 'cg')");
  });
  it("snowflake -> postgres: REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", () => {
    const result = transpile("REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'c')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("REGEXP_REPLACE(subject, pattern, replacement, 1, 0, 'cg')");
  });
});

describe("Snowflake: replace", () => {
  it("snowflake -> bigquery: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("snowflake -> duckdb: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("snowflake -> hive: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("snowflake -> snowflake: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("snowflake -> spark: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("bigquery -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("duckdb -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("hive -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("spark -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> bigquery: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> duckdb: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> hive: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("snowflake -> spark: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
});

describe("Snowflake: match_recognize", () => {
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (2)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (3)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (4)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (5)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (6)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (7)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (8)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (9)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (10)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (11)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (12)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (13)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (14)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (15)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (16)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (17)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (18)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (19)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (20)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (21)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (22)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (23)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (24)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (25)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (26)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (27)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (28)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (29)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (30)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (31)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (32)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (33)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (34)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (35)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (36)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (37)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (38)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (39)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (40)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (41)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (42)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (43)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (44)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (45)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (46)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (47)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (48)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (49)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (50)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (51)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (52)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (53)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (54)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (55)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (56)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (57)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (58)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (59)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (60)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (61)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (62)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (63)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (64)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (65)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (66)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (67)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (68)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (69)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (70)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (71)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (72)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (73)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (74)");
  it.todo("SELECT\n  *\nFROM x\nMATCH_RECOGNIZE (\n  PARTITION BY a, b\n  ORDER BY\n... (pretty=True not supported) (75)");
});

describe("Snowflake: show_users", () => {
  it.todo("SHOW USERS (command not supported)");
  it.todo("SHOW TERSE USERS (command not supported)");
  it.todo("SHOW USERS LIKE '_foo%' STARTS WITH 'bar' LIMIT 5 FROM 'baz' (command not supported)");
});

describe("Snowflake: show_databases", () => {
  it.todo("SHOW TERSE DATABASES (command not supported)");
  it.todo("SHOW TERSE DATABASES HISTORY LIKE 'foo' STARTS WITH 'bla' LIMIT 5 F... (command not supported)");
  it.todo("test_show_databases: assertEqual call");
  it.todo("test_show_databases: assertEqual call (2)");
});

describe("Snowflake: show_file_formats", () => {
  it.todo("SHOW FILE FORMATS (command not supported)");
  it.todo("SHOW FILE FORMATS LIKE 'foo' IN DATABASE db1 (command not supported)");
  it.todo("SHOW FILE FORMATS LIKE 'foo' IN SCHEMA db1.schema1 (command not supported)");
  it.todo("test_show_file_formats: assertEqual call");
  it.todo("test_show_file_formats: assertEqual call (2)");
});

describe("Snowflake: show_functions", () => {
  it.todo("SHOW FUNCTIONS (command not supported)");
  it.todo("SHOW FUNCTIONS LIKE 'foo' IN CLASS bla (command not supported)");
  it.todo("test_show_functions: assertEqual call");
  it.todo("test_show_functions: assertEqual call (2)");
});

describe("Snowflake: show_procedures", () => {
  it.todo("SHOW PROCEDURES (command not supported)");
  it.todo("SHOW PROCEDURES LIKE 'foo' IN APPLICATION app (command not supported)");
  it.todo("SHOW PROCEDURES LIKE 'foo' IN APPLICATION PACKAGE pkg (command not supported)");
  it.todo("test_show_procedures: assertEqual call");
  it.todo("test_show_procedures: assertEqual call (2)");
});

describe("Snowflake: show_stages", () => {
  it.todo("SHOW STAGES (command not supported)");
  it.todo("SHOW STAGES LIKE 'foo' IN DATABASE db1 (command not supported)");
  it.todo("SHOW STAGES LIKE 'foo' IN SCHEMA db1.schema1 (command not supported)");
  it.todo("test_show_stages: assertEqual call");
  it.todo("test_show_stages: assertEqual call (2)");
});

describe("Snowflake: show_warehouses", () => {
  it.todo("SHOW WAREHOUSES (command not supported)");
  it.todo("SHOW WAREHOUSES LIKE 'foo' WITH PRIVILEGES USAGE, MODIFY (command not supported)");
  it.todo("test_show_warehouses: assertEqual call");
});

describe("Snowflake: show_schemas", () => {
  it.todo("show terse schemas in database db1 starts with 'a' limit 10 from 'b' (command not supported)");
  it.todo("test_show_schemas: assertEqual call");
  it.todo("test_show_schemas: assertEqual call (2)");
});

describe("Snowflake: show_objects", () => {
  it.todo("show terse objects in schema db1.schema1 starts with 'a' limit 10 f... (command not supported)");
  it.todo("show terse objects in db1.schema1 starts with 'a' limit 10 from 'b' (command not supported)");
  it.todo("test_show_objects: assertEqual call");
  it.todo("test_show_objects: assertEqual call (2)");
});

describe("Snowflake: show_columns", () => {
  it.todo("SHOW COLUMNS (command not supported)");
  it.todo("SHOW COLUMNS IN TABLE dt_test (command not supported)");
  it.todo("SHOW COLUMNS LIKE '_foo%' IN TABLE dt_test (command not supported)");
  it.todo("SHOW COLUMNS IN VIEW (command not supported)");
  it.todo("SHOW COLUMNS LIKE '_foo%' IN VIEW dt_test (command not supported)");
  it.todo("test_show_columns: assertEqual call");
  it.todo("test_show_columns: assertEqual call (2)");
});

describe("Snowflake: show_tables", () => {
  it.todo("SHOW TABLES LIKE 'line%' IN tpch.public (command not supported)");
  it.todo("SHOW TABLES HISTORY IN tpch.public (command not supported)");
  it.todo("show terse tables in schema db1.schema1 starts with 'a' limit 10 fr... (command not supported)");
  it.todo("show terse tables in db1.schema1 starts with 'a' limit 10 from 'b' (command not supported)");
  it.todo("test_show_tables: assertEqual call");
});

describe("Snowflake: show_primary_keys", () => {
  it.todo("SHOW PRIMARY KEYS (command not supported)");
  it.todo("SHOW PRIMARY KEYS IN ACCOUNT (command not supported)");
  it.todo("SHOW PRIMARY KEYS IN DATABASE (command not supported)");
  it.todo("SHOW PRIMARY KEYS IN DATABASE foo (command not supported)");
  it.todo("SHOW PRIMARY KEYS IN TABLE (command not supported)");
  it.todo("SHOW PRIMARY KEYS IN TABLE foo (command not supported)");
  it.todo('SHOW PRIMARY KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo('SHOW TERSE PRIMARY KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo("test_show_primary_keys: assertEqual call");
});

describe("Snowflake: show_views", () => {
  it.todo("SHOW TERSE VIEWS (command not supported)");
  it.todo("SHOW VIEWS (command not supported)");
  it.todo("SHOW VIEWS LIKE 'foo%' (command not supported)");
  it.todo("SHOW VIEWS IN ACCOUNT (command not supported)");
  it.todo("SHOW VIEWS IN DATABASE (command not supported)");
  it.todo("SHOW VIEWS IN DATABASE foo (command not supported)");
  it.todo("SHOW VIEWS IN SCHEMA foo (command not supported)");
  it.todo("SHOW VIEWS IN foo (command not supported)");
  it.todo("test_show_views: assertEqual call");
});

describe("Snowflake: show_unique_keys", () => {
  it.todo("SHOW UNIQUE KEYS (command not supported)");
  it.todo("SHOW UNIQUE KEYS IN ACCOUNT (command not supported)");
  it.todo("SHOW UNIQUE KEYS IN DATABASE (command not supported)");
  it.todo("SHOW UNIQUE KEYS IN DATABASE foo (command not supported)");
  it.todo("SHOW UNIQUE KEYS IN TABLE (command not supported)");
  it.todo("SHOW UNIQUE KEYS IN TABLE foo (command not supported)");
  it.todo('SHOW UNIQUE KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo('SHOW TERSE UNIQUE KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo("test_show_unique_keys: assertEqual call");
});

describe("Snowflake: show_imported_keys", () => {
  it.todo("SHOW IMPORTED KEYS (command not supported)");
  it.todo("SHOW IMPORTED KEYS IN ACCOUNT (command not supported)");
  it.todo("SHOW IMPORTED KEYS IN DATABASE (command not supported)");
  it.todo("SHOW IMPORTED KEYS IN DATABASE foo (command not supported)");
  it.todo("SHOW IMPORTED KEYS IN TABLE (command not supported)");
  it.todo("SHOW IMPORTED KEYS IN TABLE foo (command not supported)");
  it.todo('SHOW IMPORTED KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo('SHOW TERSE IMPORTED KEYS IN "TEST"."PUBLIC"."foo" (command not supported)');
  it.todo("test_show_imported_keys: assertEqual call");
});

describe("Snowflake: show_sequences", () => {
  it.todo("SHOW TERSE SEQUENCES (command not supported)");
  it.todo("SHOW SEQUENCES (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN ACCOUNT (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN DATABASE (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN DATABASE foo (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN SCHEMA (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN SCHEMA foo (command not supported)");
  it.todo("SHOW SEQUENCES LIKE '_foo%' IN foo (command not supported)");
  it.todo("test_show_sequences: assertEqual call");
});

describe("Snowflake: swap", () => {
  it.todo("test_swap: assert statement");
  it.todo("test_swap: assert statement (2)");
});

describe("Snowflake: try_cast", () => {
  it("hive -> snowflake: CAST('foo' AS STRING)", () => {
    const result = transpile("CAST('foo' AS STRING)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("TRY_CAST('foo' AS VARCHAR)");
  });
  it("hive -> snowflake: CAST(5 + 5 AS STRING)", () => {
    const result = transpile("CAST(5 + 5 AS STRING)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(5 + 5 AS VARCHAR)");
  });
  it("hive -> snowflake: CAST(CAST('2020-01-01' AS DATE) AS STRING)", () => {
    const result = transpile("CAST(CAST('2020-01-01' AS DATE) AS STRING)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TRY_CAST('2020-01-01' AS DATE) AS VARCHAR)");
  });
  it("snowflake -> snowflake: CAST(TRY_CAST('2020-01-01' AS DATE) AS VARCHAR)", () => {
    const result = transpile("CAST(TRY_CAST('2020-01-01' AS DATE) AS VARCHAR)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TRY_CAST('2020-01-01' AS DATE) AS VARCHAR)");
  });
  it("hive -> snowflake: CAST('val' AS STRING)", () => {
    const result = transpile("CAST('val' AS STRING)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("TRY_CAST('val' AS VARCHAR)");
  });
  it("snowflake -> snowflake: TRY_CAST('val' AS VARCHAR)", () => {
    const result = transpile("TRY_CAST('val' AS VARCHAR)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("TRY_CAST('val' AS VARCHAR)");
  });
  it("SELECT TRY_CAST(x AS DOUBLE)", () => {
    validateIdentity("SELECT TRY_CAST(x AS DOUBLE)");
  });
  it("SELECT TRY_CAST(FOO() AS TEXT) -> SELECT TRY_CAST(FOO() AS VARCHAR)", () => {
    validateIdentity("SELECT TRY_CAST(FOO() AS TEXT)", "SELECT TRY_CAST(FOO() AS VARCHAR)");
  });
  it.todo("test_try_cast: assertEqual call");
  it.todo("test_try_cast: assertEqual call (2)");
});

describe("Snowflake: decfloat", () => {
  it("snowflake -> snowflake: SELECT CAST(1.5 AS DECFLOAT)", () => {
    const result = transpile("SELECT CAST(1.5 AS DECFLOAT)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST(1.5 AS DECFLOAT)");
  });
  it("snowflake -> duckdb: SELECT CAST(1.5 AS DECFLOAT)", () => {
    const result = transpile("SELECT CAST(1.5 AS DECFLOAT)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CAST(1.5 AS DECIMAL(38, 5))");
  });
  it.todo("CREATE TABLE t (x DECFLOAT) (DDL/DML not supported)");
});

describe("Snowflake: copy", () => {
  it.todo("COPY INTO test (c1) FROM (SELECT $1.c1 FROM @mystage) (command not supported)");
  it.todo("COPY INTO temp FROM @random_stage/path/ FILE_FORMAT = (TYPE=CSV FIE... (command not supported)");
  it.todo("COPY INTO load1 FROM @%load1/data1/ CREDENTIALS = (AWS_KEY_ID='id' ... (command not supported)");
  it.todo("COPY INTO mytable FROM 'azure://myaccount.blob.core.windows.net/myc... (command not supported)");
  it.todo("COPY INTO mytable (col1, col2) FROM 's3://mybucket/data/files' STOR... (command not supported)");
  it.todo("COPY INTO @my_stage/result/data FROM (SELECT * FROM orderstiny) FIL... (command not supported)");
  it.todo("COPY INTO mytable FILE_FORMAT = (TYPE='csv') (command not supported)");
  it.todo("COPY INTO MY_DATABASE.MY_SCHEMA.MY_TABLE FROM @MY_DATABASE.MY_SCHEM... (command not supported)");
  it.todo("COPY INTO 's3://example/data.csv'\n    FROM EXTRA.EXAMPLE.TABLE\n    ... (pretty=True not supported)");
  it.todo("COPY INTO 's3://example/data.csv'\n    FROM EXTRA.EXAMPLE.TABLE\n    ... (command not supported)");
  it.todo("test_copy: assertEqual call");
});

describe("Snowflake: put_to_stage", () => {
  it.todo(`PUT 'file:///dir/tmp.csv' @"my_DB"."schEMA1"."MYstage" (command not supported)`);
  it.todo("test_put_to_stage: assertIsInstance call");
  it.todo("test_put_to_stage: assertEqual call");
  it.todo("test_put_to_stage: assertEqual call (2)");
  it.todo("test_put_to_stage: assertEqual call (3)");
  it.todo("test_put_to_stage: assertIsInstance call (2)");
  it.todo("test_put_to_stage: assertEqual call (4)");
  it.todo("test_put_to_stage: assertEqual call (5)");
  it.todo("test_put_to_stage: assertEqual call (6)");
  it.todo("PUT 'file:///dir/tmp.csv' @s1/test (command not supported)");
  it.todo("PUT file:///dir/tmp.csv @%table (check_command_warning)");
  it.todo("PUT file:///dir/tmp.csv @s1/test PARALLEL=1 AUTO_COMPRESS=FALSE sou... (check_command_warning)");
});

describe("Snowflake: get_from_stage", () => {
  it.todo(`GET @"my_DB"."schEMA1"."MYstage" 'file:///dir/tmp.csv' (command not supported)`);
  it.todo("GET @s1/test 'file:///dir/tmp.csv' (assert_is check)");
  it.todo("test_get_from_stage: assertIsInstance call");
  it.todo("test_get_from_stage: assertEqual call");
  it.todo("test_get_from_stage: assertEqual call (2)");
  it.todo("test_get_from_stage: assertEqual call (3)");
  it.todo("test_get_from_stage: assertIsInstance call (2)");
  it.todo("test_get_from_stage: assertEqual call (4)");
  it.todo("test_get_from_stage: assertEqual call (5)");
  it.todo("test_get_from_stage: assertEqual call (6)");
  it.todo("GET @%table file:///dir/tmp.csv (check_command_warning)");
  it.todo("GET @s1/test file:///dir/tmp.csv PARALLEL=1 (check_command_warning)");
});

describe("Snowflake: querying_semi_structured_data", () => {
  it("SELECT $1", () => {
    validateIdentity("SELECT $1");
  });
  it("SELECT $1.elem", () => {
    validateIdentity("SELECT $1.elem");
  });
  it("SELECT $1:a.b -> SELECT GET_PATH($1, 'a.b')", () => {
    validateIdentity("SELECT $1:a.b", "SELECT GET_PATH($1, 'a.b')");
  });
  it("SELECT t.$23:a.b -> SELECT GET_PATH(t.$23, 'a.b')", () => {
    validateIdentity("SELECT t.$23:a.b", "SELECT GET_PATH(t.$23, 'a.b')");
  });
  it("SELECT t.$17:a[0].b[0].c -> SELECT GET_PATH(t.$17, 'a[0].b[0].c')", () => {
    validateIdentity("SELECT t.$17:a[0].b[0].c", "SELECT GET_PATH(t.$17, 'a[0].b[0].c')");
  });
  it(`snowflake -> snowflake: \n            SELECT col:"customer's department"\n            `, () => {
    const result = transpile(`\n            SELECT col:"customer's department"\n            `, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`SELECT GET_PATH(col, '["customer\\'s department"]')`);
  });
  it.todo(`snowflake -> postgres: \n            SELECT col:"customer's department"\n             (unsupported syntax)`);
});

describe("Snowflake: alter_set_unset", () => {
  it.todo("ALTER TABLE tbl SET DATA_RETENTION_TIME_IN_DAYS=1 (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET DEFAULT_DDL_COLLATION='test' (DDL/DML not supported)");
  it.todo("ALTER TABLE foo SET COMMENT='bar' (DDL/DML not supported)");
  it.todo("ALTER TABLE foo SET CHANGE_TRACKING=FALSE (DDL/DML not supported)");
  it.todo("ALTER TABLE table1 SET TAG foo.bar = 'baz' (DDL/DML not supported)");
  it.todo("ALTER TABLE IF EXISTS foo SET TAG a = 'a', b = 'b', c = 'c' (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET STAGE_FILE_FORMAT = (TYPE=CSV FIELD_DELIMITER='... (DDL/DML not supported)");
  it.todo("ALTER TABLE tbl SET STAGE_COPY_OPTIONS = (ON_ERROR=SKIP_FILE SIZE_L... (DDL/DML not supported)");
  it.todo("ALTER TABLE foo UNSET TAG a, b, c (DDL/DML not supported)");
  it.todo("ALTER TABLE foo UNSET DATA_RETENTION_TIME_IN_DAYS, CHANGE_TRACKING (DDL/DML not supported)");
});

describe("Snowflake: alter_session", () => {
  it.todo("test_alter_session: assertEqual call");
  it.todo("test_alter_session: assertEqual call (2)");
});

describe("Snowflake: from_changes", () => {
  it("SELECT C1 FROM t1 CHANGES (INFORMATION => APPEND_ONLY) AT (STREAM => 's1') END (TIMESTA...", () => {
    validateIdentity("SELECT C1 FROM t1 CHANGES (INFORMATION => APPEND_ONLY) AT (STREAM => 's1') END (TIMESTAMP => $ts2)");
  });
  it("SELECT C1 FROM t1 CHANGES (INFORMATION => APPEND_ONLY) BEFORE (STATEMENT => 'STMT_ID') ...", () => {
    validateIdentity("SELECT C1 FROM t1 CHANGES (INFORMATION => APPEND_ONLY) BEFORE (STATEMENT => 'STMT_ID') END (TIMESTAMP => $ts2)");
  });
  it("SELECT 1 FROM some_table CHANGES (INFORMATION => APPEND_ONLY) AT (TIMESTAMP => TO_TIMES...", () => {
    validateIdentity("SELECT 1 FROM some_table CHANGES (INFORMATION => APPEND_ONLY) AT (TIMESTAMP => TO_TIMESTAMP_TZ('2024-07-01 00:00:00+00:00')) END (TIMESTAMP => TO_TIMESTAMP_TZ('2024-07-01 14:28:59.999999+00:00'))", "SELECT 1 FROM some_table CHANGES (INFORMATION => APPEND_ONLY) AT (TIMESTAMP => CAST('2024-07-01 00:00:00+00:00' AS TIMESTAMPTZ)) END (TIMESTAMP => CAST('2024-07-01 14:28:59.999999+00:00' AS TIMESTAMPTZ))");
  });
});

describe("Snowflake: grant", () => {
  it.todo("test_grant: unresolvable for-loop iterable");
  it.todo("GRANT ALL PRIVILEGES ON FUNCTION mydb.myschema.ADD5(number) TO ROLE... (command not supported)");
});

describe("Snowflake: revoke", () => {
  it.todo("test_revoke: unresolvable for-loop iterable");
  it.todo("REVOKE ALL PRIVILEGES ON FUNCTION mydb.myschema.ADD5(number) FROM R... (command not supported)");
});

describe("Snowflake: window_function_arg", () => {
  it.todo("test_window_function_arg: assertEqual call");
  it.todo("test_window_function_arg: assertEqual call (2)");
  it.todo("test_window_function_arg: assertEqual call (3)");
});

describe("Snowflake: offset_without_limit", () => {
  it("trino -> snowflake: SELECT 1 ORDER BY 1 OFFSET 0", () => {
    const result = transpile("SELECT 1 ORDER BY 1 OFFSET 0", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 1 ORDER BY 1 LIMIT NULL OFFSET 0");
  });
});

describe("Snowflake: listagg", () => {
  it("LISTAGG(data['some_field'], ',')", () => {
    validateIdentity("LISTAGG(data['some_field'], ',')");
  });
  it.todo("SELECT LISTAGG(col, '|SEPARATOR|') WITHIN GROUP (ORDER BY col2) FROM t (unsupported clause)");
  it.todo("SELECT LISTAGG(DISTINCT col, '|SEPARATOR|') WITHIN GROUP (ORDER BY ... (unsupported clause)");
});

describe("Snowflake: rely_options", () => {
  it.todo("CREATE TABLE t (col1 INT PRIMARY KEY NORELY, col2 INT UNIQUE NORELY... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col1 INT, col2 INT, col3 INT, PRIMARY KEY (col1) NO... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col1 INT PRIMARY KEY RELY, col2 INT UNIQUE RELY, co... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col1 INT, col2 INT, col3 INT, PRIMARY KEY (col1) RE... (DDL/DML not supported)");
});

describe("Snowflake: parameter", () => {
  it.todo("test_parameter: assertEqual call");
  it("SELECT :1, :2", () => {
    validateIdentity("SELECT :1, :2");
  });
  it("SELECT :1 + :2", () => {
    validateIdentity("SELECT :1 + :2");
  });
});

describe("Snowflake: max_by_min_by", () => {
  it.todo("test_max_by_min_by: unresolvable for-loop iterable");
  it.todo("test_max_by_min_by: unresolvable for-loop iterable (2)");
  it("snowflake -> snowflake: SELECT MAX_BY(a, b) FROM t", () => {
    const result = transpile("SELECT MAX_BY(a, b) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MAX_BY(a, b) FROM t");
  });
  it("snowflake -> duckdb: SELECT MAX_BY(a, b) FROM t", () => {
    const result = transpile("SELECT MAX_BY(a, b) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MAX(a, b) FROM t");
  });
  it("snowflake -> snowflake: SELECT MIN_BY(a, b) FROM t", () => {
    const result = transpile("SELECT MIN_BY(a, b) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MIN_BY(a, b) FROM t");
  });
  it("snowflake -> duckdb: SELECT MIN_BY(a, b) FROM t", () => {
    const result = transpile("SELECT MIN_BY(a, b) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MIN(a, b) FROM t");
  });
});

describe("Snowflake: create_view_copy_grants", () => {
  it.todo("CREATE OR REPLACE VIEW FOO (A, B) COPY GRANTS AS SELECT A, B FROM TBL (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE MATERIALIZED VIEW FOO COPY GRANTS (A, B) AS SELEC... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE MATERIALIZED VIEW FOO COPY GRANTS (A, B) COMMENT=... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE VIEW FOO (A, B) AS SELECT A, B FROM TBL (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE MATERIALIZED VIEW FOO (A, B) AS SELECT A, B FROM TBL (DDL/DML not supported)");
});

describe("Snowflake: semantic_view", () => {
  it.todo("SELECT * FROM SEMANTIC_VIEW(foo METRICS a.b, a.c DIMENSIONS a.b, a.... (pretty=True not supported)");
  it("SELECT col1, col2, metric1 FROM SEMANTIC_VIEW(mydb.myschema.my_semantic_view METRICS me...", () => {
    validateIdentity("SELECT col1, col2, metric1 FROM SEMANTIC_VIEW(mydb.myschema.my_semantic_view METRICS metric1 DIMENSIONS col1, DATE_TRUNC('MONTH', timestamp_col) AS col2) ORDER BY col1, col2 DESC");
  });
});

describe("Snowflake: get_extract", () => {
  it("snowflake -> snowflake: SELECT GET([4, 5, 6], 1)", () => {
    const result = transpile("SELECT GET([4, 5, 6], 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GET([4, 5, 6], 1)");
  });
  it("snowflake -> duckdb: SELECT GET([4, 5, 6], 1)", () => {
    const result = transpile("SELECT GET([4, 5, 6], 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT [4, 5, 6][2]");
  });
  it.todo("SELECT GET(col::MAP(INTEGER, VARCHAR), 1) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT GET(v, 'field')", () => {
    const result = transpile("SELECT GET(v, 'field')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GET(v, 'field')");
  });
  it.todo("snowflake -> duckdb: SELECT GET(v, 'field') (unsupported syntax)");
  it.todo("GET(foo, bar) (assert_is check)");
});

describe("Snowflake: create_sequence", () => {
  it.todo("CREATE SEQUENCE seq  START=5 comment = 'foo' INCREMENT=10 (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE seq WITH START=1 INCREMENT=1 (DDL/DML not supported)");
});

describe("Snowflake: bit_aggs", () => {
  it.todo("test_bit_aggs: unresolvable for-loop iterable");
});

describe("Snowflake: bitmap_or_agg", () => {
  it("BITMAP_OR_AGG(x)", () => {
    validateIdentity("BITMAP_OR_AGG(x)");
  });
});

describe("Snowflake: md5_functions", () => {
  it("MD5_HEX(col) -> MD5(col)", () => {
    validateIdentity("MD5_HEX(col)", "MD5(col)");
  });
  it("MD5(col)", () => {
    validateIdentity("MD5(col)");
  });
  it("MD5_BINARY(col)", () => {
    validateIdentity("MD5_BINARY(col)");
  });
  it("MD5_NUMBER_LOWER64(col)", () => {
    validateIdentity("MD5_NUMBER_LOWER64(col)");
  });
  it("MD5_NUMBER_UPPER64(col)", () => {
    validateIdentity("MD5_NUMBER_UPPER64(col)");
  });
});

describe("Snowflake: sha1", () => {
  it("snowflake -> snowflake: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("snowflake -> duckdb: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it.todo("test_sha1: assertEqual call");
  it.todo("test_sha1: assertEqual call (2)");
  it.todo("SHA1(X'002A'::BINARY) (unsupported syntax)");
  it.todo("test_sha1: assertEqual call (3)");
  it.todo("test_sha1: assertEqual call (4)");
  it.todo("test_sha1: assertEqual call (5)");
  it.todo("test_sha1: assertEqual call (6)");
});

describe("Snowflake: model_attribute", () => {
  it("SELECT model!mladmin", () => {
    validateIdentity("SELECT model!mladmin");
  });
  it("SELECT model!PREDICT(1)", () => {
    validateIdentity("SELECT model!PREDICT(1)");
  });
  it("SELECT m!PREDICT(INPUT_DATA => {*}) AS p FROM tbl", () => {
    validateIdentity("SELECT m!PREDICT(INPUT_DATA => {*}) AS p FROM tbl");
  });
  it("SELECT m!PREDICT(INPUT_DATA => {tbl.*}) AS p FROM tbl", () => {
    validateIdentity("SELECT m!PREDICT(INPUT_DATA => {tbl.*}) AS p FROM tbl");
  });
  it("x.y.z!PREDICT(foo, bar, baz, bla)", () => {
    validateIdentity("x.y.z!PREDICT(foo, bar, baz, bla)");
  });
  it("SELECT * FROM TABLE(model_trained_with_labeled_data!DETECT_ANOMALIES(INPUT_DATA => TABL...", () => {
    validateIdentity("SELECT * FROM TABLE(model_trained_with_labeled_data!DETECT_ANOMALIES(INPUT_DATA => TABLE(view_with_data_to_analyze), TIMESTAMP_COLNAME => 'date', TARGET_COLNAME => 'sales', CONFIG_OBJECT => OBJECT_CONSTRUCT('prediction_interval', 0.99)))");
  });
});

describe("Snowflake: set_item_kind_attribute", () => {
  it.todo("test_set_item_kind_attribute: assertIsNotNone call");
  it.todo("test_set_item_kind_attribute: assertIsNone call");
  it.todo("test_set_item_kind_attribute: assertIsNotNone call (2)");
  it.todo("test_set_item_kind_attribute: assertEqual call");
});

describe("Snowflake: round", () => {
  it("snowflake -> snowflake: SELECT ROUND(2.25) AS value", () => {
    const result = transpile("SELECT ROUND(2.25) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(2.25) AS value", () => {
    const result = transpile("SELECT ROUND(2.25) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(2.25, 1) AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(2.25, 1) AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(EXPR => 2.25, SCALE => 1) AS value", () => {
    const result = transpile("SELECT ROUND(EXPR => 2.25, SCALE => 1) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(EXPR => 2.25, SCALE => 1) AS value", () => {
    const result = transpile("SELECT ROUND(EXPR => 2.25, SCALE => 1) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(SCALE => 1, EXPR => 2.25) AS value", () => {
    const result = transpile("SELECT ROUND(SCALE => 1, EXPR => 2.25) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(SCALE => 1, EXPR => 2.25) AS value", () => {
    const result = transpile("SELECT ROUND(SCALE => 1, EXPR => 2.25) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value", () => {
    const result = transpile("SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(EXPR => 2.25, SCALE => 1, ROUNDING_MODE => 'HALF_A...", () => {
    const result = transpile("SELECT ROUND(EXPR => 2.25, SCALE => 1, ROUNDING_MODE => 'HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1, 'HALF_AWAY_FROM_ZERO') AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(EXPR => 2.25, SCALE => 1, ROUNDING_MODE => 'HALF_AWAY...", () => {
    const result = transpile("SELECT ROUND(EXPR => 2.25, SCALE => 1, ROUNDING_MODE => 'HALF_AWAY_FROM_ZERO') AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.25, 1) AS value");
  });
  it.todo("SELECT ROUND(2.25, 1, 'HALF_TO_EVEN') AS value (unsupported syntax)");
  it.todo("SELECT ROUND(ROUNDING_MODE => 'HALF_TO_EVEN', EXPR => 2.25, SCALE =... (unsupported syntax)");
  it.todo("SELECT ROUND(SCALE => 1, EXPR => 2.25, , ROUNDING_MODE => 'HALF_TO_... (unsupported syntax)");
  it.todo("SELECT ROUND(EXPR => 2.25, SCALE => 1, ROUNDING_MODE => 'HALF_TO_EV... (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ROUND(2.256, 1.8) AS value", () => {
    const result = transpile("SELECT ROUND(2.256, 1.8) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.256, 1.8) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(2.256, 1.8) AS value", () => {
    const result = transpile("SELECT ROUND(2.256, 1.8) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.256, CAST(1.8 AS INT)) AS value");
  });
  it("snowflake -> snowflake: SELECT ROUND(2.256, CAST(1.8 AS DECIMAL(38, 0))) AS value", () => {
    const result = transpile("SELECT ROUND(2.256, CAST(1.8 AS DECIMAL(38, 0))) AS value", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ROUND(2.256, CAST(1.8 AS DECIMAL(38, 0))) AS value");
  });
  it("snowflake -> duckdb: SELECT ROUND(2.256, CAST(1.8 AS DECIMAL(38, 0))) AS value", () => {
    const result = transpile("SELECT ROUND(2.256, CAST(1.8 AS DECIMAL(38, 0))) AS value", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(2.256, CAST(CAST(1.8 AS DECIMAL(38, 0)) AS INT)) AS value");
  });
});

describe("Snowflake: get_bit", () => {
  it("snowflake -> snowflake: SELECT GETBIT(11, 1)", () => {
    const result = transpile("SELECT GETBIT(11, 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT GETBIT(11, 1)");
  });
  it("snowflake -> databricks: SELECT GETBIT(11, 1)", () => {
    const result = transpile("SELECT GETBIT(11, 1)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT GETBIT(11, 1)");
  });
  it("snowflake -> redshift: SELECT GETBIT(11, 1)", () => {
    const result = transpile("SELECT GETBIT(11, 1)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT GETBIT(11, 1)");
  });
  it.todo("test_get_bit: assertEqual call");
  it.todo("test_get_bit: assertEqual call (2)");
});

describe("Snowflake: to_binary", () => {
  it.todo("test_to_binary: assertEqual call");
  it.todo("test_to_binary: assertEqual call (2)");
  it.todo("test_to_binary: assertEqual call (3)");
  it.todo("test_to_binary: assertEqual call (4)");
  it.todo("test_to_binary: assertEqual call (5)");
  it.todo("test_to_binary: assertEqual call (6)");
  it.todo("test_to_binary: assertEqual call (7)");
  it.todo("test_to_binary: assertEqual call (8)");
  it.todo("test_to_binary: assertEqual call (9)");
});

describe("Snowflake: reverse", () => {
  it.todo("test_reverse: assertEqual call");
  it.todo("test_reverse: assertEqual call (2)");
  it.todo("test_reverse: assertEqual call (3)");
  it.todo("test_reverse: assertEqual call (4)");
});

describe("Snowflake: float_interval", () => {
  it.todo("test_float_interval: assertEqual call");
  it.todo("test_float_interval: assertEqual call (2)");
  it.todo("test_float_interval: assertEqual call (3)");
  it.todo("test_float_interval: assertEqual call (4)");
});

describe("Snowflake: transpile_bitwise_ops", () => {
  it.todo("test_transpile_bitwise_ops: assertEqual call");
  it.todo("test_transpile_bitwise_ops: assertEqual call (2)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (3)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (4)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (5)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (6)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (7)");
  it.todo("test_transpile_bitwise_ops: assertEqual call (8)");
});

describe("Snowflake: quoting", () => {
  it.todo("test_quoting: assertEqual call");
});

describe("Snowflake: floor", () => {
  it("snowflake -> duckdb: SELECT FLOOR(1.753, 2)", () => {
    const result = transpile("SELECT FLOOR(1.753, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(FLOOR(1.753 * POWER(10, 2)) / POWER(10, 2), 2)");
  });
  it("snowflake -> duckdb: SELECT FLOOR(123.45, -1)", () => {
    const result = transpile("SELECT FLOOR(123.45, -1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(FLOOR(123.45 * POWER(10, -1)) / POWER(10, -1), -1)");
  });
  it("snowflake -> duckdb: SELECT FLOOR(a + b, 2)", () => {
    const result = transpile("SELECT FLOOR(a + b, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(FLOOR((a + b) * POWER(10, 2)) / POWER(10, 2), 2)");
  });
  it("snowflake -> duckdb: SELECT FLOOR(1.234, 1.5)", () => {
    const result = transpile("SELECT FLOOR(1.234, 1.5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(FLOOR(1.234 * POWER(10, CAST(1.5 AS INT))) / POWER(10, CAST(1.5 AS INT)), CAST(1.5 AS INT))");
  });
});

describe("Snowflake: seq_functions", () => {
  it.todo("snowflake -> duckdb: SELECT SEQ1() FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ1() FROM test", () => {
    const result = transpile("SELECT SEQ1() FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ1() FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ1(0) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ1(0) FROM test", () => {
    const result = transpile("SELECT SEQ1(0) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ1(0) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ1(1) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ1(1) FROM test", () => {
    const result = transpile("SELECT SEQ1(1) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ1(1) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ2() FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ2() FROM test", () => {
    const result = transpile("SELECT SEQ2() FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ2() FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ2(0) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ2(0) FROM test", () => {
    const result = transpile("SELECT SEQ2(0) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ2(0) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ2(1) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ2(1) FROM test", () => {
    const result = transpile("SELECT SEQ2(1) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ2(1) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ4() FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ4() FROM test", () => {
    const result = transpile("SELECT SEQ4() FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ4() FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ4(0) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ4(0) FROM test", () => {
    const result = transpile("SELECT SEQ4(0) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ4(0) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ4(1) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ4(1) FROM test", () => {
    const result = transpile("SELECT SEQ4(1) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ4(1) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ8() FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ8() FROM test", () => {
    const result = transpile("SELECT SEQ8() FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ8() FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ8(0) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ8(0) FROM test", () => {
    const result = transpile("SELECT SEQ8(0) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ8(0) FROM test");
  });
  it.todo("snowflake -> duckdb: SELECT SEQ8(1) FROM test (unsupported syntax)");
  it("snowflake -> snowflake: SELECT SEQ8(1) FROM test", () => {
    const result = transpile("SELECT SEQ8(1) FROM test", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ8(1) FROM test");
  });
});

describe("Snowflake: generator", () => {
  it("snowflake -> duckdb: SELECT 1 FROM TABLE(GENERATOR(ROWCOUNT => 5))", () => {
    const result = transpile("SELECT 1 FROM TABLE(GENERATOR(ROWCOUNT => 5))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT 1 FROM RANGE(5)");
  });
  it("snowflake -> snowflake: SELECT 1 FROM TABLE(GENERATOR(ROWCOUNT => 5))", () => {
    const result = transpile("SELECT 1 FROM TABLE(GENERATOR(ROWCOUNT => 5))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT 1 FROM TABLE(GENERATOR(ROWCOUNT => 5))");
  });
  it("snowflake -> duckdb: SELECT SEQ8() FROM TABLE(GENERATOR(ROWCOUNT => 5))", () => {
    const result = transpile("SELECT SEQ8() FROM TABLE(GENERATOR(ROWCOUNT => 5))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT range % 18446744073709551616 FROM RANGE(5)");
  });
  it("snowflake -> snowflake: SELECT SEQ8() FROM TABLE(GENERATOR(ROWCOUNT => 5))", () => {
    const result = transpile("SELECT SEQ8() FROM TABLE(GENERATOR(ROWCOUNT => 5))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT SEQ8() FROM TABLE(GENERATOR(ROWCOUNT => 5))");
  });
  it("snowflake -> duckdb: SELECT * FROM (TABLE(GENERATOR(ROWCOUNT => 5)) JOIN other ON 1 = 1)", () => {
    const result = transpile("SELECT * FROM (TABLE(GENERATOR(ROWCOUNT => 5)) JOIN other ON 1 = 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM (RANGE(5) JOIN other ON 1 = 1)");
  });
  it("snowflake -> snowflake: SELECT * FROM (TABLE(GENERATOR(ROWCOUNT => 5)) JOIN other ON 1 ...", () => {
    const result = transpile("SELECT * FROM (TABLE(GENERATOR(ROWCOUNT => 5)) JOIN other ON 1 = 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT * FROM (TABLE(GENERATOR(ROWCOUNT => 5)) JOIN other ON 1 = 1)");
  });
});

describe("Snowflake: ceil", () => {
  it("snowflake -> duckdb: SELECT CEIL(1.753, 2)", () => {
    const result = transpile("SELECT CEIL(1.753, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(CEIL(1.753 * POWER(10, 2)) / POWER(10, 2), 2)");
  });
  it("snowflake -> duckdb: SELECT CEIL(123.45, -1)", () => {
    const result = transpile("SELECT CEIL(123.45, -1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(CEIL(123.45 * POWER(10, -1)) / POWER(10, -1), -1)");
  });
  it("snowflake -> duckdb: SELECT CEIL(a + b, 2)", () => {
    const result = transpile("SELECT CEIL(a + b, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(CEIL((a + b) * POWER(10, 2)) / POWER(10, 2), 2)");
  });
  it("snowflake -> duckdb: SELECT CEIL(1.234, 1.5)", () => {
    const result = transpile("SELECT CEIL(1.234, 1.5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ROUND(CEIL(1.234 * POWER(10, CAST(1.5 AS INT))) / POWER(10, CAST(1.5 AS INT)), CAST(1.5 AS INT))");
  });
});

describe("Snowflake: corr", () => {
  it.todo("SELECT CORR(a, b) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) OVER (PARTITION BY c) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) FILTER(WHERE c > 0) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) FILTER(WHERE c > 0) OVER (PARTITION BY d) (unsupported syntax)");
});

describe("Snowflake: encryption_functions", () => {
  it("ENCRYPT(value, 'passphrase')", () => {
    validateIdentity("ENCRYPT(value, 'passphrase')");
  });
  it("ENCRYPT(value, 'passphrase', 'aad')", () => {
    validateIdentity("ENCRYPT(value, 'passphrase', 'aad')");
  });
  it("ENCRYPT(value, 'passphrase', 'aad', 'AES-GCM')", () => {
    validateIdentity("ENCRYPT(value, 'passphrase', 'aad', 'AES-GCM')");
  });
  it("ENCRYPT_RAW(value, key, iv)", () => {
    validateIdentity("ENCRYPT_RAW(value, key, iv)");
  });
  it("ENCRYPT_RAW(value, key, iv, aad)", () => {
    validateIdentity("ENCRYPT_RAW(value, key, iv, aad)");
  });
  it("ENCRYPT_RAW(value, key, iv, aad, 'AES-GCM')", () => {
    validateIdentity("ENCRYPT_RAW(value, key, iv, aad, 'AES-GCM')");
  });
  it("DECRYPT(encrypted, 'passphrase')", () => {
    validateIdentity("DECRYPT(encrypted, 'passphrase')");
  });
  it("DECRYPT(encrypted, 'passphrase', 'aad')", () => {
    validateIdentity("DECRYPT(encrypted, 'passphrase', 'aad')");
  });
  it("DECRYPT(encrypted, 'passphrase', 'aad', 'AES-GCM')", () => {
    validateIdentity("DECRYPT(encrypted, 'passphrase', 'aad', 'AES-GCM')");
  });
  it("DECRYPT_RAW(encrypted, key, iv)", () => {
    validateIdentity("DECRYPT_RAW(encrypted, key, iv)");
  });
  it("DECRYPT_RAW(encrypted, key, iv, aad)", () => {
    validateIdentity("DECRYPT_RAW(encrypted, key, iv, aad)");
  });
  it("DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM')", () => {
    validateIdentity("DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM')");
  });
  it("DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM', aead)", () => {
    validateIdentity("DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM', aead)");
  });
  it("TRY_DECRYPT(encrypted, 'passphrase')", () => {
    validateIdentity("TRY_DECRYPT(encrypted, 'passphrase')");
  });
  it("TRY_DECRYPT(encrypted, 'passphrase', 'aad')", () => {
    validateIdentity("TRY_DECRYPT(encrypted, 'passphrase', 'aad')");
  });
  it("TRY_DECRYPT(encrypted, 'passphrase', 'aad', 'AES-GCM')", () => {
    validateIdentity("TRY_DECRYPT(encrypted, 'passphrase', 'aad', 'AES-GCM')");
  });
  it("TRY_DECRYPT_RAW(encrypted, key, iv)", () => {
    validateIdentity("TRY_DECRYPT_RAW(encrypted, key, iv)");
  });
  it("TRY_DECRYPT_RAW(encrypted, key, iv, aad)", () => {
    validateIdentity("TRY_DECRYPT_RAW(encrypted, key, iv, aad)");
  });
  it("TRY_DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM')", () => {
    validateIdentity("TRY_DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM')");
  });
  it("TRY_DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM', aead)", () => {
    validateIdentity("TRY_DECRYPT_RAW(encrypted, key, iv, aad, 'AES-GCM', aead)");
  });
});

describe("Snowflake: update_statement", () => {
  it.todo("UPDATE test SET t = 1 FROM t1 (DDL/DML not supported)");
  it.todo("UPDATE test SET t = 1 FROM t2 JOIN t3 ON t2.id = t3.id (DDL/DML not supported)");
  it.todo("UPDATE test SET t = 1 FROM (SELECT id FROM test2) AS t2 JOIN test3 ... (DDL/DML not supported)");
  it.todo("UPDATE sometesttable u FROM (SELECT 5195 AS new_count, '01bee1e5-00... (DDL/DML not supported)");
});

describe("Snowflake: type_sensitive_bitshift_transpilation", () => {
  it.todo("test_type_sensitive_bitshift_transpilation: assertEqual call");
  it.todo("test_type_sensitive_bitshift_transpilation: assertEqual call (2)");
});

describe("Snowflake: array_flatten", () => {
  it.todo("SELECT ARRAY_FLATTEN([['a', 'b'], ['c', 'd', 'e']]) (unsupported syntax)");
  it("snowflake -> snowflake: SELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]])");
  });
  it("snowflake -> duckdb: SELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT FLATTEN([[[1, 2], [3]], [[4], [5]]])");
  });
  it("snowflake -> snowflake: SELECT ARRAY_FLATTEN([[1, NULL, 3], [4]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[1, NULL, 3], [4]])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_FLATTEN([[1, NULL, 3], [4]])");
  });
  it("snowflake -> duckdb: SELECT ARRAY_FLATTEN([[1, NULL, 3], [4]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[1, NULL, 3], [4]])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT FLATTEN([[1, NULL, 3], [4]])");
  });
  it("snowflake -> snowflake: SELECT ARRAY_FLATTEN([[]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[]])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT ARRAY_FLATTEN([[]])");
  });
  it("snowflake -> duckdb: SELECT ARRAY_FLATTEN([[]])", () => {
    const result = transpile("SELECT ARRAY_FLATTEN([[]])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT FLATTEN([[]])");
  });
});

describe("Snowflake: space", () => {
  it("snowflake -> snowflake: SELECT SPACE(5)", () => {
    const result = transpile("SELECT SPACE(5)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REPEAT(' ', 5)");
  });
  it("snowflake -> duckdb: SELECT SPACE(5)", () => {
    const result = transpile("SELECT SPACE(5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT REPEAT(' ', CAST(5 AS BIGINT))");
  });
  it("snowflake -> snowflake: SELECT SPACE(3.7)", () => {
    const result = transpile("SELECT SPACE(3.7)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REPEAT(' ', 3.7)");
  });
  it("snowflake -> duckdb: SELECT SPACE(3.7)", () => {
    const result = transpile("SELECT SPACE(3.7)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT REPEAT(' ', CAST(3.7 AS BIGINT))");
  });
  it("snowflake -> snowflake: SELECT SPACE(NULL)", () => {
    const result = transpile("SELECT SPACE(NULL)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT REPEAT(' ', NULL)");
  });
  it("snowflake -> duckdb: SELECT SPACE(NULL)", () => {
    const result = transpile("SELECT SPACE(NULL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT REPEAT(' ', CAST(NULL AS BIGINT))");
  });
});

describe("Snowflake: directed_joins", () => {
  it("SELECT * FROM a CROSS DIRECTED JOIN b USING (id)", () => {
    validateIdentity("SELECT * FROM a CROSS DIRECTED JOIN b USING (id)");
  });
  it("SELECT * FROM a INNER DIRECTED JOIN b USING (id)", () => {
    validateIdentity("SELECT * FROM a INNER DIRECTED JOIN b USING (id)");
  });
  it("SELECT * FROM a NATURAL INNER DIRECTED JOIN b USING (id)", () => {
    validateIdentity("SELECT * FROM a NATURAL INNER DIRECTED JOIN b USING (id)");
  });
  it.todo("test_directed_joins: unresolvable SQL string");
  it.todo("test_directed_joins: unresolvable SQL string (2)");
  it.todo("test_directed_joins: unresolvable SQL string (3)");
  it.todo("test_directed_joins: unresolvable SQL string (4)");
  it.todo("test_directed_joins: unresolvable SQL string (5)");
  it.todo("test_directed_joins: unresolvable SQL string (6)");
  it.todo("test_directed_joins: unresolvable SQL string (7)");
  it.todo("test_directed_joins: unresolvable SQL string (8)");
  it.todo("test_directed_joins: unresolvable SQL string (9)");
  it.todo("test_directed_joins: unresolvable SQL string (10)");
  it.todo("test_directed_joins: unresolvable SQL string (11)");
  it.todo("test_directed_joins: unresolvable SQL string (12)");
});
