// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "prql";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Prql: prql", () => {
  it("prql -> : from x", () => {
    const result = transpile("from x", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x");
  });
  it("prql -> : from x derive a + 1", () => {
    const result = transpile("from x derive a + 1", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT *, a + 1 FROM x");
  });
  it("prql -> : from x derive x = a + 1", () => {
    const result = transpile("from x derive x = a + 1", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT *, a + 1 AS x FROM x");
  });
  it("prql -> : from x derive {a + 1}", () => {
    const result = transpile("from x derive {a + 1}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT *, a + 1 FROM x");
  });
  it("prql -> : from x derive {x = a + 1, b}", () => {
    const result = transpile("from x derive {x = a + 1, b}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT *, a + 1 AS x, b FROM x");
  });
  it("prql -> : from x derive {x = a + 1, b} select {y = x, 2}", () => {
    const result = transpile("from x derive {x = a + 1, b} select {y = x, 2}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT a + 1 AS y, 2 FROM x");
  });
  it("prql -> : from x take 10", () => {
    const result = transpile("from x take 10", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x LIMIT 10");
  });
  it("prql -> : from x take 10 take 5", () => {
    const result = transpile("from x take 10 take 5", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x LIMIT 5");
  });
  it("prql -> : from x filter age > 25", () => {
    const result = transpile("from x filter age > 25", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE age > 25");
  });
  it("prql -> : from x derive {x = a + 1, b} filter age > 25", () => {
    const result = transpile("from x derive {x = a + 1, b} filter age > 25", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT *, a + 1 AS x, b FROM x WHERE age > 25");
  });
  it("prql -> : from x filter dept != 'IT'", () => {
    const result = transpile("from x filter dept != 'IT'", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE dept <> 'IT'");
  });
  it("prql -> : from x filter p == 'product' select { a, b }", () => {
    const result = transpile("from x filter p == 'product' select { a, b }", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT a, b FROM x WHERE p = 'product'");
  });
  it("prql -> : from x filter age > 25 filter age < 27", () => {
    const result = transpile("from x filter age > 25 filter age < 27", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE age > 25 AND age < 27");
  });
  it("prql -> : from x filter (age > 25 && age < 27)", () => {
    const result = transpile("from x filter (age > 25 && age < 27)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE (age > 25 AND age < 27)");
  });
  it.todo("from x filter (age > 25 || age < 27) (unsupported syntax)");
  it.todo("from x filter (age > 25 || age < 22) filter age > 26 filter age < 27 (unsupported syntax)");
  it("prql -> : from x sort age", () => {
    const result = transpile("from x sort age", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x ORDER BY age");
  });
  it("prql -> : from x sort {-age}", () => {
    const result = transpile("from x sort {-age}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x ORDER BY age DESC");
  });
  it("prql -> : from x sort {age, name}", () => {
    const result = transpile("from x sort {age, name}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x ORDER BY age, name");
  });
  it("prql -> : from x sort {-age, +name}", () => {
    const result = transpile("from x sort {-age, +name}", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x ORDER BY age DESC, name");
  });
  it("prql -> : from x append y", () => {
    const result = transpile("from x append y", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x UNION ALL SELECT * FROM y");
  });
  it("prql -> : from x remove y", () => {
    const result = transpile("from x remove y", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x EXCEPT ALL SELECT * FROM y");
  });
  it("prql -> : from x intersect y", () => {
    const result = transpile("from x intersect y", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x INTERSECT ALL SELECT * FROM y");
  });
  it("prql -> : from x filter a == null filter null != b", () => {
    const result = transpile("from x filter a == null filter null != b", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE a IS NULL AND NOT b IS NULL");
  });
  it.todo("from x filter (a > 1 || null != b || c != null) (unsupported syntax)");
  it("prql -> : from a aggregate { average x }", () => {
    const result = transpile("from a aggregate { average x }", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT AVG(x) FROM a");
  });
  it("prql -> : from a aggregate { average x, min y, ct = sum z }", () => {
    const result = transpile("from a aggregate { average x, min y, ct = sum z }", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT AVG(x), MIN(y), COALESCE(SUM(z), 0) AS ct FROM a");
  });
  it("prql -> : from a aggregate { average x, min y, sum z }", () => {
    const result = transpile("from a aggregate { average x, min y, sum z }", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT AVG(x), MIN(y), COALESCE(SUM(z), 0) FROM a");
  });
  it("prql -> : from a aggregate { min y, b = stddev x, max z }", () => {
    const result = transpile("from a aggregate { min y, b = stddev x, max z }", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT MIN(y), STDDEV(x) AS b, MAX(z) FROM a");
  });
});
