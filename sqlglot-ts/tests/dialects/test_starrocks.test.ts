// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "starrocks";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Starrocks: starrocks", () => {
  it.todo("test_starrocks: assertEqual call");
  it("SELECT ARRAY_JOIN([1, 3, 5, NULL], '_', 'NULL')", () => {
    validateIdentity("SELECT ARRAY_JOIN([1, 3, 5, NULL], '_', 'NULL')");
  });
  it("SELECT ARRAY_JOIN([1, 3, 5, NULL], '_')", () => {
    validateIdentity("SELECT ARRAY_JOIN([1, 3, 5, NULL], '_')");
  });
  it.todo("ALTER TABLE a SWAP WITH b (DDL/DML not supported)");
  it("SELECT ARRAY_AGG(a) FROM x", () => {
    validateIdentity("SELECT ARRAY_AGG(a) FROM x");
  });
  it("SELECT ST_POINT(10, 20)", () => {
    validateIdentity("SELECT ST_POINT(10, 20)");
  });
  it("SELECT ST_DISTANCE_SPHERE(10.1, 20.2, 30.3, 40.4)", () => {
    validateIdentity("SELECT ST_DISTANCE_SPHERE(10.1, 20.2, 30.3, 40.4)");
  });
  it.todo("ARRAY_FLATTEN(arr) (assert_is check)");
  it(" -> starrocks: SELECT * FROM t WHERE cond IS TRUE", () => {
    const result = transpile("SELECT * FROM t WHERE cond IS TRUE", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t WHERE cond");
  });
  it("starrocks -> starrocks: SELECT * FROM t WHERE cond", () => {
    const result = transpile("SELECT * FROM t WHERE cond", { readDialect: "starrocks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t WHERE cond");
  });
  it("CURRENT_VERSION()", () => {
    validateIdentity("CURRENT_VERSION()");
  });
});

describe("Starrocks: ddl", () => {
  it.todo("INSERT OVERWRITE my_table SELECT * FROM other_table (DDL/DML not supported)");
  it.todo("CREATE TABLE t (c INT) COMMENT 'c' (DDL/DML not supported)");
  it.todo("test_ddl: unresolvable for-loop iterable");
  it.todo("CREATE TABLE foo (col0 DECIMAL(9, 1), col1 DECIMAL32(9, 1), col2 DE... (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (col1 LARGEINT) DISTRIBUTED BY HASH (col1) BUCKETS 1 (DDL/DML not supported)");
  it.todo("CREATE VIEW foo (foo_col1) SECURITY NONE AS SELECT bar_col1 FROM bar (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (col1 BIGINT, col2 BIGINT) ROLLUP (r1(col1, col2),... (DDL/DML not supported)");
  it.todo("test_ddl: assertEqual call");
  it.todo("test_ddl: assertEqual call (2)");
  it.todo("test_ddl: unresolvable for-loop iterable (2)");
  it.todo("ALTER TABLE t1 RENAME t2 (DDL/DML not supported)");
});

describe("Starrocks: identity", () => {
  it("SELECT CAST(`a`.`b` AS INT) FROM foo", () => {
    validateIdentity("SELECT CAST(`a`.`b` AS INT) FROM foo");
  });
  it("SELECT APPROX_COUNT_DISTINCT(a) FROM x", () => {
    validateIdentity("SELECT APPROX_COUNT_DISTINCT(a) FROM x");
  });
  it("SELECT [1, 2, 3]", () => {
    validateIdentity("SELECT [1, 2, 3]");
  });
  it.todo("SELECT CAST(PARSE_JSON(fieldvalue) -> '00000000-0000-0000-0000-0000... (unsupported syntax)");
  it("SELECT text FROM example_table -> SELECT `text` FROM example_table", () => {
    validateIdentity("SELECT text FROM example_table", "SELECT `text` FROM example_table");
  });
});

describe("Starrocks: time", () => {
  it("TIMESTAMP('2022-01-01')", () => {
    validateIdentity("TIMESTAMP('2022-01-01')");
  });
  it("SELECT DATE_DIFF('SECOND', '2010-11-30 23:59:59', '2010-11-30 20:58:59')", () => {
    validateIdentity("SELECT DATE_DIFF('SECOND', '2010-11-30 23:59:59', '2010-11-30 20:58:59')");
  });
  it("SELECT DATE_DIFF('MINUTE', '2010-11-30 23:59:59', '2010-11-30 20:58:59')", () => {
    validateIdentity("SELECT DATE_DIFF('MINUTE', '2010-11-30 23:59:59', '2010-11-30 20:58:59')");
  });
});

describe("Starrocks: regex", () => {
  it.todo("mysql -> starrocks: SELECT REGEXP_LIKE(abc, '%foo%') (cross-dialect transform)");
  it("starrocks -> starrocks: SELECT REGEXP(abc, '%foo%')", () => {
    const result = transpile("SELECT REGEXP(abc, '%foo%')", { readDialect: "starrocks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP(abc, '%foo%')");
  });
  it.todo("starrocks -> mysql: SELECT REGEXP(abc, '%foo%') (cross-dialect transform)");
});

describe("Starrocks: unnest", () => {
  it.todo("SELECT student, score, t.unnest FROM tests CROSS JOIN LATERAL UNNES... (unsupported syntax)");
  it.todo("SELECT student, score, unnest FROM tests CROSS JOIN LATERAL UNNEST(... (unsupported syntax)");
  it.todo("SELECT * FROM UNNEST(array['John','Jane','Jim','Jamie'], array[24,2... (unsupported syntax)");
  it.todo("SELECT id, t.type, t.scores FROM example_table, unnest(split(type, ... (UnsupportedError in write)");
  it.todo("SELECT id, t.type, t.scores FROM example_table_2 CROSS JOIN LATERAL... (UnsupportedError in write)");
  it.todo("test_unnest: unresolvable for-loop iterable");
});

describe("Starrocks: analyze", () => {
  it.todo("ANALYZE TABLE TBL(c1, c2) PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE FULL TABLE TBL(c1, c2) PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE SAMPLE TABLE TBL(c1, c2) PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE TABLE TBL(c1, c2) WITH SYNC MODE PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE TABLE TBL(c1, c2) WITH ASYNC MODE PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE TABLE TBL UPDATE HISTOGRAM ON c1, c2 PROPERTIES ('prop1'=val1) (command not supported)");
  it.todo("ANALYZE TABLE TBL UPDATE HISTOGRAM ON c1, c2 WITH 5 BUCKETS PROPERT... (command not supported)");
  it.todo("ANALYZE TABLE TBL UPDATE HISTOGRAM ON c1, c2 WITH SYNC MODE WITH 5 ... (command not supported)");
  it.todo("ANALYZE TABLE TBL UPDATE HISTOGRAM ON c1, c2 WITH ASYNC MODE WITH 5... (command not supported)");
});

describe("Starrocks: between", () => {
  it("starrocks -> starrocks: SELECT * FROM t WHERE a BETWEEN 1 AND 5", () => {
    const result = transpile("SELECT * FROM t WHERE a BETWEEN 1 AND 5", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SELECT * FROM t WHERE a BETWEEN 1 AND 5");
  });
  it("starrocks -> mysql: SELECT * FROM t WHERE a BETWEEN 1 AND 5", () => {
    const result = transpile("SELECT * FROM t WHERE a BETWEEN 1 AND 5", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT * FROM t WHERE a BETWEEN 1 AND 5");
  });
  it("SELECT a BETWEEN 1 AND 5 FROM t", () => {
    validateIdentity("SELECT a BETWEEN 1 AND 5 FROM t");
  });
  it.todo("DELETE FROM t WHERE a BETWEEN b AND c (DDL/DML not supported)");
  it.todo("DELETE FROM t WHERE a BETWEEN 1 AND 10 AND b BETWEEN 20 AND 30 OR c... (DDL/DML not supported)");
});

describe("Starrocks: partition", () => {
  it.todo("CREATE TABLE test_table (col1 INT, col2 DATE) PARTITION BY (col1) (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 INT, col2 DATE) PARTITION BY col1 (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 INT, col2 DATE) PARTITION BY (col1, c... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 INT, col2 DATE) PARTITION BY col1, col2 (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col2 DATE) PARTITION BY DATE_TRUNC('DAY', ... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col2 BIGINT) PARTITION BY FROM_UNIXTIME(co... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 STRING, col2 BIGINT) PARTITION BY FRO... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 BIGINT, col2 DATE) PARTITION BY FROM_... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 STRING) PARTITION BY LIST (col1) (PAR... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 DATE, col2 STRING) PARTITION BY LIST ... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 DATE) PARTITION BY RANGE (col1) (PART... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 STRING) PARTITION BY RANGE (STR2DATE(... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 DATE) PARTITION BY RANGE (col1) (PART... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE test_table (col1 BIGINT) PARTITION BY RANGE (col1) (ST... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (col1 DATE) PARTITION BY RANGE (col1) (STAR... (DDL/DML not supported)");
});
