// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "duckdb";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Duckdb: duckdb", () => {
  it.todo("TRUNC(3.14) (assert_is check)");
  it("postgres -> duckdb: TRUNC(3.14159, 2)", () => {
    const result = transpile("TRUNC(3.14159, 2)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("TRUNC(3.14159)");
  });
  it("SELECT ([1,2,3])[:-:-1] -> SELECT ([1, 2, 3])[:-1:-1]", () => {
    validateIdentity("SELECT ([1,2,3])[:-:-1]", "SELECT ([1, 2, 3])[:-1:-1]");
  });
  it.todo("SELECT INTERVAL '1 hour'::VARCHAR (unsupported syntax)");
  it.todo("PIVOT duckdb_functions() ON schema_name USING AVG(LENGTH(function_n... (unsupported clause)");
  it("SELECT str[0:1]", () => {
    validateIdentity("SELECT str[0:1]");
  });
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it("SELECT MODE(category)", () => {
    validateIdentity("SELECT MODE(category)");
  });
  it.todo("SELECT e'\\n' (unsupported syntax)");
  it.todo("SELECT e'\\t' (unsupported syntax)");
  it.todo("SELECT e'update table_name set a = \\'foo\\' where 1 = 0' AS x FROM tab (unsupported syntax)");
  it.todo("test_duckdb: assertEqual call");
  it.todo("test_duckdb: assertEqual call (2)");
  it("databricks -> duckdb: c LIKE ANY ('a', 'b') AND other_cond", () => {
    const result = transpile("c LIKE ANY ('a', 'b') AND other_cond", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("(c LIKE 'a' OR c LIKE 'b') AND other_cond");
  });
  it.todo("SELECT FIRST_VALUE(c IGNORE NULLS) OVER (PARTITION BY gb ORDER BY o... (UnsupportedError in write)");
  it.todo("SELECT FIRST_VALUE(c RESPECT NULLS) OVER (PARTITION BY gb ORDER BY ... (UnsupportedError in write)");
  it("duckdb -> bigquery: CAST(x AS UUID)", () => {
    const result = transpile("CAST(x AS UUID)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(x AS STRING)");
  });
  it("duckdb -> duckdb: CAST(x AS UUID)", () => {
    const result = transpile("CAST(x AS UUID)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS UUID)");
  });
  it.todo("SELECT APPROX_TOP_K(category, 3) FROM t (UnsupportedError in write)");
  it(`duckdb -> duckdb: SELECT CASE WHEN JSON_VALID('{"x: 1}') THEN '{"x: 1}' ELSE NULL END`, () => {
    const result = transpile(`SELECT CASE WHEN JSON_VALID('{"x: 1}') THEN '{"x: 1}' ELSE NULL END`, { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT CASE WHEN JSON_VALID('{"x: 1}') THEN '{"x: 1}' ELSE NULL END`);
  });
  it(`snowflake -> duckdb: SELECT TRY_PARSE_JSON('{"x: 1}')`, () => {
    const result = transpile(`SELECT TRY_PARSE_JSON('{"x: 1}')`, { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT CASE WHEN JSON_VALID('{"x: 1}') THEN '{"x: 1}' ELSE NULL END`);
  });
  it.todo("SELECT straight_join (unsupported syntax)");
  it.todo('STRUCT_PACK("a b" := 1) (unsupported syntax)');
  it("bigquery -> duckdb: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("postgres -> duckdb: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("presto -> duckdb: ARRAY_JOIN(arr, delim)", () => {
    const result = transpile("ARRAY_JOIN(arr, delim)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("snowflake -> duckdb: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("spark -> duckdb: ARRAY_JOIN(arr, delim)", () => {
    const result = transpile("ARRAY_JOIN(arr, delim)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("duckdb -> bigquery: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("duckdb -> duckdb: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("duckdb -> postgres: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("duckdb -> presto: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARRAY_JOIN(arr, delim)");
  });
  it("duckdb -> snowflake: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_TO_STRING(arr, delim)");
  });
  it("duckdb -> spark: ARRAY_TO_STRING(arr, delim)", () => {
    const result = transpile("ARRAY_TO_STRING(arr, delim)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ARRAY_JOIN(arr, delim)");
  });
  it.todo("duckdb -> tsql: ARRAY_TO_STRING(arr, delim) (unsupported syntax)");
  it("duckdb -> bigquery: SELECT SUM(X) OVER (ORDER BY x)", () => {
    const result = transpile("SELECT SUM(X) OVER (ORDER BY x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT SUM(X) OVER (ORDER BY x)");
  });
  it("duckdb -> duckdb: SELECT SUM(X) OVER (ORDER BY x)", () => {
    const result = transpile("SELECT SUM(X) OVER (ORDER BY x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT SUM(X) OVER (ORDER BY x)");
  });
  it("duckdb -> mysql: SELECT SUM(X) OVER (ORDER BY x)", () => {
    const result = transpile("SELECT SUM(X) OVER (ORDER BY x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT SUM(X) OVER (ORDER BY CASE WHEN x IS NULL THEN 1 ELSE 0 END, x)");
  });
  it.todo("SELECT SUM(X) OVER (ORDER BY x RANGE BETWEEN 1 PRECEDING AND CURREN... (unsupported clause)");
  it.todo("SELECT * FROM x ORDER BY 1 NULLS LAST (unsupported syntax)");
  it.todo("CREATE TEMPORARY FUNCTION f1(a, b) AS (a + b) (DDL/DML not supported)");
  it("SELECT GET_BIT(CAST('0110010' AS BIT), 2)", () => {
    validateIdentity("SELECT GET_BIT(CAST('0110010' AS BIT), 2)");
  });
  it("SELECT 1 WHERE x > $1", () => {
    validateIdentity("SELECT 1 WHERE x > $1");
  });
  it("SELECT 1 WHERE x > $name", () => {
    validateIdentity("SELECT 1 WHERE x > $name");
  });
  it(`SELECT '{"x": 1}' -> c FROM t`, () => {
    validateIdentity(`SELECT '{"x": 1}' -> c FROM t`);
  });
  it.todo("test_duckdb: assertEqual call (3)");
  it.todo("test_duckdb: assertEqual call (4)");
  it.todo("duckdb -> presto: {'a': 1, 'b': '2'} (unsupported syntax)");
  it.todo("struct_pack(a := 1, b := 2) (unsupported syntax)");
  it.todo("struct_pack(a := 1, b := x) (UnsupportedError in write)");
  it.todo("test_duckdb: unresolvable write dict");
  it("duckdb -> duckdb: SELECT * FROM t1 SEMI JOIN t2 ON t1.x = t2.x", () => {
    const result = transpile("SELECT * FROM t1 SEMI JOIN t2 ON t1.x = t2.x", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 SEMI JOIN t2 ON t1.x = t2.x");
  });
  it("spark -> duckdb: SELECT * FROM t1 LEFT SEMI JOIN t2 ON t1.x = t2.x", () => {
    const result = transpile("SELECT * FROM t1 LEFT SEMI JOIN t2 ON t1.x = t2.x", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 SEMI JOIN t2 ON t1.x = t2.x");
  });
  it.todo("test_duckdb: unresolvable write dict (2)");
  it("duckdb -> duckdb: SELECT * FROM t1 ANTI JOIN t2 ON t1.x = t2.x", () => {
    const result = transpile("SELECT * FROM t1 ANTI JOIN t2 ON t1.x = t2.x", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 ANTI JOIN t2 ON t1.x = t2.x");
  });
  it("spark -> duckdb: SELECT * FROM t1 LEFT ANTI JOIN t2 ON t1.x = t2.x", () => {
    const result = transpile("SELECT * FROM t1 LEFT ANTI JOIN t2 ON t1.x = t2.x", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 ANTI JOIN t2 ON t1.x = t2.x");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it.todo(`SELECT '{"duck": [1, 2, 3]}' -> '$.duck[#-1]' (unsupported syntax)`);
  it("duckdb -> duckdb: SELECT RANGE(1, 5)", () => {
    const result = transpile("SELECT RANGE(1, 5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RANGE(1, 5)");
  });
  it("duckdb -> spark: SELECT RANGE(1, 5)", () => {
    const result = transpile("SELECT RANGE(1, 5)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SEQUENCE(1, 4)");
  });
  it("duckdb -> duckdb: SELECT RANGE(1, 5, 2)", () => {
    const result = transpile("SELECT RANGE(1, 5, 2)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RANGE(1, 5, 2)");
  });
  it("duckdb -> spark: SELECT RANGE(1, 5, 2)", () => {
    const result = transpile("SELECT RANGE(1, 5, 2)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SEQUENCE(1, 3, 2)");
  });
  it("duckdb -> duckdb: SELECT RANGE(1, 1)", () => {
    const result = transpile("SELECT RANGE(1, 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RANGE(1, 1)");
  });
  it.todo("duckdb -> spark: SELECT RANGE(1, 1) (unsupported syntax)");
  it("duckdb -> duckdb: SELECT RANGE(5, 1, -1)", () => {
    const result = transpile("SELECT RANGE(5, 1, -1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RANGE(5, 1, -1)");
  });
  it("duckdb -> spark: SELECT RANGE(5, 1, -1)", () => {
    const result = transpile("SELECT RANGE(5, 1, -1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SEQUENCE(5, 2, -1)");
  });
  it("duckdb -> duckdb: SELECT RANGE(5, 1, 0)", () => {
    const result = transpile("SELECT RANGE(5, 1, 0)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT RANGE(5, 1, 0)");
  });
  it.todo("duckdb -> spark: SELECT RANGE(5, 1, 0) (unsupported syntax)");
  it("duckdb -> duckdb: WITH t AS (SELECT 5 AS c) SELECT RANGE(1, c) FROM t", () => {
    const result = transpile("WITH t AS (SELECT 5 AS c) SELECT RANGE(1, c) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("WITH t AS (SELECT 5 AS c) SELECT RANGE(1, c) FROM t");
  });
  it.todo("duckdb -> spark: WITH t AS (SELECT 5 AS c) SELECT RANGE(1, c) FROM t (unsupported syntax)");
  it(`duckdb -> : SELECT JSON_EXTRACT('{"duck": [1, 2, 3]}', '/duck/0')`, () => {
    const result = transpile(`SELECT JSON_EXTRACT('{"duck": [1, 2, 3]}', '/duck/0')`, { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT('{"duck": [1, 2, 3]}', '/duck/0')`);
  });
  it.todo(`duckdb -> duckdb: SELECT JSON_EXTRACT('{"duck": [1, 2, 3]}', '/duck/0') (unsupported syntax)`);
  it.todo(`SELECT JSON('{"fruit":"banana"}') -> 'fruit' (unsupported syntax)`);
  it.todo(`SELECT JSON('{"fruit": {"foo": "banana"}}') -> 'fruit' -> 'foo' (unsupported syntax)`);
  it("bigquery -> duckdb: SELECT STRUCT(column1 AS bla, column2 AS foo, column3 AS bar) AS da...", () => {
    const result = transpile("SELECT STRUCT(column1 AS bla, column2 AS foo, column3 AS bar) AS data FROM source_table", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FROM source_table");
  });
  it("duckdb -> duckdb: SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FROM ...", () => {
    const result = transpile("SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FROM source_table", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FROM source_table");
  });
  it("duckdb -> bigquery: SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FRO...", () => {
    const result = transpile("SELECT {'bla': column1, 'foo': column2, 'bar': column3} AS data FROM source_table", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT STRUCT(column1 AS bla, column2 AS foo, column3 AS bar) AS data FROM source_table");
  });
  it.todo("WITH cte(x) AS (SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) SEL... (unsupported syntax)");
  it.todo("SELECT AVG(x) FILTER (WHERE TRUE) FROM t (unsupported syntax)");
  it.todo("SELECT UNNEST(ARRAY[1, 2, 3]), UNNEST(ARRAY[4, 5]), UNNEST(ARRAY[6]) (unsupported syntax)");
  it.todo("SELECT UNNEST(ARRAY[1, 2, 3]), UNNEST(ARRAY[4, 5]), UNNEST(ARRAY[6]... (unsupported syntax)");
  it.todo("duckdb -> bigquery: SELECT UNNEST(x) + 1 (unsupported syntax)");
  it.todo("duckdb -> bigquery: SELECT UNNEST(x) + 1 AS y (unsupported syntax)");
  it.todo("snowflake -> duckdb: SELECT DATEDIFF('day', '2020-01-01', '2025-10-12') (cross-dialect transform)");
  it.todo("SELECT DATE_DIFF('SECOND', CAST('2020-01-01' AS DATE), CAST('2025-1... (unsupported syntax)");
  it.todo("SELECT DATE_DIFF('SECOND', CAST('2020-01-01' AS DATE), CAST('2025-1... (unsupported syntax) (2)");
  it.todo("test_duckdb: assertEqual call (5)");
  it.todo("test_duckdb: assertEqual call (6)");
  it("SELECT tbl.x*1e4+tbl.y FROM tbl -> SELECT tbl.x * 1e4 + tbl.y FROM tbl", () => {
    validateIdentity("SELECT tbl.x*1e4+tbl.y FROM tbl", "SELECT tbl.x * 1e4 + tbl.y FROM tbl");
  });
  it("DAYNAME(x)", () => {
    validateIdentity("DAYNAME(x)");
  });
  it.todo("MONTHNAME(x) (unsupported syntax)");
  it("SELECT LIST_TRANSFORM([5, NULL, 6], (x, y) -> COALESCE(x, y, 0) + 1)", () => {
    validateIdentity("SELECT LIST_TRANSFORM([5, NULL, 6], (x, y) -> COALESCE(x, y, 0) + 1)");
  });
  it("SELECT LIST_TRANSFORM([5, NULL, 6], LAMBDA x, y : COALESCE(x, y, 0) + 1)", () => {
    validateIdentity("SELECT LIST_TRANSFORM([5, NULL, 6], LAMBDA x, y : COALESCE(x, y, 0) + 1)");
  });
  it("SELECT LIST_TRANSFORM(LIST_FILTER([0, 1, 2, 3, 4, 5], LAMBDA x : x % 2 = 0), LAMBDA y :...", () => {
    validateIdentity("SELECT LIST_TRANSFORM(LIST_FILTER([0, 1, 2, 3, 4, 5], LAMBDA x : x % 2 = 0), LAMBDA y : y * y)");
  });
  it(`ARG_MIN({'d': "DATE", 'ts': "TIMESTAMP", 'i': "INT", 'b': "BIGINT", 's': "VARCHAR"}, "D...`, () => {
    validateIdentity(`ARG_MIN({'d': "DATE", 'ts': "TIMESTAMP", 'i': "INT", 'b': "BIGINT", 's': "VARCHAR"}, "DOUBLE")`);
  });
  it("ARG_MAX(keyword_name, keyword_category, 3 ORDER BY keyword_name DESC)", () => {
    validateIdentity("ARG_MAX(keyword_name, keyword_category, 3 ORDER BY keyword_name DESC)");
  });
  it.todo("INSERT INTO t DEFAULT VALUES RETURNING (c1) (DDL/DML not supported)");
  it.todo("CREATE TABLE notes (watermark TEXT) (DDL/DML not supported)");
  it("SELECT LIST_TRANSFORM([5, NULL, 6], LAMBDA x : COALESCE(x, 0) + 1)", () => {
    validateIdentity("SELECT LIST_TRANSFORM([5, NULL, 6], LAMBDA x : COALESCE(x, 0) + 1)");
  });
  it("SELECT LIST_TRANSFORM(nbr, LAMBDA x : x + 1) FROM article AS a", () => {
    validateIdentity("SELECT LIST_TRANSFORM(nbr, LAMBDA x : x + 1) FROM article AS a");
  });
  it("SELECT * FROM my_ducklake.demo AT (VERSION => 2)", () => {
    validateIdentity("SELECT * FROM my_ducklake.demo AT (VERSION => 2)");
  });
  it("SELECT TO_BINARY('test')", () => {
    validateIdentity("SELECT TO_BINARY('test')");
  });
  it("SELECT UUIDV7()", () => {
    validateIdentity("SELECT UUIDV7()");
  });
  it("SELECT TRY(LOG(0))", () => {
    validateIdentity("SELECT TRY(LOG(0))");
  });
  it.todo("x::timestamp (unsupported syntax)");
  it.todo("x::timestamp without time zone (unsupported syntax)");
  it.todo("x::timestamp with time zone (unsupported syntax)");
  it("CAST(x AS FOO)", () => {
    validateIdentity("CAST(x AS FOO)");
  });
  it("'red' IN tbl.flags", () => {
    validateIdentity("'red' IN tbl.flags");
  });
  it.todo("CREATE TABLE tbl1 (u UNION(num INT, str TEXT)) (DDL/DML not supported)");
  it.todo("INSERT INTO x BY NAME SELECT 1 AS y (DDL/DML not supported)");
  it("SELECT 1 AS x UNION ALL BY NAME SELECT 2 AS x", () => {
    validateIdentity("SELECT 1 AS x UNION ALL BY NAME SELECT 2 AS x");
  });
  it("SELECT SUM(x) FILTER (x = 1) -> SELECT SUM(x) FILTER(WHERE x = 1)", () => {
    validateIdentity("SELECT SUM(x) FILTER (x = 1)", "SELECT SUM(x) FILTER(WHERE x = 1)");
  });
  it("SELECT * FROM GLOB(x)", () => {
    validateIdentity("SELECT * FROM GLOB(x)");
  });
  it("SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30])", () => {
    validateIdentity("SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30])");
  });
  it("SELECT MAP {'x': 1}", () => {
    validateIdentity("SELECT MAP {'x': 1}");
  });
  it("SELECT (MAP {'x': 1})['x']", () => {
    validateIdentity("SELECT (MAP {'x': 1})['x']");
  });
  it("SELECT df1.*, df2.* FROM df1 POSITIONAL JOIN df2", () => {
    validateIdentity("SELECT df1.*, df2.* FROM df1 POSITIONAL JOIN df2");
  });
  it("MAKE_TIMESTAMP(1992, 9, 20, 13, 34, 27.123456)", () => {
    validateIdentity("MAKE_TIMESTAMP(1992, 9, 20, 13, 34, 27.123456)");
  });
  it("MAKE_TIMESTAMP(1667810584123456)", () => {
    validateIdentity("MAKE_TIMESTAMP(1667810584123456)");
  });
  it("SELECT EPOCH_MS(10) AS t", () => {
    validateIdentity("SELECT EPOCH_MS(10) AS t");
  });
  it("SELECT MAKE_TIMESTAMP(10) AS t", () => {
    validateIdentity("SELECT MAKE_TIMESTAMP(10) AS t");
  });
  it("SELECT TO_TIMESTAMP(10) AS t", () => {
    validateIdentity("SELECT TO_TIMESTAMP(10) AS t");
  });
  it.todo("SELECT UNNEST(col, recursive := TRUE) FROM t (unsupported syntax)");
  it("VAR_POP(a)", () => {
    validateIdentity("VAR_POP(a)");
  });
  it("SELECT * FROM foo ASOF LEFT JOIN bar ON a = b", () => {
    validateIdentity("SELECT * FROM foo ASOF LEFT JOIN bar ON a = b");
  });
  it("SELECT {'a': 1} AS x", () => {
    validateIdentity("SELECT {'a': 1} AS x");
  });
  it.todo("SELECT {'a': {'b': {'c': 1}}, 'd': {'e': 2}} AS x (unsupported syntax)");
  it("SELECT {'x': 1, 'y': 2, 'z': 3}", () => {
    validateIdentity("SELECT {'x': 1, 'y': 2, 'z': 3}");
  });
  it("SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345}", () => {
    validateIdentity("SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345}");
  });
  it("SELECT ROW(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y)", () => {
    validateIdentity("SELECT ROW(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y)");
  });
  it("SELECT (x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y)", () => {
    validateIdentity("SELECT (x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y)");
  });
  it("SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a)", () => {
    validateIdentity("SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a)");
  });
  it("FROM  x SELECT x UNION SELECT 1 -> SELECT x FROM x UNION SELECT 1", () => {
    validateIdentity("FROM  x SELECT x UNION SELECT 1", "SELECT x FROM x UNION SELECT 1");
  });
  it("FROM (FROM tbl) -> SELECT * FROM (SELECT * FROM tbl)", () => {
    validateIdentity("FROM (FROM tbl)", "SELECT * FROM (SELECT * FROM tbl)");
  });
  it("FROM tbl -> SELECT * FROM tbl", () => {
    validateIdentity("FROM tbl", "SELECT * FROM tbl");
  });
  it.todo("x -> '$.family' (unsupported syntax)");
  it.todo("CREATE TABLE color (name ENUM('RED', 'GREEN', 'BLUE')) (DDL/DML not supported)");
  it("SELECT * FROM foo WHERE bar > $baz AND bla = $bob", () => {
    validateIdentity("SELECT * FROM foo WHERE bar > $baz AND bla = $bob");
  });
  it.todo("SUMMARIZE tbl (assert_is check)");
  it.todo("SUMMARIZE SELECT * FROM tbl (assert_is check)");
  it.todo("CREATE TABLE tbl_summary AS SELECT * FROM (SUMMARIZE tbl) (DDL/DML not supported)");
  it.todo("SELECT STAR(tbl, exclude := [foo]) (unsupported syntax)");
  it.todo("MERGE INTO people USING (SELECT 1 AS id, 98000.0 AS salary) AS sala... (DDL/DML not supported)");
  it.todo("MERGE INTO people USING (SELECT 1 AS id, 98000.0 AS salary) AS sala... (DDL/DML not supported) (2)");
  it.todo("SELECT species, island, COUNT(*) FROM t GROUP BY GROUPING SETS (spe... (unsupported clause)");
  it.todo("SELECT species, island, COUNT(*) FROM t GROUP BY CUBE (species), CU... (unsupported clause)");
  it.todo("SELECT species, island, COUNT(*) FROM t GROUP BY ROLLUP (species), ... (unsupported clause)");
  it.todo("SUMMARIZE TABLE 'https://blobs.duckdb.org/data/Star_Trek-Season_1.csv' (assert_is check)");
  it.todo('COPY (SELECT * FROM "input.parquet" USING SAMPLE RESERVOIR (5000 RO... (command not supported)');
  it.todo("bigquery -> duckdb: SELECT * FROM x LEFT JOIN UNNEST(y) (cross-dialect transform)");
  it.todo("duckdb -> bigquery: SELECT * FROM x LEFT JOIN UNNEST(y) ON TRUE (cross-dialect transform)");
  it("duckdb -> duckdb: SELECT * FROM x LEFT JOIN UNNEST(y) ON TRUE", () => {
    const result = transpile("SELECT * FROM x LEFT JOIN UNNEST(y) ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM x LEFT JOIN UNNEST(y) ON TRUE");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM x LEFT OUTER JOIN UNNEST(y) (cross-dialect transform)");
  it.todo("duckdb -> bigquery: SELECT * FROM x LEFT OUTER JOIN UNNEST(y) ON TRUE (cross-dialect transform)");
  it("duckdb -> duckdb: SELECT * FROM x LEFT OUTER JOIN UNNEST(y) ON TRUE", () => {
    const result = transpile("SELECT * FROM x LEFT OUTER JOIN UNNEST(y) ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM x LEFT OUTER JOIN UNNEST(y) ON TRUE");
  });
  it.todo("bigquery -> duckdb: SELECT * FROM x INNER JOIN UNNEST(y) (cross-dialect transform)");
  it.todo("duckdb -> bigquery: SELECT * FROM x INNER JOIN UNNEST(y) ON TRUE (cross-dialect transform)");
  it("duckdb -> duckdb: SELECT * FROM x INNER JOIN UNNEST(y) ON TRUE", () => {
    const result = transpile("SELECT * FROM x INNER JOIN UNNEST(y) ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM x INNER JOIN UNNEST(y) ON TRUE");
  });
  it.todo(`SELECT '{ "family": "anatidae", "species": [ "duck", "goose", "swan... (unsupported syntax)`);
  it("SELECT $$foo$$ -> SELECT 'foo'", () => {
    validateIdentity("SELECT $$foo$$", "SELECT 'foo'");
  });
  it.todo("SELECT * FROM t PIVOT(FIRST(t) AS t, FOR quarter IN ('Q1', 'Q2')) (unsupported clause)");
  it(`SELECT JSON_EXTRACT_STRING('{ "family": "anatidae", "species": [ "duck", "goose", "swan...`, () => {
    validateIdentity(`SELECT JSON_EXTRACT_STRING('{ "family": "anatidae", "species": [ "duck", "goose", "swan", null ] }', ['$.family', '$.species'])`, `SELECT '{ "family": "anatidae", "species": [ "duck", "goose", "swan", null ] }' ->> ['$.family', '$.species']`);
  });
  it("SELECT col FROM t WHERE JSON_EXTRACT_STRING(col, '$.id') NOT IN ('b') -> SELECT col FRO...", () => {
    validateIdentity("SELECT col FROM t WHERE JSON_EXTRACT_STRING(col, '$.id') NOT IN ('b')", "SELECT col FROM t WHERE NOT (col ->> '$.id') IN ('b')");
  });
  it("SELECT a, LOGICAL_OR(b) FROM foo GROUP BY a -> SELECT a, BOOL_OR(CAST(b AS BOOLEAN)) FR...", () => {
    validateIdentity("SELECT a, LOGICAL_OR(b) FROM foo GROUP BY a", "SELECT a, BOOL_OR(CAST(b AS BOOLEAN)) FROM foo GROUP BY a");
  });
  it("SELECT JSON_EXTRACT_STRING(c, '$.k1') = 'v1' -> SELECT (c ->> '$.k1') = 'v1'", () => {
    validateIdentity("SELECT JSON_EXTRACT_STRING(c, '$.k1') = 'v1'", "SELECT (c ->> '$.k1') = 'v1'");
  });
  it("SELECT JSON_EXTRACT(c, '$.k1') = 'v1' -> SELECT (c -> '$.k1') = 'v1'", () => {
    validateIdentity("SELECT JSON_EXTRACT(c, '$.k1') = 'v1'", "SELECT (c -> '$.k1') = 'v1'");
  });
  it("SELECT JSON_EXTRACT(c, '$[*].id')[0:2] -> SELECT (c -> '$[*].id')[0:2]", () => {
    validateIdentity("SELECT JSON_EXTRACT(c, '$[*].id')[0:2]", "SELECT (c -> '$[*].id')[0:2]");
  });
  it("SELECT JSON_EXTRACT_STRING(c, '$[*].id')[0:2] -> SELECT (c ->> '$[*].id')[0:2]", () => {
    validateIdentity("SELECT JSON_EXTRACT_STRING(c, '$[*].id')[0:2]", "SELECT (c ->> '$[*].id')[0:2]");
  });
  it.todo(`SELECT '{"foo": [1, 2, 3]}' -> 'foo' -> 0 (unsupported syntax)`);
  it.todo("SELECT ($$hello)'world$$) (unsupported syntax)");
  it.todo("SELECT $$foo$$ (unsupported syntax)");
  it("SELECT $tag$foo$tag$ -> SELECT 'foo'", () => {
    validateIdentity("SELECT $tag$foo$tag$", "SELECT 'foo'");
  });
  it("JSON_EXTRACT(x, '$.family') -> x -> '$.family'", () => {
    validateIdentity("JSON_EXTRACT(x, '$.family')", "x -> '$.family'");
  });
  it("JSON_EXTRACT_PATH(x, '$.family') -> x -> '$.family'", () => {
    validateIdentity("JSON_EXTRACT_PATH(x, '$.family')", "x -> '$.family'");
  });
  it("JSON_EXTRACT_STRING(x, '$.family') -> x ->> '$.family'", () => {
    validateIdentity("JSON_EXTRACT_STRING(x, '$.family')", "x ->> '$.family'");
  });
  it("JSON_EXTRACT_PATH_TEXT(x, '$.family') -> x ->> '$.family'", () => {
    validateIdentity("JSON_EXTRACT_PATH_TEXT(x, '$.family')", "x ->> '$.family'");
  });
  it.todo("SELECT NOT (data -> '$.value') (unsupported syntax)");
  it.todo("SELECT NOT (data -> '$.value.nested') (unsupported syntax)");
  it.todo("SELECT (data -> '$.value') = 1 (unsupported syntax)");
  it.todo("SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} (unsupported syntax)");
  it("SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a)", () => {
    validateIdentity("SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a)");
  });
  it.todo("PIVOT Cities ON Year IN (2000, 2010) USING SUM(Population) GROUP BY... (unsupported clause)");
  it.todo("PIVOT Cities ON Year USING SUM(Population) AS total, MAX(Population... (unsupported clause)");
  it.todo("WITH pivot_alias AS (PIVOT Cities ON Year USING SUM(Population) GRO... (unsupported clause)");
  it.todo("SELECT * FROM (PIVOT Cities ON Year USING SUM(Population) GROUP BY ... (unsupported clause)");
  it.todo("SELECT * FROM cities PIVOT(SUM(population) FOR year IN (2000, 2010,... (unsupported clause)");
  it.todo("SELECT schema_name, function_name, ROW_NUMBER() OVER my_window AS f... (unsupported clause)");
  it.todo("DATE_SUB('YEAR', col, '2020-01-01') (assert_is check)");
  it.todo("DATESUB('YEAR', col, '2020-01-01') (assert_is check)");
  it("SELECT SHA256('abc')", () => {
    validateIdentity("SELECT SHA256('abc')");
  });
  it("duckdb -> : 0b1010", () => {
    const result = transpile("0b1010", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("0 AS b1010");
  });
  it("duckdb -> : 0x1010", () => {
    const result = transpile("0x1010", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("0 AS x1010");
  });
  it.todo("x ~ y (unsupported syntax)");
  it.todo("x !~ y (unsupported syntax)");
  it("REGEXP_FULL_MATCH(x, y, 'i')", () => {
    validateIdentity("REGEXP_FULL_MATCH(x, y, 'i')");
  });
  it("duckdb -> duckdb: SELECT * FROM 'x.y'", () => {
    const result = transpile("SELECT * FROM 'x.y'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe('SELECT * FROM "x.y"');
  });
  it("duckdb -> duckdb: SELECT LIST(DISTINCT sample_col) FROM sample_table", () => {
    const result = transpile("SELECT LIST(DISTINCT sample_col) FROM sample_table", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LIST(DISTINCT sample_col) FROM sample_table");
  });
  it("spark -> duckdb: SELECT COLLECT_SET(sample_col) FROM sample_table", () => {
    const result = transpile("SELECT COLLECT_SET(sample_col) FROM sample_table", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LIST(DISTINCT sample_col) FROM sample_table");
  });
  it("duckdb -> duckdb: SELECT LIST_TRANSFORM(STR_SPLIT_REGEX('abc , dfg ', ','), x -> TRIM(x))", () => {
    const result = transpile("SELECT LIST_TRANSFORM(STR_SPLIT_REGEX('abc , dfg ', ','), x -> TRIM(x))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LIST_TRANSFORM(STR_SPLIT_REGEX('abc , dfg ', ','), x -> TRIM(x))");
  });
  it("duckdb -> spark: SELECT LIST_TRANSFORM(STR_SPLIT_REGEX('abc , dfg ', ','), x -> TRIM(x))", () => {
    const result = transpile("SELECT LIST_TRANSFORM(STR_SPLIT_REGEX('abc , dfg ', ','), x -> TRIM(x))", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT TRANSFORM(SPLIT('abc , dfg ', ','), x -> TRIM(x))");
  });
  it("duckdb -> duckdb: SELECT LIST_FILTER([4, 5, 6], x -> x > 4)", () => {
    const result = transpile("SELECT LIST_FILTER([4, 5, 6], x -> x > 4)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LIST_FILTER([4, 5, 6], x -> x > 4)");
  });
  it.todo("duckdb -> spark: SELECT LIST_FILTER([4, 5, 6], x -> x > 4) (unsupported syntax)");
  it("duckdb -> duckdb: ARRAY_COMPACT([1, NULL, 2, NULL, 3])", () => {
    const result = transpile("ARRAY_COMPACT([1, NULL, 2, NULL, 3])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER([1, NULL, 2, NULL, 3], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_COMPACT([1, NULL, 2, NULL, 3])", () => {
    const result = transpile("ARRAY_COMPACT([1, NULL, 2, NULL, 3])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_COMPACT([1, NULL, 2, NULL, 3])");
  });
  it("duckdb -> duckdb: ARRAY_COMPACT(NULL)", () => {
    const result = transpile("ARRAY_COMPACT(NULL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER(NULL, _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_COMPACT(NULL)", () => {
    const result = transpile("ARRAY_COMPACT(NULL)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_COMPACT(NULL)");
  });
  it("duckdb -> duckdb: ARRAY_COMPACT([])", () => {
    const result = transpile("ARRAY_COMPACT([])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER([], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_COMPACT([])", () => {
    const result = transpile("ARRAY_COMPACT([])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_COMPACT([])");
  });
  it("duckdb -> duckdb: ARRAY_COMPACT(['a', NULL, 'b', NULL, 'c'])", () => {
    const result = transpile("ARRAY_COMPACT(['a', NULL, 'b', NULL, 'c'])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER(['a', NULL, 'b', NULL, 'c'], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_COMPACT(['a', NULL, 'b', NULL, 'c'])", () => {
    const result = transpile("ARRAY_COMPACT(['a', NULL, 'b', NULL, 'c'])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_COMPACT(['a', NULL, 'b', NULL, 'c'])");
  });
  it("duckdb -> duckdb: ARRAY_COMPACT([[1, 2], NULL, [3, 4]])", () => {
    const result = transpile("ARRAY_COMPACT([[1, 2], NULL, [3, 4]])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER([[1, 2], NULL, [3, 4]], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_COMPACT([[1, 2], NULL, [3, 4]])", () => {
    const result = transpile("ARRAY_COMPACT([[1, 2], NULL, [3, 4]])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_COMPACT([[1, 2], NULL, [3, 4]])");
  });
  it("duckdb -> duckdb: ARRAY_CONSTRUCT_COMPACT(1, 2, 3, 4, 5)", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT(1, 2, 3, 4, 5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER([1, 2, 3, 4, 5], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_CONSTRUCT_COMPACT(1, 2, 3, 4, 5)", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT(1, 2, 3, 4, 5)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CONSTRUCT_COMPACT(1, 2, 3, 4, 5)");
  });
  it("duckdb -> duckdb: ARRAY_CONSTRUCT_COMPACT()", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER([], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_CONSTRUCT_COMPACT()", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CONSTRUCT_COMPACT()");
  });
  it("duckdb -> duckdb: ARRAY_CONSTRUCT_COMPACT('a', NULL, 'b', NULL, 'c')", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT('a', NULL, 'b', NULL, 'c')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_FILTER(['a', NULL, 'b', NULL, 'c'], _u -> NOT _u IS NULL)");
  });
  it("duckdb -> snowflake: ARRAY_CONSTRUCT_COMPACT('a', NULL, 'b', NULL, 'c')", () => {
    const result = transpile("ARRAY_CONSTRUCT_COMPACT('a', NULL, 'b', NULL, 'c')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CONSTRUCT_COMPACT('a', NULL, 'b', NULL, 'c')");
  });
  it("duckdb -> duckdb: SELECT ANY_VALUE(sample_column) FROM sample_table", () => {
    const result = transpile("SELECT ANY_VALUE(sample_column) FROM sample_table", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ANY_VALUE(sample_column) FROM sample_table");
  });
  it.todo("duckdb -> spark: SELECT ANY_VALUE(sample_column) FROM sample_table (cross-dialect transform)");
  it("duckdb -> duckdb: COUNT_IF(x)", () => {
    const result = transpile("COUNT_IF(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("COUNT_IF(x)");
  });
  it("duckdb -> duckdb, version=1.0: COUNT_IF(x)", () => {
    const result = transpile("COUNT_IF(x)", { readDialect: DIALECT, writeDialect: "duckdb, version=1.0" })[0];
    expect(result).toBe("SUM(CASE WHEN x THEN 1 ELSE 0 END)");
  });
  it("duckdb -> duckdb, version=1.2: COUNT_IF(x)", () => {
    const result = transpile("COUNT_IF(x)", { readDialect: DIALECT, writeDialect: "duckdb, version=1.2" })[0];
    expect(result).toBe("COUNT_IF(x)");
  });
  it.todo("SELECT STRFTIME(CAST('2020-01-01' AS TIMESTAMP), CONCAT('%Y', '%m')) (unsupported syntax)");
  it.todo(`duckdb -> duckdb: SELECT '{"x": 1}'::JSON (unsupported syntax)`);
  it.todo(`postgres -> duckdb: SELECT '{"x": 1}'::JSONB (unsupported syntax)`);
  it.todo("SELECT * FROM produce PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2')) (unsupported clause)");
  it("duckdb -> duckdb: SELECT UNNEST([1, 2, 3])", () => {
    const result = transpile("SELECT UNNEST([1, 2, 3])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT UNNEST([1, 2, 3])");
  });
  it.todo("duckdb -> snowflake: SELECT UNNEST([1, 2, 3]) (cross-dialect transform)");
  it.todo(" -> duckdb: VARIANCE_POP(x) (cross-dialect transform)");
  it.todo("duckdb -> : VAR_POP(x) (cross-dialect transform)");
  it("duckdb -> duckdb: VAR_POP(x)", () => {
    const result = transpile("VAR_POP(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("VAR_POP(x)");
  });
  it("duckdb -> duckdb: DATE_DIFF('day', CAST(b AS DATE), CAST(a AS DATE))", () => {
    const result = transpile("DATE_DIFF('day', CAST(b AS DATE), CAST(a AS DATE))", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_DIFF('DAY', CAST(b AS DATE), CAST(a AS DATE))");
  });
  it.todo("hive -> duckdb: DATEDIFF(a, b) (cross-dialect transform)");
  it.todo("spark -> duckdb: DATEDIFF(a, b) (cross-dialect transform)");
  it.todo("spark2 -> duckdb: DATEDIFF(a, b) (cross-dialect transform)");
  it.todo("XOR(a, b) (unsupported syntax)");
  it.todo("duckdb -> duckdb: PIVOT_WIDER Cities ON Year USING SUM(Population) (unsupported clause)");
  it("duckdb -> duckdb: WITH t AS (SELECT 1) FROM t", () => {
    const result = transpile("WITH t AS (SELECT 1) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("WITH t AS (SELECT 1) SELECT * FROM t");
  });
  it("duckdb -> duckdb: WITH t AS (SELECT 1) SELECT * FROM (FROM t)", () => {
    const result = transpile("WITH t AS (SELECT 1) SELECT * FROM (FROM t)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("WITH t AS (SELECT 1) SELECT * FROM (SELECT * FROM t)");
  });
  it(`duckdb -> duckdb: SELECT DATEDIFF('day', t1."A", t1."B") FROM "table" AS t1`, () => {
    const result = transpile(`SELECT DATEDIFF('day', t1."A", t1."B") FROM "table" AS t1`, { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`SELECT DATE_DIFF('DAY', t1."A", t1."B") FROM "table" AS t1`);
  });
  it.todo(`duckdb -> trino: SELECT DATEDIFF('day', t1."A", t1."B") FROM "table" AS t1 (cross-dialect transform)`);
  it.todo("SELECT DATE_DIFF('day', DATE '2020-01-01', DATE '2020-01-05') (unsupported syntax)");
  it("duckdb -> duckdb: WITH 'x' AS (SELECT 1) SELECT * FROM x", () => {
    const result = transpile("WITH 'x' AS (SELECT 1) SELECT * FROM x", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe('WITH "x" AS (SELECT 1) SELECT * FROM x');
  });
  it.todo("CREATE TABLE IF NOT EXISTS t (cola INT, colb STRING) USING ICEBERG ... (DDL/DML not supported)");
  it.todo("CREATE TABLE IF NOT EXISTS t (cola INT COMMENT 'cola', colb STRING)... (DDL/DML not supported)");
  it.todo("spark -> duckdb: ARRAY(0, 1, 2) (unsupported syntax)");
  it("duckdb -> bigquery: [0, 1, 2]", () => {
    const result = transpile("[0, 1, 2]", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("[0, 1, 2]");
  });
  it("duckdb -> duckdb: [0, 1, 2]", () => {
    const result = transpile("[0, 1, 2]", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("[0, 1, 2]");
  });
  it.todo("duckdb -> presto: [0, 1, 2] (unsupported syntax)");
  it.todo("duckdb -> spark: [0, 1, 2] (unsupported syntax)");
  it("duckdb -> duckdb: SELECT ARRAY_LENGTH([0], 1) AS x", () => {
    const result = transpile("SELECT ARRAY_LENGTH([0], 1) AS x", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARRAY_LENGTH([0], 1) AS x");
  });
  it("REGEXP_REPLACE(this, pattern, replacement, modifiers)", () => {
    validateIdentity("REGEXP_REPLACE(this, pattern, replacement, modifiers)");
  });
  it("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table", () => {
    validateIdentity("SELECT NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("SELECT NTH_VALUE(is_deleted, 2 IGNORE NULLS) OVER (PARTITION BY id) AS nth_is_deleted F...", () => {
    validateIdentity("SELECT NTH_VALUE(is_deleted, 2 IGNORE NULLS) OVER (PARTITION BY id) AS nth_is_deleted FROM my_table");
  });
  it("duckdb -> duckdb: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_MATCHES(x, y)");
  });
  it("duckdb -> presto: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_LIKE(x, y)");
  });
  it("duckdb -> hive: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x RLIKE y");
  });
  it("duckdb -> spark: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x RLIKE y");
  });
  it("duckdb -> duckdb: STR_SPLIT(x, 'a')", () => {
    const result = transpile("STR_SPLIT(x, 'a')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STR_SPLIT(x, 'a')");
  });
  it("duckdb -> presto: STR_SPLIT(x, 'a')", () => {
    const result = transpile("STR_SPLIT(x, 'a')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SPLIT(x, 'a')");
  });
  it.todo("duckdb -> hive: STR_SPLIT(x, 'a') (unsupported syntax)");
  it.todo("duckdb -> spark: STR_SPLIT(x, 'a') (unsupported syntax)");
  it.todo("STRING_TO_ARRAY(x, 'a') (unsupported syntax)");
  it("duckdb -> duckdb: STR_SPLIT_REGEX(x, 'a')", () => {
    const result = transpile("STR_SPLIT_REGEX(x, 'a')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STR_SPLIT_REGEX(x, 'a')");
  });
  it("duckdb -> presto: STR_SPLIT_REGEX(x, 'a')", () => {
    const result = transpile("STR_SPLIT_REGEX(x, 'a')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_SPLIT(x, 'a')");
  });
  it("duckdb -> hive: STR_SPLIT_REGEX(x, 'a')", () => {
    const result = transpile("STR_SPLIT_REGEX(x, 'a')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SPLIT(x, 'a')");
  });
  it("duckdb -> spark: STR_SPLIT_REGEX(x, 'a')", () => {
    const result = transpile("STR_SPLIT_REGEX(x, 'a')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SPLIT(x, 'a')");
  });
  it("duckdb -> duckdb: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRUCT_EXTRACT(x, 'abc')");
  });
  it("duckdb -> presto: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("x.abc");
  });
  it("duckdb -> hive: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x.abc");
  });
  it("duckdb -> postgres: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("x.abc");
  });
  it("duckdb -> redshift: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("x.abc");
  });
  it("duckdb -> spark: STRUCT_EXTRACT(x, 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(x, 'abc')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x.abc");
  });
  it("duckdb -> duckdb: STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')");
  });
  it("duckdb -> presto: STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("x.y.abc");
  });
  it("duckdb -> hive: STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x.y.abc");
  });
  it("duckdb -> spark: STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", () => {
    const result = transpile("STRUCT_EXTRACT(STRUCT_EXTRACT(x, 'y'), 'abc')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x.y.abc");
  });
  it("duckdb -> duckdb: QUANTILE(x, 0.5)", () => {
    const result = transpile("QUANTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("QUANTILE(x, 0.5)");
  });
  it("duckdb -> presto: QUANTILE(x, 0.5)", () => {
    const result = transpile("QUANTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("APPROX_PERCENTILE(x, 0.5)");
  });
  it("duckdb -> hive: QUANTILE(x, 0.5)", () => {
    const result = transpile("QUANTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("duckdb -> spark: QUANTILE(x, 0.5)", () => {
    const result = transpile("QUANTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it.todo("spark -> duckdb: EXPLODE(x) (cross-dialect transform)");
  it("duckdb -> duckdb: UNNEST(x)", () => {
    const result = transpile("UNNEST(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("UNNEST(x)");
  });
  it.todo("duckdb -> spark: UNNEST(x) (cross-dialect transform)");
  it("duckdb -> duckdb: 1d", () => {
    const result = transpile("1d", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("1 AS d");
  });
  it("duckdb -> spark: 1d", () => {
    const result = transpile("1d", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("1 AS d");
  });
  it("hive -> duckdb: POW(2S, 3)", () => {
    const result = transpile("POW(2S, 3)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("POWER(TRY_CAST(2 AS SMALLINT), 3)");
  });
  it("spark -> duckdb: POW(2S, 3)", () => {
    const result = transpile("POW(2S, 3)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("POWER(TRY_CAST(2 AS SMALLINT), 3)");
  });
  it.todo("spark -> duckdb: ARRAY_SUM(ARRAY(1, 2)) (unsupported syntax)");
  it.todo("STRUCT_PACK(x := 1, y := '2') (unsupported syntax)");
  it.todo("STRUCT_PACK(key1 := 'value1', key2 := 42) (unsupported syntax)");
  it("duckdb -> duckdb: ARRAY_REVERSE_SORT(x)", () => {
    const result = transpile("ARRAY_REVERSE_SORT(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_REVERSE_SORT(x)");
  });
  it("duckdb -> presto: ARRAY_REVERSE_SORT(x)", () => {
    const result = transpile("ARRAY_REVERSE_SORT(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARRAY_SORT(x, (a, b) -> CASE WHEN a < b THEN 1 WHEN a > b THEN -1 ELSE 0 END)");
  });
  it.todo("duckdb -> hive: ARRAY_REVERSE_SORT(x) (unsupported syntax)");
  it.todo("duckdb -> spark: ARRAY_REVERSE_SORT(x) (unsupported syntax)");
  it("duckdb -> duckdb: LIST_REVERSE_SORT(x)", () => {
    const result = transpile("LIST_REVERSE_SORT(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_REVERSE_SORT(x)");
  });
  it("duckdb -> presto: LIST_REVERSE_SORT(x)", () => {
    const result = transpile("LIST_REVERSE_SORT(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARRAY_SORT(x, (a, b) -> CASE WHEN a < b THEN 1 WHEN a > b THEN -1 ELSE 0 END)");
  });
  it.todo("duckdb -> hive: LIST_REVERSE_SORT(x) (unsupported syntax)");
  it.todo("duckdb -> spark: LIST_REVERSE_SORT(x) (unsupported syntax)");
  it("duckdb -> duckdb: LIST_SORT(x)", () => {
    const result = transpile("LIST_SORT(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_SORT(x)");
  });
  it("duckdb -> presto: LIST_SORT(x)", () => {
    const result = transpile("LIST_SORT(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARRAY_SORT(x)");
  });
  it.todo("duckdb -> hive: LIST_SORT(x) (unsupported syntax)");
  it.todo("duckdb -> spark: LIST_SORT(x) (unsupported syntax)");
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it("duckdb -> duckdb: MONTH('2021-03-01')", () => {
    const result = transpile("MONTH('2021-03-01')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MONTH('2021-03-01')");
  });
  it("duckdb -> presto: MONTH('2021-03-01')", () => {
    const result = transpile("MONTH('2021-03-01')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("MONTH('2021-03-01')");
  });
  it("duckdb -> hive: MONTH('2021-03-01')", () => {
    const result = transpile("MONTH('2021-03-01')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("MONTH('2021-03-01')");
  });
  it("duckdb -> spark: MONTH('2021-03-01')", () => {
    const result = transpile("MONTH('2021-03-01')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("MONTH('2021-03-01')");
  });
  it("bigquery -> duckdb: ARRAY_CONCAT([1, 2], [3, 4])", () => {
    const result = transpile("ARRAY_CONCAT([1, 2], [3, 4])", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("LIST_CONCAT([1, 2], [3, 4])");
  });
  it.todo("postgres -> duckdb: ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4]) (unsupported syntax)");
  it("snowflake -> duckdb: ARRAY_CAT([1, 2], [3, 4])", () => {
    const result = transpile("ARRAY_CAT([1, 2], [3, 4])", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("LIST_CONCAT([1, 2], [3, 4])");
  });
  it("duckdb -> bigquery: LIST_CONCAT([1, 2], [3, 4])", () => {
    const result = transpile("LIST_CONCAT([1, 2], [3, 4])", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("ARRAY_CONCAT([1, 2], [3, 4])");
  });
  it("duckdb -> duckdb: LIST_CONCAT([1, 2], [3, 4])", () => {
    const result = transpile("LIST_CONCAT([1, 2], [3, 4])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LIST_CONCAT([1, 2], [3, 4])");
  });
  it.todo("duckdb -> hive: LIST_CONCAT([1, 2], [3, 4]) (unsupported syntax)");
  it.todo("duckdb -> postgres: LIST_CONCAT([1, 2], [3, 4]) (unsupported syntax)");
  it.todo("duckdb -> presto: LIST_CONCAT([1, 2], [3, 4]) (unsupported syntax)");
  it("duckdb -> snowflake: LIST_CONCAT([1, 2], [3, 4])", () => {
    const result = transpile("LIST_CONCAT([1, 2], [3, 4])", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CAT([1, 2], [3, 4])");
  });
  it.todo("duckdb -> spark: LIST_CONCAT([1, 2], [3, 4]) (unsupported syntax)");
  it.todo("hive -> duckdb: SELECT DATE_ADD(TO_DATE(x), 1) (cross-dialect transform)");
  it("hive -> duckdb: SELECT DATE_ADD('2018-01-01 00:00:00', 3)", () => {
    const result = transpile("SELECT DATE_ADD('2018-01-01 00:00:00', 3)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('2018-01-01 00:00:00' AS DATE) + INTERVAL 3 DAY");
  });
  it.todo("duckdb -> duckdb: SELECT CAST('2018-01-01 00:00:00' AS DATE) + INTERVAL 3 DAY (unsupported syntax)");
  it.todo("duckdb -> hive: SELECT CAST('2018-01-01 00:00:00' AS DATE) + INTERVAL 3 DAY (unsupported syntax)");
  it.todo("SELECT CAST('2020-05-06' AS DATE) - INTERVAL '5' DAY (unsupported syntax)");
  it.todo("SELECT CAST('2020-05-06' AS DATE) + INTERVAL '5' DAY (unsupported syntax)");
  it.todo("SELECT PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY y DESC) FROM t (unsupported clause)");
  it.todo("SELECT PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY y DESC) FROM t (unsupported clause)");
  it("duckdb -> duckdb: SELECT QUANTILE_CONT(x, q) FROM t", () => {
    const result = transpile("SELECT QUANTILE_CONT(x, q) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT QUANTILE_CONT(x, q) FROM t");
  });
  it.todo("duckdb -> postgres: SELECT QUANTILE_CONT(x, q) FROM t (unsupported clause)");
  it.todo("duckdb -> snowflake: SELECT QUANTILE_CONT(x, q) FROM t (unsupported clause)");
  it("duckdb -> duckdb: SELECT QUANTILE_DISC(x, q) FROM t", () => {
    const result = transpile("SELECT QUANTILE_DISC(x, q) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT QUANTILE_DISC(x, q) FROM t");
  });
  it.todo("duckdb -> postgres: SELECT QUANTILE_DISC(x, q) FROM t (unsupported clause)");
  it.todo("duckdb -> snowflake: SELECT QUANTILE_DISC(x, q) FROM t (unsupported clause)");
  it.todo("SELECT REGEXP_EXTRACT(a, 'pattern') FROM t (unsupported syntax)");
  it.todo("SELECT REGEXP_EXTRACT(a, 'pattern', 2, 'i') FROM t (unsupported syntax)");
  it.todo("SELECT REGEXP_EXTRACT(a, 'pattern', 0) (unsupported syntax)");
  it.todo("SELECT REGEXP_EXTRACT(a, 'pattern', 0, 'i') (unsupported syntax)");
  it.todo("SELECT REGEXP_EXTRACT(a, 'pattern', 1, 'i') (unsupported syntax)");
  it("SELECT ISNAN(x)", () => {
    validateIdentity("SELECT ISNAN(x)");
  });
  it("duckdb -> duckdb: SELECT COUNT_IF(x)", () => {
    const result = transpile("SELECT COUNT_IF(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT COUNT_IF(x)");
  });
  it("duckdb -> bigquery: SELECT COUNT_IF(x)", () => {
    const result = transpile("SELECT COUNT_IF(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT COUNTIF(x)");
  });
  it("SELECT * FROM RANGE(1, 5, 10)", () => {
    validateIdentity("SELECT * FROM RANGE(1, 5, 10)");
  });
  it.todo("SELECT * FROM GENERATE_SERIES(2, 13, 4) (unsupported syntax)");
  it("duckdb -> duckdb: WITH t AS (SELECT i, i * i * i * i * i AS i5 FROM RANGE(1, 5) t(i)) S...", () => {
    const result = transpile("WITH t AS (SELECT i, i * i * i * i * i AS i5 FROM RANGE(1, 5) t(i)) SELECT * FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("WITH t AS (SELECT i, i * i * i * i * i AS i5 FROM RANGE(1, 5) AS t(i)) SELECT * FROM t");
  });
  it.todo("duckdb -> sqlite: WITH t AS (SELECT i, i * i * i * i * i AS i5 FROM RANGE(1, 5) t(i)) S... (unsupported syntax)");
  it("SELECT i FROM RANGE(5) AS _(i) ORDER BY i ASC -> SELECT i FROM RANGE(0, 5) AS _(i) ORDE...", () => {
    validateIdentity("SELECT i FROM RANGE(5) AS _(i) ORDER BY i ASC", "SELECT i FROM RANGE(0, 5) AS _(i) ORDER BY i ASC");
  });
  it.todo("SELECT i FROM GENERATE_SERIES(12) AS _(i) ORDER BY i ASC (unsupported syntax)");
  it.todo("COPY lineitem FROM 'lineitem.ndjson' WITH (FORMAT JSON, DELIMITER '... (command not supported)");
  it.todo("COPY (SELECT 42 AS a, 'hello' AS b) TO 'query.json' WITH (FORMAT JS... (command not supported)");
  it.todo("COPY lineitem (l_orderkey) TO 'orderkey.tbl' WITH (DELIMITER '|') (command not supported)");
  it("duckdb -> duckdb: VARIANCE(a)", () => {
    const result = transpile("VARIANCE(a)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("VARIANCE(a)");
  });
  it.todo("duckdb -> clickhouse: VARIANCE(a) (cross-dialect transform)");
  it("duckdb -> duckdb: STDDEV(a)", () => {
    const result = transpile("STDDEV(a)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STDDEV(a)");
  });
  it("duckdb -> clickhouse: STDDEV(a)", () => {
    const result = transpile("STDDEV(a)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("stddevSamp(a)");
  });
  it("duckdb -> duckdb: DATE_TRUNC('DAY', x)", () => {
    const result = transpile("DATE_TRUNC('DAY', x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('DAY', x)");
  });
  it("duckdb -> clickhouse: DATE_TRUNC('DAY', x)", () => {
    const result = transpile("DATE_TRUNC('DAY', x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("dateTrunc('DAY', x)");
  });
  it("EDITDIST3(col1, col2) -> LEVENSHTEIN(col1, col2)", () => {
    validateIdentity("EDITDIST3(col1, col2)", "LEVENSHTEIN(col1, col2)");
  });
  it("JARO_WINKLER_SIMILARITY('hello', 'world')", () => {
    validateIdentity("JARO_WINKLER_SIMILARITY('hello', 'world')");
  });
  it("SELECT LENGTH(foo)", () => {
    validateIdentity("SELECT LENGTH(foo)");
  });
  it.todo("SELECT ARRAY[1, 2, 3] (unsupported syntax)");
  it("SELECT * FROM (DESCRIBE t)", () => {
    validateIdentity("SELECT * FROM (DESCRIBE t)");
  });
  it("SELECT UNNEST([*COLUMNS('alias_.*')]) AS column_name", () => {
    validateIdentity("SELECT UNNEST([*COLUMNS('alias_.*')]) AS column_name");
  });
  it("SELECT COALESCE(*COLUMNS(*)) FROM (SELECT NULL, 2, 3) AS t(a, b, c)", () => {
    validateIdentity("SELECT COALESCE(*COLUMNS(*)) FROM (SELECT NULL, 2, 3) AS t(a, b, c)");
  });
  it("SELECT id, STRUCT_PACK(*COLUMNS('m\\d')) AS measurements FROM many_measurements -> SELEC...", () => {
    validateIdentity("SELECT id, STRUCT_PACK(*COLUMNS('m\\d')) AS measurements FROM many_measurements", "SELECT id, {'_0': *COLUMNS('m\\d')} AS measurements FROM many_measurements");
  });
  it("SELECT COLUMNS(c -> c LIKE '%num%') FROM numbers", () => {
    validateIdentity("SELECT COLUMNS(c -> c LIKE '%num%') FROM numbers");
  });
  it("SELECT MIN(COLUMNS(* REPLACE (number + id AS number))), COUNT(COLUMNS(* EXCLUDE (number...", () => {
    validateIdentity("SELECT MIN(COLUMNS(* REPLACE (number + id AS number))), COUNT(COLUMNS(* EXCLUDE (number))) FROM numbers");
  });
  it("SELECT COLUMNS(*) + COLUMNS(*) FROM numbers", () => {
    validateIdentity("SELECT COLUMNS(*) + COLUMNS(*) FROM numbers");
  });
  it("SELECT COLUMNS('(id|numbers?)') FROM numbers", () => {
    validateIdentity("SELECT COLUMNS('(id|numbers?)') FROM numbers");
  });
  it("SELECT COALESCE(COLUMNS(['a', 'b', 'c'])) AS result FROM (SELECT NULL AS a, 42 AS b, TR...", () => {
    validateIdentity("SELECT COALESCE(COLUMNS(['a', 'b', 'c'])) AS result FROM (SELECT NULL AS a, 42 AS b, TRUE AS c)");
  });
  it("SELECT COALESCE(*COLUMNS(['a', 'b', 'c'])) AS result FROM (SELECT NULL AS a, 42 AS b, T...", () => {
    validateIdentity("SELECT COALESCE(*COLUMNS(['a', 'b', 'c'])) AS result FROM (SELECT NULL AS a, 42 AS b, TRUE AS c)");
  });
  it.todo("SELECT UNNEST(foo) AS x (UnsupportedError in write)");
  it.todo("a ^ b (unsupported syntax)");
  it("a ** b -> POWER(a, b)", () => {
    validateIdentity("a ** b", "POWER(a, b)");
  });
  it.todo("a ~~~ b (unsupported syntax)");
  it.todo("a ~~ b (unsupported syntax)");
  it("a @> b", () => {
    validateIdentity("a @> b");
  });
  it("a <@ b -> b @> a", () => {
    validateIdentity("a <@ b", "b @> a");
  });
  it.todo("a && b (assert_is check)");
  it("a ^@ b -> STARTS_WITH(a, b)", () => {
    validateIdentity("a ^@ b", "STARTS_WITH(a, b)");
  });
  it.todo("a !~~ b (unsupported syntax)");
  it.todo("a !~~* b (unsupported syntax)");
  it.todo("SELECT e'Hello\nworld' (unsupported syntax)");
  it.todo("postgres -> duckdb: SELECT 'ThOmAs' ~* 'thomas' (unsupported syntax)");
  it.todo("SELECT DATE_ADD(CAST('2020-01-01' AS DATE), INTERVAL 1 DAY) (unsupported syntax)");
  it("ARRAY_SLICE(x, 1, 3, 2)", () => {
    validateIdentity("ARRAY_SLICE(x, 1, 3, 2)");
  });
  it.todo("SELECT #2, #1 FROM (VALUES (1, 'foo')) (unsupported syntax)");
  it.todo("SELECT #2 AS a, #1 AS b FROM (VALUES (1, 'foo')) (unsupported syntax)");
  it("duckdb -> duckdb: LIST_CONTAINS([1, 2, NULL], 1)", () => {
    const result = transpile("LIST_CONTAINS([1, 2, NULL], 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_CONTAINS([1, 2, NULL], 1)");
  });
  it.todo("duckdb -> postgres: LIST_CONTAINS([1, 2, NULL], 1) (unsupported syntax)");
  it("duckdb -> duckdb: LIST_CONTAINS([1, 2, NULL], NULL)", () => {
    const result = transpile("LIST_CONTAINS([1, 2, NULL], NULL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_CONTAINS([1, 2, NULL], NULL)");
  });
  it.todo("duckdb -> postgres: LIST_CONTAINS([1, 2, NULL], NULL) (unsupported syntax)");
  it("duckdb -> duckdb: LIST_HAS_ANY([1, 2, 3], [1,2])", () => {
    const result = transpile("LIST_HAS_ANY([1, 2, 3], [1,2])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("[1, 2, 3] && [1, 2]");
  });
  it.todo("duckdb -> postgres: LIST_HAS_ANY([1, 2, 3], [1,2]) (unsupported syntax)");
  it("LISTAGG(x, ', ')", () => {
    validateIdentity("LISTAGG(x, ', ')");
  });
  it.todo("STRING_AGG(x, ', ') (unsupported syntax)");
  it("duckdb -> duckdb: SELECT CONCAT(foo)", () => {
    const result = transpile("SELECT CONCAT(foo)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CONCAT(foo)");
  });
  it.todo("duckdb -> spark: SELECT CONCAT(foo) (cross-dialect transform)");
  it("duckdb -> duckdb: SELECT CONCAT(COALESCE(['abc'], []), ['bcg'])", () => {
    const result = transpile("SELECT CONCAT(COALESCE(['abc'], []), ['bcg'])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CONCAT(COALESCE(['abc'], []), ['bcg'])");
  });
  it.todo("duckdb -> spark: SELECT CONCAT(COALESCE(['abc'], []), ['bcg']) (unsupported syntax)");
  it("SELECT CUME_DIST( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)", () => {
    validateIdentity("SELECT CUME_DIST( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)");
  });
  it("SELECT NTILE(1 ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)", () => {
    validateIdentity("SELECT NTILE(1 ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)");
  });
  it("SELECT RANK( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)", () => {
    validateIdentity("SELECT RANK( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)");
  });
  it("SELECT PERCENT_RANK( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)", () => {
    validateIdentity("SELECT PERCENT_RANK( ORDER BY foo) OVER (ORDER BY 1) FROM (SELECT 1 AS foo)");
  });
  it("LIST_COSINE_DISTANCE(x, y)", () => {
    validateIdentity("LIST_COSINE_DISTANCE(x, y)");
  });
  it("LIST_DISTANCE(x, y)", () => {
    validateIdentity("LIST_DISTANCE(x, y)");
  });
  it("SELECT * FROM t LIMIT 10 PERCENT", () => {
    validateIdentity("SELECT * FROM t LIMIT 10 PERCENT");
  });
  it("SELECT * FROM t LIMIT 10% -> SELECT * FROM t LIMIT 10 PERCENT", () => {
    validateIdentity("SELECT * FROM t LIMIT 10%", "SELECT * FROM t LIMIT 10 PERCENT");
  });
  it("SELECT * FROM t LIMIT 10 PERCENT OFFSET 1", () => {
    validateIdentity("SELECT * FROM t LIMIT 10 PERCENT OFFSET 1");
  });
  it("SELECT * FROM t LIMIT 10% OFFSET 1 -> SELECT * FROM t LIMIT 10 PERCENT OFFSET 1", () => {
    validateIdentity("SELECT * FROM t LIMIT 10% OFFSET 1", "SELECT * FROM t LIMIT 10 PERCENT OFFSET 1");
  });
  it.todo("SELECT CAST(ROW(1, 2) AS ROW(a INTEGER, b INTEGER)) (unsupported syntax)");
  it("SELECT row", () => {
    validateIdentity("SELECT row");
  });
  it("SELECT TRY_STRPTIME('2013-04-28T20:57:01.123456789+07:00', '%Y-%m-%dT%H:%M:%S.%n%z')", () => {
    validateIdentity("SELECT TRY_STRPTIME('2013-04-28T20:57:01.123456789+07:00', '%Y-%m-%dT%H:%M:%S.%n%z')");
  });
  it.todo("DELETE FROM t USING (VALUES (1)) AS t1(c), (VALUES (1), (2)) AS t2(... (DDL/DML not supported)");
  it("FROM (FROM t1 UNION FROM t2) -> SELECT * FROM (SELECT * FROM t1 UNION SELECT * FROM t2)", () => {
    validateIdentity("FROM (FROM t1 UNION FROM t2)", "SELECT * FROM (SELECT * FROM t1 UNION SELECT * FROM t2)");
  });
  it("FROM (FROM (SELECT 1) AS t2(c), (SELECT t2.c AS c0)) -> SELECT * FROM (SELECT * FROM (S...", () => {
    validateIdentity("FROM (FROM (SELECT 1) AS t2(c), (SELECT t2.c AS c0))", "SELECT * FROM (SELECT * FROM (SELECT 1) AS t2(c), (SELECT t2.c AS c0))");
  });
  it("FROM (FROM (SELECT 2000 as amount) t GROUP BY amount HAVING SUM(amount) > 1000) -> SELE...", () => {
    validateIdentity("FROM (FROM (SELECT 2000 as amount) t GROUP BY amount HAVING SUM(amount) > 1000)", "SELECT * FROM (SELECT * FROM (SELECT 2000 AS amount) AS t GROUP BY amount HAVING SUM(amount) > 1000)");
  });
  it("(FROM (SELECT 1) t1(c) EXCEPT FROM (SELECT 2) t2(c)) UNION ALL (FROM (SELECT 3) t3(c) E...", () => {
    validateIdentity("(FROM (SELECT 1) t1(c) EXCEPT FROM (SELECT 2) t2(c)) UNION ALL (FROM (SELECT 3) t3(c) EXCEPT FROM (SELECT 4) t4(c))", "(SELECT * FROM (SELECT 1) AS t1(c) EXCEPT SELECT * FROM (SELECT 2) AS t2(c)) UNION ALL (SELECT * FROM (SELECT 3) AS t3(c) EXCEPT SELECT * FROM (SELECT 4) AS t4(c))");
  });
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) ORDER BY 1... (unsupported syntax)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) LIMIT 1) I... (unsupported syntax)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) OFFSET 1) ... (unsupported syntax)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) ORDER BY 1... (unsupported syntax) (2)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) ORDER BY 1... (unsupported syntax) (3)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) ORDER BY 1... (unsupported syntax) (4)");
  it.todo("SELECT 1 FROM (SELECT 1) AS t(c) WHERE ((VALUES (1), (c) LIMIT 1 OF... (unsupported syntax)");
  it("FORMAT('foo')", () => {
    validateIdentity("FORMAT('foo')");
  });
  it("FORMAT('foo', 'foo2', 'foo3')", () => {
    validateIdentity("FORMAT('foo', 'foo2', 'foo3')");
  });
  it.todo("test_duckdb: assertEqual call (7)");
  it.todo("test_duckdb: assertEqual call (8)");
  it("duckdb -> duckdb: SELECT UUID()", () => {
    const result = transpile("SELECT UUID()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT UUID()");
  });
  it("duckdb -> bigquery: SELECT UUID()", () => {
    const result = transpile("SELECT UUID()", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT GENERATE_UUID()");
  });
  it.todo("test_duckdb: assertEqual call (9)");
  it("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result", () => {
    validateIdentity("SELECT REPLACE('apple pie', 'pie', 'cobbler') AS result");
  });
  it("SELECT REPLACE(CAST(CAST('apple pie' AS BLOB) AS TEXT), CAST(CAST('pie' AS BLOB) AS TEX...", () => {
    validateIdentity("SELECT REPLACE(CAST(CAST('apple pie' AS BLOB) AS TEXT), CAST(CAST('pie' AS BLOB) AS TEXT), CAST(CAST('cobbler' AS BLOB) AS TEXT)) AS result");
  });
  it.todo("test_duckdb: assertEqual call (10)");
  it("SELECT TRIM('***apple***', '*') AS result", () => {
    validateIdentity("SELECT TRIM('***apple***', '*') AS result");
  });
  it("SELECT CAST(TRIM(CAST(CAST('***apple***' AS BLOB) AS TEXT), CAST(CAST('*' AS BLOB) AS T...", () => {
    validateIdentity("SELECT CAST(TRIM(CAST(CAST('***apple***' AS BLOB) AS TEXT), CAST(CAST('*' AS BLOB) AS TEXT)) AS BLOB) AS result");
  });
  it("SELECT GREATEST(1.0, 2.5, NULL, 3.7)", () => {
    validateIdentity("SELECT GREATEST(1.0, 2.5, NULL, 3.7)");
  });
  it("FROM t1, t2 SELECT * -> SELECT * FROM t1, t2", () => {
    validateIdentity("FROM t1, t2 SELECT *", "SELECT * FROM t1, t2");
  });
  it("ROUND(2.256, 1)", () => {
    validateIdentity("ROUND(2.256, 1)");
  });
  it("SELECT MAKE_DATE(DATE_PART(['year', 'month', 'day'], CURRENT_DATE))", () => {
    validateIdentity("SELECT MAKE_DATE(DATE_PART(['year', 'month', 'day'], CURRENT_DATE))");
  });
  it.todo("SELECT * FROM t PIVOT(SUM(y) FOR foo IN y_enum) (unsupported clause)");
  it("SELECT 20_000 AS literal", () => {
    validateIdentity("SELECT 20_000 AS literal");
  });
  it.todo("SELECT 1_2E+1_0::FLOAT (unsupported syntax)");
  it.todo("CASE WHEN 2500 > 0 THEN ((2500 - 1) // 32768) + 1 ELSE 2500 // 3276... (unsupported syntax)");
  it.todo("CASE WHEN 32768 > 0 THEN ((32768 - 1) // 32768) + 1 ELSE 32768 // 3... (unsupported syntax)");
  it.todo("CASE WHEN 32769 > 0 THEN ((32769 - 1) // 32768) + 1 ELSE 32769 // 3... (unsupported syntax)");
  it.todo("CASE WHEN -100 > 0 THEN ((-100 - 1) // 32768) + 1 ELSE -100 // 3276... (unsupported syntax)");
  it("snowflake -> duckdb: BITMAP_BUCKET_NUMBER(NULL)", () => {
    const result = transpile("BITMAP_BUCKET_NUMBER(NULL)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN NULL > 0 THEN ((NULL - 1) // 32768) + 1 ELSE NULL // 32768 END");
  });
  it("SELECT [1, 2, 3][1 + 1:LENGTH([1, 2, 3]) + -1]", () => {
    validateIdentity("SELECT [1, 2, 3][1 + 1:LENGTH([1, 2, 3]) + -1]");
  });
  it("VERSION()", () => {
    validateIdentity("VERSION()");
  });
  it("SELECT TODAY() -> SELECT CURRENT_DATE", () => {
    validateIdentity("SELECT TODAY()", "SELECT CURRENT_DATE");
  });
});

describe("Duckdb: array_index", () => {
  it("bigquery -> duckdb: SELECT some_arr[0] AS first FROM blah", () => {
    const result = transpile("SELECT some_arr[0] AS first FROM blah", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT some_arr[1] AS first FROM blah");
  });
  it("duckdb -> bigquery: SELECT some_arr[1] AS first FROM blah", () => {
    const result = transpile("SELECT some_arr[1] AS first FROM blah", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT some_arr[0] AS first FROM blah");
  });
  it("duckdb -> duckdb: SELECT some_arr[1] AS first FROM blah", () => {
    const result = transpile("SELECT some_arr[1] AS first FROM blah", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT some_arr[1] AS first FROM blah");
  });
  it("duckdb -> presto: SELECT some_arr[1] AS first FROM blah", () => {
    const result = transpile("SELECT some_arr[1] AS first FROM blah", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT some_arr[1] AS first FROM blah");
  });
  it("[x.STRING_SPLIT(' ')[i] FOR x IN ['1', '2', 3] IF x.CONTAINS('1')]", () => {
    validateIdentity("[x.STRING_SPLIT(' ')[i] FOR x IN ['1', '2', 3] IF x.CONTAINS('1')]");
  });
  it("SELECT [4, 5, 6] AS l, [x FOR x, i IN l IF i = 2] AS filtered", () => {
    validateIdentity("SELECT [4, 5, 6] AS l, [x FOR x, i IN l IF i = 2] AS filtered");
  });
  it("SELECT LIST_VALUE(1)[i] -> SELECT [1][i]", () => {
    validateIdentity("SELECT LIST_VALUE(1)[i]", "SELECT [1][i]");
  });
  it("{'x': LIST_VALUE(1)[i]} -> {'x': [1][i]}", () => {
    validateIdentity("{'x': LIST_VALUE(1)[i]}", "{'x': [1][i]}");
  });
  it("SELECT LIST_APPLY(RANGE(1, 4), i -> {'f1': LIST_VALUE(1, 2, 3)[i], 'f2': LIST_VALUE(1, ...", () => {
    validateIdentity("SELECT LIST_APPLY(RANGE(1, 4), i -> {'f1': LIST_VALUE(1, 2, 3)[i], 'f2': LIST_VALUE(1, 2, 3)[i]})", "SELECT LIST_APPLY(RANGE(1, 4), i -> {'f1': [1, 2, 3][i], 'f2': [1, 2, 3][i]})");
  });
  it.todo("test_array_index: assertEqual call");
});

describe("Duckdb: array_insert", () => {
  it(" -> duckdb: ARRAY_INSERT([1, 2, 3], 0, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 0, 99)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([99], [1, 2, 3]) END");
  });
  it("snowflake -> duckdb: ARRAY_INSERT([1, 2, 3], 0, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 0, 99)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([99], [1, 2, 3]) END");
  });
  it.todo("spark -> duckdb: ARRAY_INSERT(ARRAY(1, 2, 3), 1, 99) (unsupported syntax)");
  it(" -> duckdb: ARRAY_INSERT([1, 2, 3], 1, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 1, 99)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:1], [99], [1, 2, 3][2:]) END");
  });
  it("snowflake -> duckdb: ARRAY_INSERT([1, 2, 3], 1, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 1, 99)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:1], [99], [1, 2, 3][2:]) END");
  });
  it.todo("spark -> duckdb: ARRAY_INSERT(ARRAY(1, 2, 3), 2, 99) (unsupported syntax)");
  it(" -> duckdb: ARRAY_INSERT([1, 2, 3], 3, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 3, 99)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:3], [99], [1, 2, 3][4:]) END");
  });
  it("snowflake -> duckdb: ARRAY_INSERT([1, 2, 3], 3, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], 3, 99)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:3], [99], [1, 2, 3][4:]) END");
  });
  it.todo("spark -> duckdb: ARRAY_INSERT(ARRAY(1, 2, 3), 4, 99) (unsupported syntax)");
  it(" -> duckdb: ARRAY_INSERT([1, 2, 3], -1, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], -1, 99)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:LENGTH([1, 2, 3]) + -1], [99], [1, 2, 3][LENGTH([1, 2, 3]) + -1 + 1:]) END");
  });
  it("snowflake -> duckdb: ARRAY_INSERT([1, 2, 3], -1, 99)", () => {
    const result = transpile("ARRAY_INSERT([1, 2, 3], -1, 99)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:LENGTH([1, 2, 3]) + -1], [99], [1, 2, 3][LENGTH([1, 2, 3]) + -1 + 1:]) END");
  });
  it.todo("spark -> duckdb: ARRAY_INSERT(ARRAY(1, 2, 3), -2, 99) (unsupported syntax)");
});

describe("Duckdb: array_remove", () => {
  it("snowflake -> duckdb: ARRAY_REMOVE(the_array, target)", () => {
    const result = transpile("ARRAY_REMOVE(the_array, target)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN target IS NULL THEN NULL ELSE LIST_FILTER(the_array, _u -> _u <> target) END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE([1, 2, 3], 2)", () => {
    const result = transpile("ARRAY_REMOVE([1, 2, 3], 2)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("LIST_FILTER([1, 2, 3], _u -> _u <> 2)");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE([1, 2, 3], NULL)", () => {
    const result = transpile("ARRAY_REMOVE([1, 2, 3], NULL)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN NULL IS NULL THEN NULL ELSE LIST_FILTER([1, 2, 3], _u -> _u <> NULL) END");
  });
});

describe("Duckdb: array_remove_at", () => {
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], 0)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], 0)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE [1, 2, 3][2:] END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], 1)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], 1)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:1], [1, 2, 3][3:]) END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], 2)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], 2)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:2], [1, 2, 3][4:]) END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], -1)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], -1)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE [1, 2, 3][1:LENGTH([1, 2, 3]) + -1] END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], -2)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], -2)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [1, 2, 3] IS NULL THEN NULL ELSE LIST_CONCAT([1, 2, 3][1:LENGTH([1, 2, 3]) + -2], [1, 2, 3][LENGTH([1, 2, 3]) + -2 + 2:]) END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([99], 0)", () => {
    const result = transpile("ARRAY_REMOVE_AT([99], 0)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN [99] IS NULL THEN NULL ELSE [99][2:] END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT(arr, 0)", () => {
    const result = transpile("ARRAY_REMOVE_AT(arr, 0)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CASE WHEN arr IS NULL THEN NULL ELSE arr[2:] END");
  });
  it("snowflake -> duckdb: ARRAY_REMOVE_AT([1, 2, 3], pos)", () => {
    const result = transpile("ARRAY_REMOVE_AT([1, 2, 3], pos)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_REMOVE_AT([1, 2, 3], pos)");
  });
});

describe("Duckdb: time", () => {
  it("SELECT CURRENT_DATE", () => {
    validateIdentity("SELECT CURRENT_DATE");
  });
  it("SELECT CURRENT_TIMESTAMP", () => {
    validateIdentity("SELECT CURRENT_TIMESTAMP");
  });
  it.todo("SELECT CAST(CURRENT_TIMESTAMP AT TIME ZONE 'UTC' AS DATE) (unsupported syntax)");
  it("bigquery -> duckdb: SELECT DATE(2016, 12, 25)", () => {
    const result = transpile("SELECT DATE(2016, 12, 25)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAKE_DATE(2016, 12, 25)");
  });
  it("duckdb -> bigquery: SELECT MAKE_DATE(2016, 12, 25)", () => {
    const result = transpile("SELECT MAKE_DATE(2016, 12, 25)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT DATE(2016, 12, 25)");
  });
  it("duckdb -> duckdb: SELECT MAKE_DATE(2016, 12, 25)", () => {
    const result = transpile("SELECT MAKE_DATE(2016, 12, 25)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT MAKE_DATE(2016, 12, 25)");
  });
  it.todo("SELECT CAST(CAST('2016-12-25 23:59:59' AS TIMESTAMP) AS DATE) (unsupported syntax)");
  it.todo("SELECT CAST(CAST(CAST('2016-12-25' AS TIMESTAMPTZ) AS TIMESTAMP) AT... (unsupported syntax)");
  it.todo("SELECT CAST(CAST('2024-01-15 23:30:00' AS TIMESTAMP) AT TIME ZONE '... (unsupported syntax)");
  it("bigquery -> duckdb: SELECT DATE(PARSE_DATE('%m/%d/%Y', '05/06/2020'))", () => {
    const result = transpile("SELECT DATE(PARSE_DATE('%m/%d/%Y', '05/06/2020'))", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST(CAST(STRPTIME('05/06/2020', '%m/%d/%Y') AS DATE) AS DATE)");
  });
  it.todo("SELECT CAST('2020-01-01' AS DATE) + INTERVAL '-1' DAY (unsupported syntax)");
  it.todo("duckdb -> duckdb: SELECT INTERVAL '1 quarter' (unsupported syntax)");
  it.todo("presto -> duckdb: SELECT ((DATE_ADD('week', -5, DATE_TRUNC('DAY', DATE_ADD('day', (0 - ... (unsupported syntax)");
  it("presto -> duckdb: TO_UNIXTIME(x)", () => {
    const result = transpile("TO_UNIXTIME(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("EPOCH(x)");
  });
  it("duckdb -> bigquery: EPOCH(x)", () => {
    const result = transpile("EPOCH(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TIME_TO_UNIX(x)");
  });
  it("duckdb -> duckdb: EPOCH(x)", () => {
    const result = transpile("EPOCH(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EPOCH(x)");
  });
  it("duckdb -> presto: EPOCH(x)", () => {
    const result = transpile("EPOCH(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_UNIXTIME(x)");
  });
  it("duckdb -> spark: EPOCH(x)", () => {
    const result = transpile("EPOCH(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UNIX_TIMESTAMP(x)");
  });
  it("duckdb -> bigquery: EPOCH_MS(x)", () => {
    const result = transpile("EPOCH_MS(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TIMESTAMP_MILLIS(x)");
  });
  it("duckdb -> clickhouse: EPOCH_MS(x)", () => {
    const result = transpile("EPOCH_MS(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("fromUnixTimestamp64Milli(CAST(x AS Nullable(Int64)))");
  });
  it("duckdb -> duckdb: EPOCH_MS(x)", () => {
    const result = transpile("EPOCH_MS(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EPOCH_MS(x)");
  });
  it.todo("duckdb -> mysql: EPOCH_MS(x) (cross-dialect transform)");
  it.todo("duckdb -> postgres: EPOCH_MS(x) (cross-dialect transform)");
  it.todo("duckdb -> presto: EPOCH_MS(x) (cross-dialect transform)");
  it("duckdb -> spark: EPOCH_MS(x)", () => {
    const result = transpile("EPOCH_MS(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TIMESTAMP_MILLIS(x)");
  });
  it("duckdb -> bigquery: STRFTIME(x, '%y-%-m-%S')", () => {
    const result = transpile("STRFTIME(x, '%y-%-m-%S')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%y-%-m-%S', x)");
  });
  it("duckdb -> duckdb: STRFTIME(x, '%y-%-m-%S')", () => {
    const result = transpile("STRFTIME(x, '%y-%-m-%S')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRFTIME(x, '%y-%-m-%S')");
  });
  it("duckdb -> postgres: STRFTIME(x, '%y-%-m-%S')", () => {
    const result = transpile("STRFTIME(x, '%y-%-m-%S')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("TO_CHAR(x, 'YY-FMMM-SS')");
  });
  it.todo("duckdb -> presto: STRFTIME(x, '%y-%-m-%S') (unsupported syntax)");
  it.todo("duckdb -> spark: STRFTIME(x, '%y-%-m-%S') (unsupported syntax)");
  it("duckdb -> duckdb: SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SHA1(x)");
  });
  it("duckdb -> : SHA1(x)", () => {
    const result = transpile("SHA1(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SHA(x)");
  });
  it("duckdb -> bigquery: STRFTIME(x, '%Y-%m-%d %H:%M:%S')", () => {
    const result = transpile("STRFTIME(x, '%Y-%m-%d %H:%M:%S')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%F %T', x)");
  });
  it("duckdb -> duckdb: STRFTIME(x, '%Y-%m-%d %H:%M:%S')", () => {
    const result = transpile("STRFTIME(x, '%Y-%m-%d %H:%M:%S')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRFTIME(x, '%Y-%m-%d %H:%M:%S')");
  });
  it.todo("duckdb -> presto: STRFTIME(x, '%Y-%m-%d %H:%M:%S') (unsupported syntax)");
  it.todo("duckdb -> hive: STRFTIME(x, '%Y-%m-%d %H:%M:%S') (unsupported syntax)");
  it("duckdb -> bigquery: STRPTIME(x, '%y-%-m')", () => {
    const result = transpile("STRPTIME(x, '%y-%-m')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_TIMESTAMP('%y-%-m', x)");
  });
  it("duckdb -> duckdb: STRPTIME(x, '%y-%-m')", () => {
    const result = transpile("STRPTIME(x, '%y-%-m')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRPTIME(x, '%y-%-m')");
  });
  it.todo("duckdb -> presto: STRPTIME(x, '%y-%-m') (cross-dialect transform)");
  it.todo("duckdb -> hive: STRPTIME(x, '%y-%-m') (cross-dialect transform)");
  it.todo("duckdb -> spark: STRPTIME(x, '%y-%-m') (cross-dialect transform)");
  it.todo("duckdb -> bigquery: TO_TIMESTAMP(x) (cross-dialect transform)");
  it("duckdb -> duckdb: TO_TIMESTAMP(x)", () => {
    const result = transpile("TO_TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TO_TIMESTAMP(x)");
  });
  it.todo("duckdb -> presto: TO_TIMESTAMP(x) (cross-dialect transform)");
  it.todo("duckdb -> hive: TO_TIMESTAMP(x) (cross-dialect transform)");
  it("duckdb -> bigquery: STRPTIME(x, '%-m/%-d/%y %-I:%M %p')", () => {
    const result = transpile("STRPTIME(x, '%-m/%-d/%y %-I:%M %p')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_TIMESTAMP('%-m/%e/%y %-I:%M %p', x)");
  });
  it("duckdb -> duckdb: STRPTIME(x, '%-m/%-d/%y %-I:%M %p')", () => {
    const result = transpile("STRPTIME(x, '%-m/%-d/%y %-I:%M %p')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRPTIME(x, '%-m/%-d/%y %-I:%M %p')");
  });
  it.todo("duckdb -> presto: STRPTIME(x, '%-m/%-d/%y %-I:%M %p') (cross-dialect transform)");
  it.todo("duckdb -> hive: STRPTIME(x, '%-m/%-d/%y %-I:%M %p') (cross-dialect transform)");
  it.todo("duckdb -> spark: STRPTIME(x, '%-m/%-d/%y %-I:%M %p') (cross-dialect transform)");
  it.todo("CAST(start AS TIMESTAMPTZ) AT TIME ZONE 'America/New_York' (unsupported syntax)");
  it.todo("SELECT TIMESTAMP 'foo' (unsupported syntax)");
});

describe("Duckdb: sample", () => {
  it.todo("SELECT * FROM tbl USING SAMPLE 5 (unsupported clause)");
  it.todo("SELECT * FROM tbl USING SAMPLE 10% (unsupported clause)");
  it.todo("SELECT * FROM tbl USING SAMPLE 10 PERCENT (bernoulli) (unsupported clause)");
  it.todo("SELECT * FROM tbl USING SAMPLE reservoir(50 ROWS) REPEATABLE (100) (unsupported clause)");
  it.todo("SELECT * FROM tbl USING SAMPLE 10% (system, 377) (unsupported clause)");
  it.todo("SELECT * FROM tbl TABLESAMPLE RESERVOIR(20%), tbl2 WHERE tbl.i=tbl2.i (unsupported clause)");
  it.todo("SELECT * FROM tbl, tbl2 WHERE tbl.i=tbl2.i USING SAMPLE RESERVOIR(20%) (unsupported clause)");
  it.todo("SELECT * FROM example TABLESAMPLE RESERVOIR (3 ROWS) REPEATABLE (82) (unsupported clause)");
  it.todo("SELECT * FROM (SELECT * FROM t) AS t1 TABLESAMPLE (1 ROWS), (SELECT... (unsupported clause)");
});

describe("Duckdb: array", () => {
  it.todo("ARRAY(SELECT id FROM t) (unsupported syntax)");
  it.todo("ARRAY((SELECT id FROM t)) (unsupported syntax)");
});

describe("Duckdb: cast", () => {
  it.todo("x::int[3] (unsupported syntax)");
  it("CAST(x AS REAL)", () => {
    validateIdentity("CAST(x AS REAL)");
  });
  it("CAST(x AS UINTEGER)", () => {
    validateIdentity("CAST(x AS UINTEGER)");
  });
  it("CAST(x AS UBIGINT)", () => {
    validateIdentity("CAST(x AS UBIGINT)");
  });
  it("CAST(x AS USMALLINT)", () => {
    validateIdentity("CAST(x AS USMALLINT)");
  });
  it("CAST(x AS UTINYINT)", () => {
    validateIdentity("CAST(x AS UTINYINT)");
  });
  it("CAST(x AS TEXT)", () => {
    validateIdentity("CAST(x AS TEXT)");
  });
  it("CAST(x AS INT128)", () => {
    validateIdentity("CAST(x AS INT128)");
  });
  it("CAST(x AS DOUBLE)", () => {
    validateIdentity("CAST(x AS DOUBLE)");
  });
  it("CAST(x AS DECIMAL(15, 4))", () => {
    validateIdentity("CAST(x AS DECIMAL(15, 4))");
  });
  it("CAST(x AS STRUCT(number BIGINT))", () => {
    validateIdentity("CAST(x AS STRUCT(number BIGINT))");
  });
  it("CAST(x AS INT64) -> CAST(x AS BIGINT)", () => {
    validateIdentity("CAST(x AS INT64)", "CAST(x AS BIGINT)");
  });
  it("CAST(x AS INT32) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS INT32)", "CAST(x AS INT)");
  });
  it("CAST(x AS INT16) -> CAST(x AS SMALLINT)", () => {
    validateIdentity("CAST(x AS INT16)", "CAST(x AS SMALLINT)");
  });
  it("CAST(x AS INT8) -> CAST(x AS BIGINT)", () => {
    validateIdentity("CAST(x AS INT8)", "CAST(x AS BIGINT)");
  });
  it("CAST(x AS NUMERIC(1, 2)) -> CAST(x AS DECIMAL(1, 2))", () => {
    validateIdentity("CAST(x AS NUMERIC(1, 2))", "CAST(x AS DECIMAL(1, 2))");
  });
  it("CAST(x AS HUGEINT) -> CAST(x AS INT128)", () => {
    validateIdentity("CAST(x AS HUGEINT)", "CAST(x AS INT128)");
  });
  it("CAST(x AS UHUGEINT) -> CAST(x AS UINT128)", () => {
    validateIdentity("CAST(x AS UHUGEINT)", "CAST(x AS UINT128)");
  });
  it("CAST(x AS CHAR) -> CAST(x AS TEXT)", () => {
    validateIdentity("CAST(x AS CHAR)", "CAST(x AS TEXT)");
  });
  it("CAST(x AS BPCHAR) -> CAST(x AS TEXT)", () => {
    validateIdentity("CAST(x AS BPCHAR)", "CAST(x AS TEXT)");
  });
  it("CAST(x AS STRING) -> CAST(x AS TEXT)", () => {
    validateIdentity("CAST(x AS STRING)", "CAST(x AS TEXT)");
  });
  it("CAST(x AS VARCHAR) -> CAST(x AS TEXT)", () => {
    validateIdentity("CAST(x AS VARCHAR)", "CAST(x AS TEXT)");
  });
  it("CAST(x AS INT1) -> CAST(x AS TINYINT)", () => {
    validateIdentity("CAST(x AS INT1)", "CAST(x AS TINYINT)");
  });
  it("CAST(x AS FLOAT4) -> CAST(x AS REAL)", () => {
    validateIdentity("CAST(x AS FLOAT4)", "CAST(x AS REAL)");
  });
  it("CAST(x AS FLOAT) -> CAST(x AS REAL)", () => {
    validateIdentity("CAST(x AS FLOAT)", "CAST(x AS REAL)");
  });
  it("CAST(x AS INT4) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS INT4)", "CAST(x AS INT)");
  });
  it("CAST(x AS INTEGER) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS INTEGER)", "CAST(x AS INT)");
  });
  it("CAST(x AS SIGNED) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS SIGNED)", "CAST(x AS INT)");
  });
  it("CAST(x AS BLOB) -> CAST(x AS BLOB)", () => {
    validateIdentity("CAST(x AS BLOB)", "CAST(x AS BLOB)");
  });
  it("CAST(x AS BYTEA) -> CAST(x AS BLOB)", () => {
    validateIdentity("CAST(x AS BYTEA)", "CAST(x AS BLOB)");
  });
  it("CAST(x AS BINARY) -> CAST(x AS BLOB)", () => {
    validateIdentity("CAST(x AS BINARY)", "CAST(x AS BLOB)");
  });
  it("CAST(x AS VARBINARY) -> CAST(x AS BLOB)", () => {
    validateIdentity("CAST(x AS VARBINARY)", "CAST(x AS BLOB)");
  });
  it("CAST(x AS LOGICAL) -> CAST(x AS BOOLEAN)", () => {
    validateIdentity("CAST(x AS LOGICAL)", "CAST(x AS BOOLEAN)");
  });
  it(`CAST({'i': 1, 's': 'foo'} AS STRUCT("s" TEXT, "i" INT))`, () => {
    validateIdentity(`CAST({'i': 1, 's': 'foo'} AS STRUCT("s" TEXT, "i" INT))`);
  });
  it("CAST(ROW(1, ROW(1)) AS STRUCT(number BIGINT, row STRUCT(number BIGINT)))", () => {
    validateIdentity("CAST(ROW(1, ROW(1)) AS STRUCT(number BIGINT, row STRUCT(number BIGINT)))");
  });
  it.todo("123::CHARACTER VARYING (unsupported syntax)");
  it.todo("CAST([[STRUCT_PACK(a := 1)]] AS STRUCT(a BIGINT)[][]) (unsupported syntax)");
  it.todo("CAST([STRUCT_PACK(a := 1)] AS STRUCT(a BIGINT)[]) (unsupported syntax)");
  it.todo("STRUCT_PACK(a := 'b')::json (unsupported syntax)");
  it.todo("STRUCT_PACK(a := 'b')::STRUCT(a TEXT) (unsupported syntax)");
  it("duckdb -> duckdb: CAST(x AS TIME)", () => {
    const result = transpile("CAST(x AS TIME)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS TIME)");
  });
  it("presto -> duckdb: CAST(x AS TIME(6))", () => {
    const result = transpile("CAST(x AS TIME(6))", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS TIME)");
  });
  it.todo("SELECT CAST('2020-01-01 12:05:01' AS TIMESTAMP) (unsupported syntax)");
  it("duckdb -> duckdb: SELECT CAST('2020-01-01' AS DATE) + INTERVAL (day_offset) DAY FROM t", () => {
    const result = transpile("SELECT CAST('2020-01-01' AS DATE) + INTERVAL (day_offset) DAY FROM t", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('2020-01-01' AS DATE) + INTERVAL (day_offset) DAY FROM t");
  });
  it.todo("mysql -> duckdb: SELECT DATE '2020-01-01' + INTERVAL day_offset DAY FROM t (unsupported syntax)");
  it("snowflake -> duckdb: SELECT TIMEADD(HOUR, 2, TO_TIME('09:05:03'))", () => {
    const result = transpile("SELECT TIMEADD(HOUR, 2, TO_TIME('09:05:03'))", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('09:05:03' AS TIME) + INTERVAL 2 HOUR");
  });
  it.todo("duckdb -> duckdb: SELECT CAST('09:05:03' AS TIME) + INTERVAL 2 HOUR (unsupported syntax)");
  it("duckdb -> snowflake: SELECT CAST('09:05:03' AS TIME) + INTERVAL 2 HOUR", () => {
    const result = transpile("SELECT CAST('09:05:03' AS TIME) + INTERVAL 2 HOUR", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CAST('09:05:03' AS TIME) + INTERVAL '2 HOUR'");
  });
  it("duckdb -> duckdb: CAST(x AS VARCHAR(5))", () => {
    const result = transpile("CAST(x AS VARCHAR(5))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS TEXT)");
  });
  it.todo("duckdb -> postgres: CAST(x AS VARCHAR(5)) (cross-dialect transform)");
  it("snowflake -> duckdb: CAST(x AS NUMBER)", () => {
    const result = transpile("CAST(x AS NUMBER)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS DECIMAL(38, 0))");
  });
  it("duckdb -> duckdb: CAST(x AS DECIMAL(38, 0))", () => {
    const result = transpile("CAST(x AS DECIMAL(38, 0))", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS DECIMAL(38, 0))");
  });
  it("duckdb -> snowflake: CAST(x AS DECIMAL(38, 0))", () => {
    const result = transpile("CAST(x AS DECIMAL(38, 0))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(38, 0))");
  });
  it("duckdb -> duckdb: CAST(x AS NUMERIC)", () => {
    const result = transpile("CAST(x AS NUMERIC)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(18, 3))");
  });
  it("duckdb -> postgres: CAST(x AS NUMERIC)", () => {
    const result = transpile("CAST(x AS NUMERIC)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(18, 3))");
  });
  it("duckdb -> duckdb: CAST(x AS DECIMAL)", () => {
    const result = transpile("CAST(x AS DECIMAL)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(18, 3))");
  });
  it("duckdb -> postgres: CAST(x AS DECIMAL)", () => {
    const result = transpile("CAST(x AS DECIMAL)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS DECIMAL(18, 3))");
  });
  it("duckdb -> duckdb: CAST(x AS BITSTRING)", () => {
    const result = transpile("CAST(x AS BITSTRING)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it("duckdb -> duckdb: CAST(x AS BIT)", () => {
    const result = transpile("CAST(x AS BIT)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it("duckdb -> tsql: CAST(x AS BIT)", () => {
    const result = transpile("CAST(x AS BIT)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it("duckdb -> duckdb: cast([[1]] as int[][])", () => {
    const result = transpile("cast([[1]] as int[][])", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST([[1]] AS INT[][])");
  });
  it.todo("duckdb -> spark: cast([[1]] as int[][]) (unsupported syntax)");
  it("spark -> duckdb: DATE_SUB(x, 7)", () => {
    const result = transpile("DATE_SUB(x, 7)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS DATE) + INTERVAL (7 * -1) DAY");
  });
  it("hive -> duckdb: 1d", () => {
    const result = transpile("1d", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("TRY_CAST(1 AS DOUBLE)");
  });
  it("spark -> duckdb: 1d", () => {
    const result = transpile("1d", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("TRY_CAST(1 AS DOUBLE)");
  });
  it("duckdb -> duckdb: CAST(x AS DATE)", () => {
    const result = transpile("CAST(x AS DATE)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it("duckdb -> : CAST(x AS DATE)", () => {
    const result = transpile("CAST(x AS DATE)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("CAST(x AS DATE)");
  });
  it.todo("COL::BIGINT[] (unsupported syntax)");
  it.todo("SELECT x::INT[3][3] (unsupported syntax)");
  it.todo("SELECT ARRAY[[[1]]]::INT[1][1][1] (unsupported syntax)");
});

describe("Duckdb: encode_decode", () => {
  it("spark -> duckdb: ENCODE(x, 'utf-8')", () => {
    const result = transpile("ENCODE(x, 'utf-8')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("ENCODE(x)");
  });
  it("presto -> duckdb: TO_UTF8(x)", () => {
    const result = transpile("TO_UTF8(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("ENCODE(x)");
  });
  it("duckdb -> duckdb: ENCODE(x)", () => {
    const result = transpile("ENCODE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ENCODE(x)");
  });
  it("duckdb -> spark: ENCODE(x)", () => {
    const result = transpile("ENCODE(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ENCODE(x, 'utf-8')");
  });
  it("duckdb -> presto: ENCODE(x)", () => {
    const result = transpile("ENCODE(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_UTF8(x)");
  });
  it("spark -> duckdb: DECODE(x, 'utf-8')", () => {
    const result = transpile("DECODE(x, 'utf-8')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("DECODE(x)");
  });
  it("presto -> duckdb: FROM_UTF8(x)", () => {
    const result = transpile("FROM_UTF8(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DECODE(x)");
  });
  it("duckdb -> duckdb: DECODE(x)", () => {
    const result = transpile("DECODE(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DECODE(x)");
  });
  it("duckdb -> spark: DECODE(x)", () => {
    const result = transpile("DECODE(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DECODE(x, 'utf-8')");
  });
  it("duckdb -> presto: DECODE(x)", () => {
    const result = transpile("DECODE(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("FROM_UTF8(x)");
  });
  it("presto -> duckdb: FROM_UTF8(x, y)", () => {
    const result = transpile("FROM_UTF8(x, y)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DECODE(x)");
  });
});

describe("Duckdb: sha", () => {
  it("SHA1('foo')", () => {
    validateIdentity("SHA1('foo')");
  });
  it("SHA1(x)", () => {
    validateIdentity("SHA1(x)");
  });
  it("SHA256('foo')", () => {
    validateIdentity("SHA256('foo')");
  });
  it("SHA256(x)", () => {
    validateIdentity("SHA256(x)");
  });
});

describe("Duckdb: rename_table", () => {
  it.todo("ALTER TABLE db.t1 RENAME TO db.t2 (DDL/DML not supported)");
  it.todo('ALTER TABLE "db"."t1" RENAME TO "db"."t2" (DDL/DML not supported)');
});

describe("Duckdb: timestamps_with_units", () => {
  it.todo("SELECT w::TIMESTAMP_S, x::TIMESTAMP_MS, y::TIMESTAMP_US, z::TIMESTA... (unsupported syntax)");
});

describe("Duckdb: isnan", () => {
  it("bigquery -> duckdb: IS_NAN(x)", () => {
    const result = transpile("IS_NAN(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("ISNAN(x)");
  });
  it("duckdb -> bigquery: ISNAN(x)", () => {
    const result = transpile("ISNAN(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("IS_NAN(x)");
  });
  it("duckdb -> duckdb: ISNAN(x)", () => {
    const result = transpile("ISNAN(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ISNAN(x)");
  });
});

describe("Duckdb: isinf", () => {
  it("bigquery -> duckdb: IS_INF(x)", () => {
    const result = transpile("IS_INF(x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("ISINF(x)");
  });
  it("duckdb -> bigquery: ISINF(x)", () => {
    const result = transpile("ISINF(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("IS_INF(x)");
  });
  it("duckdb -> duckdb: ISINF(x)", () => {
    const result = transpile("ISINF(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ISINF(x)");
  });
});

describe("Duckdb: parameter_token", () => {
  it("bigquery -> duckdb: SELECT @foo", () => {
    const result = transpile("SELECT @foo", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT $foo");
  });
  it("duckdb -> bigquery: SELECT $foo", () => {
    const result = transpile("SELECT $foo", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT @foo");
  });
  it("duckdb -> duckdb: SELECT $foo", () => {
    const result = transpile("SELECT $foo", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT $foo");
  });
});

describe("Duckdb: ignore_nulls", () => {
  it.todo("test_ignore_nulls: unresolvable for-loop iterable");
});

describe("Duckdb: attach_detach", () => {
  it.todo("ATTACH 'file.db' (command not supported)");
  it.todo("ATTACH ':memory:' AS db_alias (command not supported)");
  it.todo("ATTACH IF NOT EXISTS 'file.db' AS db_alias (command not supported)");
  it.todo("ATTACH 'file.db' AS db_alias (READ_ONLY) (command not supported)");
  it.todo("ATTACH 'file.db' (READ_ONLY FALSE, TYPE sqlite) (command not supported)");
  it.todo("ATTACH 'file.db' (TYPE POSTGRES, SCHEMA 'public') (command not supported)");
  it.todo("ATTACH DATABASE 'file.db' (command not supported)");
  it.todo("DETACH new_database (command not supported)");
  it.todo("DETACH IF EXISTS file (command not supported)");
  it.todo("DETACH DATABASE IF EXISTS file (command not supported)");
  it.todo("DETACH DATABASE db (command not supported)");
});

describe("Duckdb: simplified_pivot_unpivot", () => {
  it.todo("PIVOT Cities ON Year USING SUM(Population) (unsupported clause)");
  it.todo("PIVOT Cities ON Year USING FIRST(Population) (unsupported clause)");
  it.todo("PIVOT Cities ON Year USING SUM(Population) GROUP BY Country (unsupported clause)");
  it.todo("PIVOT Cities ON Country, Name USING SUM(Population) (unsupported clause)");
  it.todo("PIVOT Cities ON Country || '_' || Name USING SUM(Population) (unsupported clause)");
  it.todo("PIVOT Cities ON Year USING SUM(Population) GROUP BY Country, Name (unsupported clause)");
  it.todo("UNPIVOT (SELECT 1 AS col1, 2 AS col2) ON foo, bar (unsupported clause)");
  it.todo("UNPIVOT monthly_sales ON jan, feb, mar, apr, may, jun INTO NAME mon... (unsupported clause)");
  it.todo("UNPIVOT monthly_sales ON COLUMNS(* EXCLUDE (empid, dept)) INTO NAME... (unsupported clause)");
  it.todo("UNPIVOT monthly_sales ON (jan, feb, mar) AS q1, (apr, may, jun) AS ... (unsupported clause)");
  it.todo("WITH unpivot_alias AS (UNPIVOT monthly_sales ON COLUMNS(* EXCLUDE (... (unsupported clause)");
  it.todo("SELECT * FROM (UNPIVOT monthly_sales ON COLUMNS(* EXCLUDE (empid, d... (unsupported clause)");
  it.todo("WITH cities(country, name, year, population) AS (SELECT 'NL', 'Amst... (unsupported clause)");
});

describe("Duckdb: from_first_with_parentheses", () => {
  it.todo("CREATE TABLE t1 AS (FROM t2 SELECT foo1, foo2) (DDL/DML not supported)");
  it("FROM (FROM t1 SELECT foo1, foo2) -> SELECT * FROM (SELECT foo1, foo2 FROM t1)", () => {
    validateIdentity("FROM (FROM t1 SELECT foo1, foo2)", "SELECT * FROM (SELECT foo1, foo2 FROM t1)");
  });
  it("WITH t1 AS (FROM (FROM t2 SELECT foo1, foo2)) FROM t1 -> WITH t1 AS (SELECT * FROM (SEL...", () => {
    validateIdentity("WITH t1 AS (FROM (FROM t2 SELECT foo1, foo2)) FROM t1", "WITH t1 AS (SELECT * FROM (SELECT foo1, foo2 FROM t2)) SELECT * FROM t1");
  });
});

describe("Duckdb: analyze", () => {
  it.todo("ANALYZE (command not supported)");
});

describe("Duckdb: prefix_aliases", () => {
  it("SELECT foo: 1 -> SELECT 1 AS foo", () => {
    validateIdentity("SELECT foo: 1", "SELECT 1 AS foo");
  });
  it("SELECT foo: bar -> SELECT bar AS foo", () => {
    validateIdentity("SELECT foo: bar", "SELECT bar AS foo");
  });
  it("SELECT foo: t.col FROM t -> SELECT t.col AS foo FROM t", () => {
    validateIdentity("SELECT foo: t.col FROM t", "SELECT t.col AS foo FROM t");
  });
  it('SELECT "foo" /* bla */: 1 -> SELECT 1 AS "foo" /* bla */', () => {
    validateIdentity('SELECT "foo" /* bla */: 1', 'SELECT 1 AS "foo" /* bla */');
  });
  it('SELECT "foo": 1 /* bla */ -> SELECT 1 AS "foo" /* bla */', () => {
    validateIdentity('SELECT "foo": 1 /* bla */', 'SELECT 1 AS "foo" /* bla */');
  });
  it('SELECT "foo": /* bla */ 1 -> SELECT 1 AS "foo" /* bla */', () => {
    validateIdentity('SELECT "foo": /* bla */ 1', 'SELECT 1 AS "foo" /* bla */');
  });
  it('SELECT "foo": /* bla */ 1 /* foo */ -> SELECT 1 AS "foo" /* bla */ /* foo */', () => {
    validateIdentity('SELECT "foo": /* bla */ 1 /* foo */', 'SELECT 1 AS "foo" /* bla */ /* foo */');
  });
  it('SELECT "foo": 1 -> SELECT 1 AS "foo"', () => {
    validateIdentity('SELECT "foo": 1', 'SELECT 1 AS "foo"');
  });
  it("SELECT foo: 1, bar: 2, baz: 3 -> SELECT 1 AS foo, 2 AS bar, 3 AS baz", () => {
    validateIdentity("SELECT foo: 1, bar: 2, baz: 3", "SELECT 1 AS foo, 2 AS bar, 3 AS baz");
  });
  it("SELECT e: 1 + 2, f: len('asdf'), s: (SELECT 42) -> SELECT 1 + 2 AS e, LENGTH('asdf') AS...", () => {
    validateIdentity("SELECT e: 1 + 2, f: len('asdf'), s: (SELECT 42)", "SELECT 1 + 2 AS e, LENGTH('asdf') AS f, (SELECT 42) AS s");
  });
  it("SELECT * FROM foo: bar -> SELECT * FROM bar AS foo", () => {
    validateIdentity("SELECT * FROM foo: bar", "SELECT * FROM bar AS foo");
  });
  it("SELECT * FROM foo: c.db.tbl -> SELECT * FROM c.db.tbl AS foo", () => {
    validateIdentity("SELECT * FROM foo: c.db.tbl", "SELECT * FROM c.db.tbl AS foo");
  });
  it("SELECT * FROM foo /* bla */: bar -> SELECT * FROM bar AS foo /* bla */", () => {
    validateIdentity("SELECT * FROM foo /* bla */: bar", "SELECT * FROM bar AS foo /* bla */");
  });
  it("SELECT * FROM foo /* bla */: bar /* baz */ -> SELECT * FROM bar AS foo /* bla */ /* baz */", () => {
    validateIdentity("SELECT * FROM foo /* bla */: bar /* baz */", "SELECT * FROM bar AS foo /* bla */ /* baz */");
  });
  it("SELECT * FROM foo /* bla */: /* baz */ bar /* boo */ -> SELECT * FROM bar AS foo /* bla...", () => {
    validateIdentity("SELECT * FROM foo /* bla */: /* baz */ bar /* boo */", "SELECT * FROM bar AS foo /* bla */ /* baz */ /* boo */");
  });
  it.todo("SELECT * FROM r: range(10), v: (VALUES (42)), s: (FROM range(10)) (unsupported syntax)");
  it("\n            SELECT\n                l_returnflag,\n                l_linestatus,\n       ...", () => {
    validateIdentity("\n            SELECT\n                l_returnflag,\n                l_linestatus,\n                sum_qty:        sum(l_quantity),\n                sum_base_price: sum(l_extendedprice),\n                sum_disc_price: sum(l_extendedprice * (1-l_discount)),\n                sum_charge:     sum(l_extendedprice * (1-l_discount) * (1+l_tax)),\n                avg_qty:        avg(l_quantity),\n                avg_price:      avg(l_extendedprice),\n                avg_disc:       avg(l_discount),\n                count_order:    count(*)\n            ", "SELECT l_returnflag, l_linestatus, SUM(l_quantity) AS sum_qty, SUM(l_extendedprice) AS sum_base_price, SUM(l_extendedprice * (1 - l_discount)) AS sum_disc_price, SUM(l_extendedprice * (1 - l_discount) * (1 + l_tax)) AS sum_charge, AVG(l_quantity) AS avg_qty, AVG(l_extendedprice) AS avg_price, AVG(l_discount) AS avg_disc, COUNT(*) AS count_order");
  });
});

describe("Duckdb: at_sign_to_abs", () => {
  it("SELECT @col FROM t -> SELECT ABS(col) FROM t", () => {
    validateIdentity("SELECT @col FROM t", "SELECT ABS(col) FROM t");
  });
  it("SELECT @col + 1 FROM t -> SELECT ABS(col + 1) FROM t", () => {
    validateIdentity("SELECT @col + 1 FROM t", "SELECT ABS(col + 1) FROM t");
  });
  it("SELECT (@col) + 1 FROM t -> SELECT (ABS(col)) + 1 FROM t", () => {
    validateIdentity("SELECT (@col) + 1 FROM t", "SELECT (ABS(col)) + 1 FROM t");
  });
  it("SELECT @(-1) -> SELECT ABS((-1))", () => {
    validateIdentity("SELECT @(-1)", "SELECT ABS((-1))");
  });
  it("SELECT @(-1) + 1 -> SELECT ABS((-1) + 1)", () => {
    validateIdentity("SELECT @(-1) + 1", "SELECT ABS((-1) + 1)");
  });
  it("SELECT (@-1) + 1 -> SELECT (ABS(-1)) + 1", () => {
    validateIdentity("SELECT (@-1) + 1", "SELECT (ABS(-1)) + 1");
  });
});

describe("Duckdb: show_tables", () => {
  it.todo("SHOW TABLES (assert_is check)");
  it.todo("SHOW ALL TABLES (assert_is check)");
});

describe("Duckdb: extract_date_parts", () => {
  it("EXTRACT(WEEK FROM foo) -> EXTRACT(WEEK FROM foo)", () => {
    validateIdentity("EXTRACT(WEEK FROM foo)", "EXTRACT(WEEK FROM foo)");
  });
  it("EXTRACT(WEEKOFYEAR FROM foo) -> EXTRACT(WEEK FROM foo)", () => {
    validateIdentity("EXTRACT(WEEKOFYEAR FROM foo)", "EXTRACT(WEEK FROM foo)");
  });
  it("EXTRACT(WEEKDAY FROM foo)", () => {
    validateIdentity("EXTRACT(WEEKDAY FROM foo)");
  });
  it("EXTRACT(ISOYEAR FROM foo)", () => {
    validateIdentity("EXTRACT(ISOYEAR FROM foo)");
  });
  it("EXTRACT(ISODOW FROM foo)", () => {
    validateIdentity("EXTRACT(ISODOW FROM foo)");
  });
  it("EXTRACT(YEARWEEK FROM foo)", () => {
    validateIdentity("EXTRACT(YEARWEEK FROM foo)");
  });
  it("EXTRACT(TIMEZONE_HOUR FROM foo)", () => {
    validateIdentity("EXTRACT(TIMEZONE_HOUR FROM foo)");
  });
  it("EXTRACT(TIMEZONE_MINUTE FROM foo)", () => {
    validateIdentity("EXTRACT(TIMEZONE_MINUTE FROM foo)");
  });
});

describe("Duckdb: set_item", () => {
  it.todo("SET memory_limit = '10GB' (command not supported)");
  it.todo("SET SESSION default_collation = 'nocase' (command not supported)");
  it.todo("SET GLOBAL sort_order = 'desc' (command not supported)");
  it.todo("SET VARIABLE my_var = 30 (command not supported)");
  it.todo("SET VARIABLE location_map = (SELECT foo FROM bar) (command not supported)");
  it.todo("SET VARIABLE my_var TO 30 (command not supported)");
  it.todo("SET VARIABLE a = 1 (command not supported)");
});

describe("Duckdb: reset", () => {
  it.todo("RESET threads (check_command_warning)");
  it.todo("RESET memory_limit (check_command_warning)");
  it.todo("RESET default_collation (check_command_warning)");
  it.todo("RESET SESSION threads (check_command_warning)");
  it.todo("RESET GLOBAL memory_limit (check_command_warning)");
  it.todo("RESET LOCAL threads (check_command_warning)");
  it.todo("RESET SESSION default_collation (check_command_warning)");
});

describe("Duckdb: map_struct", () => {
  it("MAP {1: 'a', 2: 'b'}", () => {
    validateIdentity("MAP {1: 'a', 2: 'b'}");
  });
  it("MAP {'1': 'a', '2': 'b'}", () => {
    validateIdentity("MAP {'1': 'a', '2': 'b'}");
  });
  it("MAP {[1, 2]: 'a', [3, 4]: 'b'}", () => {
    validateIdentity("MAP {[1, 2]: 'a', [3, 4]: 'b'}");
  });
});

describe("Duckdb: create_sequence", () => {
  it.todo("CREATE SEQUENCE serial START 101 (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE serial START WITH 1 INCREMENT BY 2 (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE serial START WITH 99 INCREMENT BY -1 MAXVALUE 99 (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE serial START WITH 1 MAXVALUE 10 NO CYCLE (DDL/DML not supported)");
  it.todo("CREATE SEQUENCE serial START WITH 1 MAXVALUE 10 CYCLE (DDL/DML not supported)");
});

describe("Duckdb: install", () => {
  it.todo("test_install: assert statement");
  it("INSTALL httpfs FROM community", () => {
    validateIdentity("INSTALL httpfs FROM community");
  });
  it("INSTALL httpfs FROM 'https://extensions.duckdb.org'", () => {
    validateIdentity("INSTALL httpfs FROM 'https://extensions.duckdb.org'");
  });
  it("FORCE INSTALL httpfs FROM community", () => {
    validateIdentity("FORCE INSTALL httpfs FROM community");
  });
  it("FORCE INSTALL httpfs FROM 'https://extensions.duckdb.org'", () => {
    validateIdentity("FORCE INSTALL httpfs FROM 'https://extensions.duckdb.org'");
  });
  it.todo("FORCE CHECKPOINT db (check_command_warning)");
});

describe("Duckdb: cte_using_key", () => {
  it.todo("WITH RECURSIVE tbl(a, b) USING KEY (a) AS (SELECT a, b FROM (VALUES... (unsupported syntax)");
  it.todo("WITH RECURSIVE tbl(a, b) USING KEY (a, b) AS (SELECT a, b FROM (VAL... (unsupported syntax)");
});

describe("Duckdb: udf", () => {
  it("SELECT FUNCTION", () => {
    validateIdentity("SELECT FUNCTION");
  });
  it.todo("CREATE FUNCTION add(a, b) AS a + b (DDL/DML not supported)");
  it.todo("CREATE FUNCTION ifelse(a, b, c) AS CASE WHEN a THEN b ELSE c END (DDL/DML not supported)");
  it("SELECT MACRO", () => {
    validateIdentity("SELECT MACRO");
  });
  it.todo("CREATE MACRO add(a, b) AS a + b (DDL/DML not supported)");
  it.todo("CREATE MACRO ifelse(a, b, c) AS CASE WHEN a THEN b ELSE c END (DDL/DML not supported)");
});

describe("Duckdb: bitwise_agg", () => {
  it("snowflake -> duckdb: SELECT BITOR_AGG(int_value) FROM t", () => {
    const result = transpile("SELECT BITOR_AGG(int_value) FROM t", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_OR(int_value) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_OR(int_value) FROM t", () => {
    const result = transpile("SELECT BIT_OR(int_value) FROM t", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_OR(int_value) FROM t");
  });
  it("snowflake -> duckdb: SELECT BITAND_AGG(int_value) FROM t", () => {
    const result = transpile("SELECT BITAND_AGG(int_value) FROM t", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_AND(int_value) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_AND(int_value) FROM t", () => {
    const result = transpile("SELECT BIT_AND(int_value) FROM t", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_AND(int_value) FROM t");
  });
  it("snowflake -> duckdb: SELECT BITXOR_AGG(int_value) FROM t", () => {
    const result = transpile("SELECT BITXOR_AGG(int_value) FROM t", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_XOR(int_value) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_XOR(int_value) FROM t", () => {
    const result = transpile("SELECT BIT_XOR(int_value) FROM t", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BIT_XOR(int_value) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_OR(CAST(val AS FLOAT)) FROM t", () => {
    const result = transpile("SELECT BIT_OR(CAST(val AS FLOAT)) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT BIT_OR(CAST(ROUND(CAST(val AS REAL)) AS INT)) FROM t");
  });
  it("duckdb -> snowflake: SELECT BIT_OR(CAST(val AS FLOAT)) FROM t", () => {
    const result = transpile("SELECT BIT_OR(CAST(val AS FLOAT)) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITORAGG(CAST(val AS FLOAT)) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_AND(CAST(val AS DOUBLE)) FROM t", () => {
    const result = transpile("SELECT BIT_AND(CAST(val AS DOUBLE)) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT BIT_AND(CAST(ROUND(CAST(val AS DOUBLE)) AS INT)) FROM t");
  });
  it("duckdb -> snowflake: SELECT BIT_AND(CAST(val AS DOUBLE)) FROM t", () => {
    const result = transpile("SELECT BIT_AND(CAST(val AS DOUBLE)) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITANDAGG(CAST(val AS DOUBLE)) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_OR(CAST(val AS DECIMAL(10, 2))) FROM t", () => {
    const result = transpile("SELECT BIT_OR(CAST(val AS DECIMAL(10, 2))) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT BIT_OR(CAST(CAST(val AS DECIMAL(10, 2)) AS INT)) FROM t");
  });
  it("duckdb -> snowflake: SELECT BIT_OR(CAST(val AS DECIMAL(10, 2))) FROM t", () => {
    const result = transpile("SELECT BIT_OR(CAST(val AS DECIMAL(10, 2))) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITORAGG(CAST(val AS DECIMAL(10, 2))) FROM t");
  });
  it("duckdb -> duckdb: SELECT BIT_XOR(CAST(val AS DECIMAL)) FROM t", () => {
    const result = transpile("SELECT BIT_XOR(CAST(val AS DECIMAL)) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT BIT_XOR(CAST(CAST(val AS DECIMAL(18, 3)) AS INT)) FROM t");
  });
  it("duckdb -> snowflake: SELECT BIT_XOR(CAST(val AS DECIMAL)) FROM t", () => {
    const result = transpile("SELECT BIT_XOR(CAST(val AS DECIMAL)) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT BITXORAGG(CAST(val AS DECIMAL(18, 3))) FROM t");
  });
});

describe("Duckdb: approx_percentile", () => {
  it("snowflake -> duckdb: SELECT APPROX_PERCENTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(a, 0.5) FROM t", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_QUANTILE(a, 0.5) FROM t");
  });
  it("duckdb -> duckdb: SELECT APPROX_QUANTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_QUANTILE(a, 0.5) FROM t", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT APPROX_QUANTILE(a, 0.5) FROM t");
  });
  it("duckdb -> snowflake: SELECT APPROX_QUANTILE(a, 0.5) FROM t", () => {
    const result = transpile("SELECT APPROX_QUANTILE(a, 0.5) FROM t", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(a, 0.5) FROM t");
  });
  it.todo("test_approx_percentile: assertEqual call");
});

describe("Duckdb: current_database", () => {
  it("snowflake -> duckdb: SELECT CURRENT_DATABASE()", () => {
    const result = transpile("SELECT CURRENT_DATABASE()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_DATABASE()");
  });
  it("duckdb -> duckdb: SELECT CURRENT_DATABASE()", () => {
    const result = transpile("SELECT CURRENT_DATABASE()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CURRENT_DATABASE()");
  });
  it("duckdb -> snowflake: SELECT CURRENT_DATABASE()", () => {
    const result = transpile("SELECT CURRENT_DATABASE()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CURRENT_DATABASE()");
  });
});

describe("Duckdb: current_schema", () => {
  it("snowflake -> duckdb: SELECT CURRENT_SCHEMA()", () => {
    const result = transpile("SELECT CURRENT_SCHEMA()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_SCHEMA()");
  });
  it("duckdb -> duckdb: SELECT CURRENT_SCHEMA()", () => {
    const result = transpile("SELECT CURRENT_SCHEMA()", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT CURRENT_SCHEMA()");
  });
  it("duckdb -> snowflake: SELECT CURRENT_SCHEMA()", () => {
    const result = transpile("SELECT CURRENT_SCHEMA()", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT CURRENT_SCHEMA()");
  });
});
