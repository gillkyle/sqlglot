// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "oracle";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Oracle: oracle", () => {
  it("1 /* /* */", () => {
    validateIdentity("1 /* /* */");
  });
  it("oracle -> : SELECT CONNECT_BY_ROOT x y", () => {
    const result = transpile("SELECT CONNECT_BY_ROOT x y", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CONNECT_BY_ROOT x AS y");
  });
  it("oracle -> oracle: SELECT CONNECT_BY_ROOT x y", () => {
    const result = transpile("SELECT CONNECT_BY_ROOT x y", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT CONNECT_BY_ROOT x AS y");
  });
  it.todo("test_oracle: parse_one call");
  it.todo("XMLELEMENT(EVALNAME foo + bar) (unsupported syntax)");
  it("SELECT BITMAP_BUCKET_NUMBER(32769)", () => {
    validateIdentity("SELECT BITMAP_BUCKET_NUMBER(32769)");
  });
  it("SELECT BITMAP_CONSTRUCT_AGG(value)", () => {
    validateIdentity("SELECT BITMAP_CONSTRUCT_AGG(value)");
  });
  it("DBMS_RANDOM.NORMAL", () => {
    validateIdentity("DBMS_RANDOM.NORMAL");
  });
  it.todo("DBMS_RANDOM.VALUE(low, high) (assert_is check)");
  it.todo("DBMS_RANDOM.VALUE() (assert_is check)");
  it("CAST(value AS NUMBER DEFAULT 0 ON CONVERSION ERROR)", () => {
    validateIdentity("CAST(value AS NUMBER DEFAULT 0 ON CONVERSION ERROR)");
  });
  it("SYSDATE", () => {
    validateIdentity("SYSDATE");
  });
  it.todo("CREATE GLOBAL TEMPORARY TABLE t AS SELECT * FROM orders (DDL/DML not supported)");
  it.todo("CREATE PRIVATE TEMPORARY TABLE t AS SELECT * FROM orders (DDL/DML not supported)");
  it("REGEXP_REPLACE('source', 'search')", () => {
    validateIdentity("REGEXP_REPLACE('source', 'search')");
  });
  it("TIMESTAMP(3) WITH TIME ZONE", () => {
    validateIdentity("TIMESTAMP(3) WITH TIME ZONE");
  });
  it.todo("SYSTIMESTAMP (assert_is check)");
  it.todo("SELECT SYSTIMESTAMP AT TIME ZONE 'UTC' (unsupported syntax)");
  it("CURRENT_TIMESTAMP(precision)", () => {
    validateIdentity("CURRENT_TIMESTAMP(precision)");
  });
  it.todo("ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol (DDL/DML not supported)");
  it.todo("ALTER TABLE Payments ADD Stock NUMBER NOT NULL (DDL/DML not supported)");
  it.todo("SELECT x FROM t WHERE cond FOR UPDATE (unsupported clause)");
  it("SELECT JSON_OBJECT(k1: v1 FORMAT JSON, k2: v2 FORMAT JSON)", () => {
    validateIdentity("SELECT JSON_OBJECT(k1: v1 FORMAT JSON, k2: v2 FORMAT JSON)");
  });
  it.todo("SELECT JSON_OBJECT('name': first_name || ' ' || last_name) FROM t (unsupported syntax)");
  it("COALESCE(c1, c2, c3)", () => {
    validateIdentity("COALESCE(c1, c2, c3)");
  });
  it("SELECT * FROM TABLE(foo)", () => {
    validateIdentity("SELECT * FROM TABLE(foo)");
  });
  it("SELECT a$x#b", () => {
    validateIdentity("SELECT a$x#b");
  });
  it("SELECT :OBJECT", () => {
    validateIdentity("SELECT :OBJECT");
  });
  it.todo("SELECT * FROM t FOR UPDATE (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE WAIT 5 (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE NOWAIT (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE SKIP LOCKED (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v NOWAIT (unsupported clause)");
  it.todo("SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v SKIP LOCKED (unsupported clause)");
  it("SELECT STANDARD_HASH('hello')", () => {
    validateIdentity("SELECT STANDARD_HASH('hello')");
  });
  it("SELECT STANDARD_HASH('hello', 'MD5')", () => {
    validateIdentity("SELECT STANDARD_HASH('hello', 'MD5')");
  });
  it("SELECT * FROM table_name@dblink_name.database_link_domain", () => {
    validateIdentity("SELECT * FROM table_name@dblink_name.database_link_domain");
  });
  it.todo("SELECT * FROM table_name SAMPLE (25) s (unsupported clause)");
  it.todo("SELECT COUNT(*) * 10 FROM orders SAMPLE (10) SEED (1) (unsupported clause)");
  it("SELECT * FROM V$SESSION", () => {
    validateIdentity("SELECT * FROM V$SESSION");
  });
  it("SELECT TO_DATE('January 15, 1989, 11:00 A.M.')", () => {
    validateIdentity("SELECT TO_DATE('January 15, 1989, 11:00 A.M.')");
  });
  it.todo("SELECT INSTR(haystack, needle) (unsupported syntax)");
  it.todo("SELECT (TIMESTAMP '2025-12-30 20:00:00' - TIMESTAMP '2025-12-29 14:... (unsupported syntax)");
  it("SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND FROM orders", () => {
    validateIdentity("SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND FROM orders");
  });
  it("SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND(3) FROM orders", () => {
    validateIdentity("SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND(3) FROM orders");
  });
  it.todo("SELECT * FROM consumer LEFT JOIN groceries ON consumer.groceries_id... (unsupported clause)");
  it.todo("SELECT * FROM test UNPIVOT INCLUDE NULLS (value FOR Description IN ... (unsupported clause)");
  it.todo("SELECT last_name, employee_id, manager_id, LEVEL FROM employees STA... (unsupported clause)");
  it.todo("ALTER TABLE Payments ADD (Stock NUMBER NOT NULL, dropid VARCHAR2(50... (DDL/DML not supported)");
  it("SELECT JSON_ARRAYAGG(JSON_OBJECT('RNK': RNK, 'RATING_CODE': RATING_CODE, 'DATE_VALUE': ...", () => {
    validateIdentity("SELECT JSON_ARRAYAGG(JSON_OBJECT('RNK': RNK, 'RATING_CODE': RATING_CODE, 'DATE_VALUE': DATE_VALUE, 'AGENT_ID': AGENT_ID RETURNING CLOB) RETURNING CLOB) AS JSON_DATA FROM tablename");
  });
  it.todo("SELECT JSON_ARRAY(FOO() FORMAT JSON, BAR() NULL ON NULL RETURNING C... (unsupported syntax)");
  it("SELECT JSON_ARRAYAGG(FOO() FORMAT JSON ORDER BY bar NULL ON NULL RETURNING CLOB STRICT)", () => {
    validateIdentity("SELECT JSON_ARRAYAGG(FOO() FORMAT JSON ORDER BY bar NULL ON NULL RETURNING CLOB STRICT)");
  });
  it("SELECT COUNT(1) INTO V_Temp FROM TABLE(CAST(somelist AS data_list)) WHERE col LIKE '%co...", () => {
    validateIdentity("SELECT COUNT(1) INTO V_Temp FROM TABLE(CAST(somelist AS data_list)) WHERE col LIKE '%contact'");
  });
  it.todo("SELECT department_id INTO v_department_id FROM departments FETCH FI... (unsupported clause)");
  it("SELECT department_id BULK COLLECT INTO v_department_ids FROM departments", () => {
    validateIdentity("SELECT department_id BULK COLLECT INTO v_department_ids FROM departments");
  });
  it("SELECT department_id, department_name BULK COLLECT INTO v_department_ids, v_department_...", () => {
    validateIdentity("SELECT department_id, department_name BULK COLLECT INTO v_department_ids, v_department_names FROM departments");
  });
  it("SELECT MIN(column_name) KEEP (DENSE_RANK FIRST ORDER BY column_name DESC) FROM table_name", () => {
    validateIdentity("SELECT MIN(column_name) KEEP (DENSE_RANK FIRST ORDER BY column_name DESC) FROM table_name");
  });
  it.todo('XMLELEMENT("ImageID", image.id) (unsupported syntax)');
  it("SELECT CAST('January 15, 1989, 11:00 A.M.' AS DATE DEFAULT NULL ON CONVERSION ERROR, 'M...", () => {
    validateIdentity("SELECT CAST('January 15, 1989, 11:00 A.M.' AS DATE DEFAULT NULL ON CONVERSION ERROR, 'Month dd, YYYY, HH:MI A.M.') FROM DUAL", "SELECT TO_DATE('January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH12:MI A.M.') FROM DUAL");
  });
  it("SELECT TRUNC(SYSDATE) -> SELECT TRUNC(SYSDATE, 'DD')", () => {
    validateIdentity("SELECT TRUNC(SYSDATE)", "SELECT TRUNC(SYSDATE, 'DD')");
  });
  it(`SELECT JSON_OBJECT(KEY 'key1' IS emp.column1, KEY 'key2' IS emp.column1) "emp_key" FROM...`, () => {
    validateIdentity(`SELECT JSON_OBJECT(KEY 'key1' IS emp.column1, KEY 'key2' IS emp.column1) "emp_key" FROM emp`, `SELECT JSON_OBJECT('key1': emp.column1, 'key2': emp.column1) AS "emp_key" FROM emp`);
  });
  it("SELECT JSON_OBJECTAGG(KEY department_name VALUE department_id) FROM dep WHERE id <= 30 ...", () => {
    validateIdentity("SELECT JSON_OBJECTAGG(KEY department_name VALUE department_id) FROM dep WHERE id <= 30", "SELECT JSON_OBJECTAGG(department_name: department_id) FROM dep WHERE id <= 30");
  });
  it("SELECT last_name, department_id, salary, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY co...", () => {
    validateIdentity('SELECT last_name, department_id, salary, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) OVER (PARTITION BY department_id) AS "Worst", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) OVER (PARTITION BY department_id) AS "Best" FROM employees ORDER BY department_id, salary, last_name');
  });
  it("SELECT UNIQUE col1, col2 FROM table -> SELECT DISTINCT col1, col2 FROM table", () => {
    validateIdentity("SELECT UNIQUE col1, col2 FROM table", "SELECT DISTINCT col1, col2 FROM table");
  });
  it.todo("SELECT * FROM T ORDER BY I OFFSET NVL(:variable1, 10) ROWS FETCH NE... (unsupported clause)");
  it.todo("SELECT * FROM t SAMPLE (.25) (unsupported clause)");
  it.todo("SELECT TO_CHAR(-100, 'L99', 'NL_CURRENCY = '' AusDollars '' ') (unsupported syntax)");
  it.todo("SELECT * FROM t START WITH col CONNECT BY NOCYCLE PRIOR col1 = col2 (unsupported clause)");
  it("oracle -> oracle: SELECT DBMS_RANDOM.VALUE", () => {
    const result = transpile("SELECT DBMS_RANDOM.VALUE", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DBMS_RANDOM.VALUE()");
  });
  it.todo("postgres -> oracle: SELECT RANDOM() (cross-dialect transform)");
  it("oracle -> oracle: SELECT DBMS_RANDOM.VALUE()", () => {
    const result = transpile("SELECT DBMS_RANDOM.VALUE()", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT DBMS_RANDOM.VALUE()");
  });
  it.todo("oracle -> postgres: SELECT DBMS_RANDOM.VALUE() (cross-dialect transform)");
  it.todo("SELECT TRIM('|' FROM '||Hello ||| world||') (unsupported syntax)");
  it.todo("SELECT department_id, department_name INTO v_department_id, v_depar... (UnsupportedError in write)");
  it("duckdb -> oracle: SELECT * FROM test WHERE col1 % 4 = 3", () => {
    const result = transpile("SELECT * FROM test WHERE col1 % 4 = 3", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM test WHERE MOD(col1, 4) = 3");
  });
  it("oracle -> duckdb: SELECT * FROM test WHERE MOD(col1, 4) = 3", () => {
    const result = transpile("SELECT * FROM test WHERE MOD(col1, 4) = 3", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM test WHERE col1 % 4 = 3");
  });
  it("oracle -> oracle: SELECT * FROM test WHERE MOD(col1, 4) = 3", () => {
    const result = transpile("SELECT * FROM test WHERE MOD(col1, 4) = 3", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT * FROM test WHERE MOD(col1, 4) = 3");
  });
  it.todo("postgres -> oracle: CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'yyyy/mm/dd') AND TO_D... (cross-dialect transform)");
  it("oracle -> oracle: CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DAT...", () => {
    const result = transpile("CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DATE(f.C_EDATE, 'YYYY/MM/DD')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DATE(f.C_EDATE, 'YYYY/MM/DD')");
  });
  it.todo("oracle -> postgres: CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_D... (cross-dialect transform)");
  it("oracle -> doris: TO_CHAR(x)", () => {
    const result = transpile("TO_CHAR(x)", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("CAST(x AS STRING)");
  });
  it("oracle -> oracle: TO_CHAR(x)", () => {
    const result = transpile("TO_CHAR(x)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TO_CHAR(x)");
  });
  it("teradata -> oracle: TO_NUMBER(expr, fmt, nlsparam)", () => {
    const result = transpile("TO_NUMBER(expr, fmt, nlsparam)", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(expr, fmt, nlsparam)");
  });
  it("oracle -> oracle: TO_NUMBER(expr, fmt, nlsparam)", () => {
    const result = transpile("TO_NUMBER(expr, fmt, nlsparam)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TO_NUMBER(expr, fmt, nlsparam)");
  });
  it("oracle -> teradata: TO_NUMBER(expr, fmt, nlsparam)", () => {
    const result = transpile("TO_NUMBER(expr, fmt, nlsparam)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("TO_NUMBER(expr, fmt, nlsparam)");
  });
  it("oracle -> bigquery: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(x AS FLOAT64)");
  });
  it("oracle -> doris: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> drill: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "drill" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> duckdb: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> hive: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> mysql: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> oracle: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TO_NUMBER(x)");
  });
  it("oracle -> postgres: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS DOUBLE PRECISION)");
  });
  it("oracle -> presto: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> redshift: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("CAST(x AS DOUBLE PRECISION)");
  });
  it("oracle -> snowflake: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_NUMBER(x)");
  });
  it("oracle -> spark: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> spark2: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> starrocks: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> tableau: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "tableau" })[0];
    expect(result).toBe("CAST(x AS DOUBLE)");
  });
  it("oracle -> teradata: TO_NUMBER(x)", () => {
    const result = transpile("TO_NUMBER(x)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("TO_NUMBER(x)");
  });
  it("databricks -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("drill -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "drill", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("postgres -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("snowflake -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("spark -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("redshift -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("teradata -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> databricks: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> drill: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "drill" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> oracle: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> postgres: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> snowflake: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> spark: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> redshift: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> teradata: TO_NUMBER(x, fmt)", () => {
    const result = transpile("TO_NUMBER(x, fmt)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("TO_NUMBER(x, fmt)");
  });
  it("oracle -> oracle: SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1", () => {
    const result = transpile("SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1");
  });
  it("oracle -> spark: SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1", () => {
    const result = transpile("SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST(NULL AS VARCHAR(2328)) AS COL1");
  });
  it("oracle -> oracle: SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1", () => {
    const result = transpile("SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1");
  });
  it("oracle -> spark: SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1", () => {
    const result = transpile("SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST(NULL AS VARCHAR(2328)) AS COL1");
  });
  it.todo("DATE '2022-01-01' (unsupported syntax)");
  it.todo("x::binary_double (unsupported syntax)");
  it.todo("x::binary_float (unsupported syntax)");
  it("postgres -> oracle: CAST(x AS sch.udt)", () => {
    const result = transpile("CAST(x AS sch.udt)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS sch.udt)");
  });
  it("oracle -> oracle: CAST(x AS sch.udt)", () => {
    const result = transpile("CAST(x AS sch.udt)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("CAST(x AS sch.udt)");
  });
  it("oracle -> postgres: CAST(x AS sch.udt)", () => {
    const result = transpile("CAST(x AS sch.udt)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS sch.udt)");
  });
  it("oracle -> oracle: SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI...", () => {
    const result = transpile("SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI:SS.FF6')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI:SS.FF6')");
  });
  it.todo("oracle -> duckdb: SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI... (cross-dialect transform)");
  it("oracle -> oracle: SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD')", () => {
    const result = transpile("SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD')");
  });
  it.todo("oracle -> duckdb: SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("SELECT * FROM t ORDER BY a ASC NULLS LAST, b ASC NULLS FIRST, c DES... (unsupported syntax)");
  it("oracle -> oracle: NVL(NULL, 1)", () => {
    const result = transpile("NVL(NULL, 1)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("NVL(NULL, 1)");
  });
  it("oracle -> : NVL(NULL, 1)", () => {
    const result = transpile("NVL(NULL, 1)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("COALESCE(NULL, 1)");
  });
  it("oracle -> clickhouse: NVL(NULL, 1)", () => {
    const result = transpile("NVL(NULL, 1)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("COALESCE(NULL, 1)");
  });
  it.todo("TRIM(BOTH 'h' FROM 'Hello World') (unsupported syntax)");
  it.todo("SELECT /*+ ORDERED */* FROM tbl (unsupported syntax)");
  it.todo("SELECT /* test */ /*+ ORDERED */* FROM tbl (unsupported syntax)");
  it.todo("SELECT /*+ ORDERED */*/* test */ FROM tbl (unsupported syntax)");
  it.todo("SELECT * FROM t FETCH FIRST 10 ROWS ONLY (unsupported clause)");
  it.todo("CREATE OR REPLACE FORCE VIEW foo1.foo2 (DDL/DML not supported)");
  it("TO_TIMESTAMP('foo')", () => {
    validateIdentity("TO_TIMESTAMP('foo')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 AM', 'DD Mon YYYY HH12:MI AM')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 AM', 'DD Mon YYYY HH12:MI AM')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 PM', 'DD Mon YYYY HH12:MI PM')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 PM', 'DD Mon YYYY HH12:MI PM')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 A.M.', 'DD Mon YYYY HH12:MI A.M.')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 A.M.', 'DD Mon YYYY HH12:MI A.M.')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 P.M.', 'DD Mon YYYY HH12:MI P.M.')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 P.M.', 'DD Mon YYYY HH12:MI P.M.')");
  });
  it.todo("SELECT CUME_DIST(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t (unsupported clause)");
  it.todo("SELECT DENSE_RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t (unsupported clause)");
  it.todo("SELECT RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t (unsupported clause)");
  it.todo("SELECT PERCENT_RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FR... (unsupported clause)");
  it("L2_DISTANCE(x, y)", () => {
    validateIdentity("L2_DISTANCE(x, y)");
  });
  it("BITMAP_OR_AGG(x)", () => {
    validateIdentity("BITMAP_OR_AGG(x)");
  });
});

describe("Oracle: join_marker", () => {
  it("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y (+) = e2.y", () => {
    validateIdentity("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y (+) = e2.y");
  });
  it.todo("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+) (UnsupportedError in write)");
  it("oracle -> : SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)", () => {
    const result = transpile("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT e1.x, e2.x FROM e AS e1, e AS e2 WHERE e1.y = e2.y");
  });
  it("oracle -> oracle: SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)", () => {
    const result = transpile("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)");
  });
});

describe("Oracle: hints", () => {
  it.todo("SELECT /*+ USE_NL(A B) */ A.COL_TEST FROM TABLE_A A, TABLE_B B (unsupported syntax)");
  it.todo("SELECT /*+ INDEX(v.j jhist_employee_ix (employee_id start_date)) */... (unsupported syntax)");
  it.todo("SELECT /*+ USE_NL(A B C) */ A.COL_TEST FROM TABLE_A A, TABLE_B B, T... (unsupported syntax)");
  it.todo("SELECT /*+ NO_INDEX(employees emp_empid) */ employee_id FROM employ... (unsupported syntax)");
  it.todo("SELECT /*+ NO_INDEX_FFS(items item_order_ix) */ order_id FROM order... (unsupported syntax)");
  it.todo("SELECT /*+ LEADING(e j) */ * FROM employees e, departments d, job_h... (unsupported syntax)");
  it.todo("INSERT /*+ APPEND */ INTO IAP_TBL (id, col1) VALUES (2, 'test2') (DDL/DML not supported)");
  it.todo("INSERT /*+ APPEND_VALUES */ INTO dest_table VALUES (i, 'Value') (DDL/DML not supported)");
  it.todo("INSERT /*+ APPEND(d) */ INTO dest d VALUES (i, 'Value') (DDL/DML not supported)");
  it.todo("INSERT /*+ APPEND(d) */ INTO dest d (i, value) SELECT 1, 'value' FR... (DDL/DML not supported)");
  it.todo("SELECT /*+ LEADING(departments employees) USE_NL(employees) */ * FR... (pretty=True not supported)");
  it.todo("SELECT /*+ USE_NL(bbbbbbbbbbbbbbbbbbbbbbbb) LEADING(aaaaaaaaaaaaaaa... (unsupported syntax)");
  it.todo("SELECT /*+ USE_NL(bbbbbbbbbbbbbbbbbbbbbbbb) LEADING(aaaaaaaaaaaaaaa... (pretty=True not supported)");
  it.todo("SELECT /*+ LEADING(departments employees) USE_NL(employees) select ... (pretty=True not supported)");
  it.todo("SELECT /*+ LEADING(departments, employees) */ * FROM employees JOIN... (unsupported syntax)");
  it.todo("SELECT /*+ LEADING(departments select) */ * FROM employees JOIN dep... (unsupported syntax)");
});

describe("Oracle: xml_table", () => {
  it.todo("XMLTABLE('x') (unsupported clause)");
  it.todo("XMLTABLE('x' RETURNING SEQUENCE BY REF) (unsupported clause)");
  it.todo("XMLTABLE('x' PASSING y) (unsupported clause)");
  it.todo("XMLTABLE('x' PASSING y RETURNING SEQUENCE BY REF) (unsupported clause)");
  it.todo("XMLTABLE('x' RETURNING SEQUENCE BY REF COLUMNS a VARCHAR2, b FLOAT) (unsupported clause)");
  it.todo("SELECT x.* FROM example t, XMLTABLE(XMLNAMESPACES(DEFAULT 'http://e... (unsupported clause)");
  it.todo('SELECT warehouse_name warehouse,\n   warehouse2."Water", warehouse2.... (pretty=True not supported)');
  it.todo("SELECT table_name, column_name, data_default FROM xmltable('ROWSET/... (pretty=True not supported)");
});

describe("Oracle: match_recognize", () => {
  it.todo("SELECT\n  *\nFROM sales_history\nMATCH_RECOGNIZE (\n  PARTITION BY prod... (pretty=True not supported)");
});

describe("Oracle: json_table", () => {
  it.todo("SELECT * FROM JSON_TABLE(foo FORMAT JSON, 'bla' ERROR ON ERROR NULL... (unsupported clause)");
  it.todo("SELECT * FROM JSON_TABLE(foo FORMAT JSON, 'bla' ERROR ON ERROR NULL... (unsupported clause) (2)");
  it.todo("SELECT\n  CASE WHEN DBMS_LOB.GETLENGTH(info) < 32000 THEN DBMS_LOB.S... (pretty=True not supported)");
  it.todo("SELECT\n  *\nFROM JSON_TABLE(res, '$.info[*]' COLUMNS(\n  tempid NUMBE... (pretty=True not supported)");
  it.todo("CONVERT('foo', 'dst') (unsupported syntax)");
  it.todo("CONVERT('foo', 'dst', 'src') (unsupported syntax)");
});

describe("Oracle: connect_by", () => {
  it.todo("test_connect_by: unresolvable for-loop iterable");
});

describe("Oracle: query_restrictions", () => {
  it.todo("SELECT * FROM tbl WITH READ ONLY CONSTRAINT name (unsupported syntax)");
  it.todo("CREATE VIEW view AS SELECT * FROM tbl WITH READ ONLY CONSTRAINT name (DDL/DML not supported)");
  it("SELECT * FROM tbl WITH READ ONLY", () => {
    validateIdentity("SELECT * FROM tbl WITH READ ONLY");
  });
  it.todo("CREATE VIEW view AS SELECT * FROM tbl WITH READ ONLY (DDL/DML not supported)");
  it("SELECT * FROM tbl WITH CHECK OPTION CONSTRAINT name", () => {
    validateIdentity("SELECT * FROM tbl WITH CHECK OPTION CONSTRAINT name");
  });
  it.todo("CREATE VIEW view AS SELECT * FROM tbl WITH CHECK OPTION CONSTRAINT ... (DDL/DML not supported)");
  it("SELECT * FROM tbl WITH CHECK OPTION", () => {
    validateIdentity("SELECT * FROM tbl WITH CHECK OPTION");
  });
  it.todo("CREATE VIEW view AS SELECT * FROM tbl WITH CHECK OPTION (DDL/DML not supported)");
});

describe("Oracle: multitable_inserts", () => {
  it.todo("INSERT ALL INTO dest_tab1 (id, description) VALUES (id, description... (DDL/DML not supported)");
  it.todo("INSERT ALL INTO pivot_dest (id, day, val) VALUES (id, 'mon', mon_va... (DDL/DML not supported)");
  it.todo("INSERT ALL WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUE... (DDL/DML not supported)");
  it.todo("INSERT ALL WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUE... (DDL/DML not supported) (2)");
  it.todo("INSERT FIRST WHEN id <= 3 THEN INTO dest_tab1 (id, description) VAL... (DDL/DML not supported)");
  it.todo("INSERT FIRST WHEN id <= 3 THEN INTO dest_tab1 (id, description) VAL... (DDL/DML not supported) (2)");
  it("/* COMMENT */ INSERT FIRST WHEN salary > 4000 THEN INTO emp2 WHEN salary > 5000 THEN IN...", () => {
    validateIdentity("/* COMMENT */ INSERT FIRST WHEN salary > 4000 THEN INTO emp2 WHEN salary > 5000 THEN INTO emp3 WHEN salary > 6000 THEN INTO emp4 SELECT salary FROM employees");
  });
});

describe("Oracle: json_functions", () => {
  it("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle')", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle')");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2...`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2")`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' TRUE ON ERROR)", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' TRUE ON ERROR)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2... (2)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" TRUE ON ERROR)`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' NULL ON EMPTY)", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' NULL ON EMPTY)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2... (3)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" NULL ON EMPTY)`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' DEFAULT 1 ON ERROR TRUE ON EMPTY)", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' DEFAULT 1 ON ERROR TRUE ON EMPTY)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2... (4)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" DEFAULT 1 ON ERROR TRUE ON EMPTY)`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle')", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle')");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "v...`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2")`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' TRUE ON ERROR)", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' TRUE ON ERROR)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "v... (2)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" TRUE ON ERROR)`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' NULL ON EMPTY)", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' NULL ON EMPTY)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "v... (3)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" NULL ON EMPTY)`);
  });
  it("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' DEFAULT 1 ON ERROR TR...", () => {
    validateIdentity("SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' DEFAULT 1 ON ERROR TRUE ON EMPTY)");
  });
  it(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "v... (4)`, () => {
    validateIdentity(`SELECT * FROM t WHERE JSON_EXISTS(name FORMAT JSON, '$[1].middle' PASSING 'name1' AS "var1", 'name2' AS "var2" DEFAULT 1 ON ERROR TRUE ON EMPTY)`);
  });
});

describe("Oracle: grant", () => {
  it.todo("test_grant: unresolvable for-loop iterable");
  it.todo("GRANT SELECT ON TABLE t TO maria, harry (command not supported)");
  it.todo("GRANT SELECT ON TABLE s.v TO PUBLIC (command not supported)");
  it.todo("GRANT SELECT ON TABLE t TO purchases_reader_role (command not supported)");
  it.todo("GRANT UPDATE, TRIGGER ON TABLE t TO anita, zhi (command not supported)");
  it.todo("GRANT EXECUTE ON PROCEDURE p TO george (command not supported)");
  it.todo("GRANT USAGE ON SEQUENCE order_id TO sales_role (command not supported)");
});

describe("Oracle: revoke", () => {
  it.todo("test_revoke: unresolvable for-loop iterable");
  it.todo("REVOKE SELECT ON TABLE t FROM maria, harry (command not supported)");
  it.todo("REVOKE SELECT ON TABLE s.v FROM PUBLIC (command not supported)");
  it.todo("REVOKE SELECT ON TABLE t FROM purchases_reader_role (command not supported)");
  it.todo("REVOKE UPDATE, TRIGGER ON TABLE t FROM anita, zhi (command not supported)");
  it.todo("REVOKE EXECUTE ON PROCEDURE p FROM george (command not supported)");
  it.todo("REVOKE USAGE ON SEQUENCE order_id FROM sales_role (command not supported)");
});

describe("Oracle: datetrunc", () => {
  it("oracle -> clickhouse: TRUNC(SYSDATE, 'YEAR')", () => {
    const result = transpile("TRUNC(SYSDATE, 'YEAR')", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CURRENT_TIMESTAMP())");
  });
  it("oracle -> oracle: TRUNC(SYSDATE, 'YEAR')", () => {
    const result = transpile("TRUNC(SYSDATE, 'YEAR')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(SYSDATE, 'YEAR')");
  });
  it("TRUNC(x, 'Q')", () => {
    validateIdentity("TRUNC(x, 'Q')");
  });
  it("TRUNC(x, 'W')", () => {
    validateIdentity("TRUNC(x, 'W')");
  });
});

describe("Oracle: trunc_type_inference", () => {
  it.todo("test_trunc_type_inference: parse_one call");
  it.todo("test_trunc_type_inference: parse_one call (2)");
  it.todo("test_trunc_type_inference: parse_one call (3)");
  it.todo("TRUNC(3.14159, 2) (assert_is check)");
  it.todo("TRUNC(price, 0) (assert_is check)");
  it.todo("TRUNC(foo, bar) (assert_is check)");
});

describe("Oracle: trunc", () => {
  it.todo("TRUNC(3.14159) (assert_is check)");
  it.todo("TRUNC(3.14159) (DDL/DML in read/write)");
  it.todo("TRUNC(3.14159, 2) (DDL/DML in read/write)");
  it("oracle -> oracle: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'DAY')");
  });
  it("oracle -> snowflake: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('DAY', CAST(x AS DATE))");
  });
  it("oracle -> postgres: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("DATE_TRUNC('DAY', CAST(x AS DATE))");
  });
  it("oracle -> bigquery: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_TRUNC(CAST(x AS DATE), DAY)");
  });
  it("oracle -> duckdb: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('DAY', CAST(x AS DATE))");
  });
  it("oracle -> tsql: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("DATE_TRUNC('DAY', CAST(x AS DATE))");
  });
  it("oracle -> spark: TRUNC(CAST(x AS DATE), 'DAY')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'DAY')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'DAY')");
  });
  it("oracle -> oracle: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'WEEK')");
  });
  it("oracle -> snowflake: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CAST(x AS DATE))");
  });
  it("oracle -> postgres: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CAST(x AS DATE))");
  });
  it("oracle -> bigquery: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_TRUNC(CAST(x AS DATE), WEEK)");
  });
  it("oracle -> duckdb: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CAST(x AS DATE))");
  });
  it("oracle -> tsql: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("DATE_TRUNC('WEEK', CAST(x AS DATE))");
  });
  it("oracle -> spark: TRUNC(CAST(x AS DATE), 'WEEK')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'WEEK')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'WEEK')");
  });
  it("oracle -> oracle: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'MONTH')");
  });
  it("oracle -> snowflake: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('MONTH', CAST(x AS DATE))");
  });
  it("oracle -> postgres: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("DATE_TRUNC('MONTH', CAST(x AS DATE))");
  });
  it("oracle -> bigquery: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_TRUNC(CAST(x AS DATE), MONTH)");
  });
  it("oracle -> duckdb: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('MONTH', CAST(x AS DATE))");
  });
  it("oracle -> tsql: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("DATE_TRUNC('MONTH', CAST(x AS DATE))");
  });
  it("oracle -> spark: TRUNC(CAST(x AS DATE), 'MONTH')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'MONTH')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'MONTH')");
  });
  it("oracle -> oracle: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'QUARTER')");
  });
  it("oracle -> snowflake: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('QUARTER', CAST(x AS DATE))");
  });
  it("oracle -> postgres: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("DATE_TRUNC('QUARTER', CAST(x AS DATE))");
  });
  it("oracle -> bigquery: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_TRUNC(CAST(x AS DATE), QUARTER)");
  });
  it("oracle -> duckdb: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('QUARTER', CAST(x AS DATE))");
  });
  it("oracle -> tsql: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("DATE_TRUNC('QUARTER', CAST(x AS DATE))");
  });
  it("oracle -> spark: TRUNC(CAST(x AS DATE), 'QUARTER')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'QUARTER')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'QUARTER')");
  });
  it("oracle -> oracle: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'YEAR')");
  });
  it("oracle -> snowflake: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST(x AS DATE))");
  });
  it("oracle -> postgres: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST(x AS DATE))");
  });
  it("oracle -> bigquery: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("DATE_TRUNC(CAST(x AS DATE), YEAR)");
  });
  it("oracle -> duckdb: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST(x AS DATE))");
  });
  it("oracle -> tsql: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("DATE_TRUNC('YEAR', CAST(x AS DATE))");
  });
  it("oracle -> spark: TRUNC(CAST(x AS DATE), 'YEAR')", () => {
    const result = transpile("TRUNC(CAST(x AS DATE), 'YEAR')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TRUNC(CAST(x AS DATE), 'YEAR')");
  });
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'HOUR') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'MINUTE') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'SECOND') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'DAY') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'MONTH') (unsupported syntax)");
  it.todo("TRUNC(CAST(x AS TIMESTAMP), 'YEAR') (unsupported syntax)");
});

describe("Oracle: analyze", () => {
  it.todo("ANALYZE TABLE tbl (command not supported)");
  it.todo("ANALYZE INDEX ndx (command not supported)");
  it.todo("ANALYZE TABLE db.tbl PARTITION(foo = 'foo', bar = 'bar') (command not supported)");
  it.todo("ANALYZE TABLE db.tbl SUBPARTITION(foo = 'foo', bar = 'bar') (command not supported)");
  it.todo("ANALYZE INDEX db.ndx PARTITION(foo = 'foo', bar = 'bar') (command not supported)");
  it.todo("ANALYZE INDEX db.ndx PARTITION(part1) (command not supported)");
  it.todo("ANALYZE CLUSTER db.cluster (command not supported)");
  it.todo("ANALYZE TABLE tbl VALIDATE REF UPDATE (command not supported)");
  it.todo("ANALYZE LIST CHAINED ROWS (command not supported)");
  it.todo("ANALYZE LIST CHAINED ROWS INTO tbl (command not supported)");
  it.todo("ANALYZE DELETE STATISTICS (command not supported)");
  it.todo("ANALYZE DELETE SYSTEM STATISTICS (command not supported)");
  it.todo("ANALYZE VALIDATE REF UPDATE (command not supported)");
  it.todo("ANALYZE VALIDATE REF UPDATE SET DANGLING TO NULL (command not supported)");
  it.todo("ANALYZE VALIDATE STRUCTURE (command not supported)");
  it.todo("ANALYZE VALIDATE STRUCTURE CASCADE FAST (command not supported)");
  it.todo("ANALYZE TABLE tbl VALIDATE STRUCTURE CASCADE COMPLETE ONLINE INTO d... (command not supported)");
  it.todo("ANALYZE TABLE tbl VALIDATE STRUCTURE CASCADE COMPLETE OFFLINE INTO ... (command not supported)");
});

describe("Oracle: prior", () => {
  it.todo("SELECT id, PRIOR name AS parent_name, name FROM tree CONNECT BY NOC... (unsupported clause)");
});

describe("Oracle: utc_time", () => {
  it.todo("UTC_TIME() (assert_is check)");
  it.todo("UTC_TIME(6) (assert_is check)");
  it.todo("UTC_TIMESTAMP() (assert_is check)");
  it.todo("UTC_TIMESTAMP(6) (assert_is check)");
});

describe("Oracle: merge_builder_alias", () => {
  it.todo("test_merge_builder_alias: assertEqual call");
});

describe("Oracle: pseudocolumns", () => {
  it.todo("test_pseudocolumns: assertIsNone call");
  it.todo("test_pseudocolumns: assertIsNotNone call");
  it.todo("test_pseudocolumns: assertEqual call");
});

describe("Oracle: chr", () => {
  it.todo("SELECT CHR(187 USING NCHAR_CS) (unsupported syntax)");
  it("SELECT CHR(187)", () => {
    validateIdentity("SELECT CHR(187)");
  });
});
