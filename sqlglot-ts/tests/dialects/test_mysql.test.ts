// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "mysql";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Mysql: ddl", () => {
  it.todo("CREATE TABLE t (id BIGINT UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id BIGINT(10) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT(10) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id MEDIUMINT UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id MEDIUMINT(10) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id SMALLINT UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id SMALLINT(10) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id TINYINT UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id TINYINT(10) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE bar (abacate DOUBLE(10, 2) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id DECIMAL(20, 4) UNSIGNED) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a BIGINT, UNIQUE (b) USING BTREE) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (id BIGINT) (DDL/DML not supported)");
  it.todo("CREATE TABLE 00f (1d BIGINT) (DDL/DML not supported)");
  it.todo("CREATE TABLE temp (id SERIAL PRIMARY KEY) (DDL/DML not supported)");
  it.todo("UPDATE items SET items.price = 0 WHERE items.id >= 5 LIMIT 10 (DDL/DML not supported)");
  it.todo("DELETE FROM t WHERE a <= 10 LIMIT 10 (DDL/DML not supported)");
  it.todo("DELETE FROM t FORCE INDEX (idx) WHERE a > 5 ORDER BY id (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a BIGINT, INDEX USING BTREE (b)) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a BIGINT, FULLTEXT INDEX (b)) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a BIGINT, SPATIAL INDEX (b)) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a INT UNSIGNED ZEROFILL) (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=EXCLUSIVE (DDL/DML not supported)");
  it.todo("ALTER TABLE t ADD INDEX `i` (`c`) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ADD UNIQUE `i` (`c`) (DDL/DML not supported)");
  it.todo("ALTER TABLE test_table MODIFY COLUMN test_column LONGTEXT (DDL/DML not supported)");
  it.todo("ALTER VIEW v AS SELECT a, b, c, d FROM foo (DDL/DML not supported)");
  it.todo("ALTER VIEW v AS SELECT * FROM foo WHERE c > 100 (DDL/DML not supported)");
  it.todo("ALTER ALGORITHM = MERGE VIEW v AS SELECT * FROM foo (check_command_warning)");
  it.todo("ALTER DEFINER = 'admin'@'localhost' VIEW v AS SELECT * FROM foo (check_command_warning)");
  it.todo("CREATE SQL SECURITY INVOKER VIEW id_test (id, foo) AS SELECT 0, foo... (DDL/DML not supported)");
  it.todo("CREATE SQL SECURITY DEFINER VIEW id_test (id, foo) AS SELECT 0, foo... (DDL/DML not supported)");
  it.todo("ALTER SQL SECURITY = DEFINER VIEW v AS SELECT * FROM foo (check_command_warning)");
  it.todo("INSERT INTO things (a, b) VALUES (1, 2) AS new_data ON DUPLICATE KE... (DDL/DML not supported)");
  it.todo("CREATE TABLE `oauth_consumer` (`key` VARCHAR(32) NOT NULL, UNIQUE `... (DDL/DML not supported)");
  it.todo("CREATE TABLE `x` (`username` VARCHAR(200), PRIMARY KEY (`username`(... (DDL/DML not supported)");
  it.todo("UPDATE items SET items.price = 0 WHERE items.id >= 5 ORDER BY items... (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (a BIGINT, INDEX b USING HASH (c) COMMENT 'd' VISI... (DDL/DML not supported)");
  it.todo("DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.id IS NULL (DDL/DML not supported)");
  it.todo("DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3 WHERE t1.id = t2.... (DDL/DML not supported)");
  it.todo("DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3 WHERE t1.id... (DDL/DML not supported)");
  it.todo("INSERT IGNORE INTO subscribers (email) VALUES ('john.doe@gmail.com'... (DDL/DML not supported)");
  it.todo("INSERT INTO t1 (a, b, c) VALUES (1, 2, 3), (4, 5, 6) ON DUPLICATE K... (DDL/DML not supported)");
  it.todo("INSERT INTO t1 (a, b) SELECT c, d FROM t2 UNION SELECT e, f FROM t3... (DDL/DML not supported)");
  it.todo("INSERT INTO t1 (a, b, c) VALUES (1, 2, 3) ON DUPLICATE KEY UPDATE c... (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON DUPLICATE KEY UPDATE x.id = 1 (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE VIEW my_view AS SELECT column1 AS `boo`, column2 ... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (id INT AUTO_INCREMENT, PRIMARY KEY (id) US... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (id INT AUTO_INCREMENT, PRIMARY KEY (id) US... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE test (id INT, PRIMARY KEY pk_name (id)) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (id INT, PRIMARY KEY `pk_name` (id)) (DDL/DML not supported)");
  it.todo('CREATE TABLE test (id INT, PRIMARY KEY "pk_name" (id)) (DDL/DML not supported)');
  it.todo("CREATE TABLE test (id INT, CONSTRAINT pk_name PRIMARY KEY (id)) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) STORED) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) VIRTUAL) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (a INT, b INT AS (a + a) STORED) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (a INT, b INT AS (a + a) VIRTUAL) (DDL/DML not supported)");
  it.todo("/*left*/ EXPLAIN SELECT /*hint*/ col FROM t1 /*right*/ (unsupported syntax)");
  it.todo("CREATE TABLE t (name VARCHAR) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ADD KEY `i` (`c`) (DDL/DML not supported)");
  it.todo("CREATE TABLE `foo` (`id` char(36) NOT NULL DEFAULT (uuid()), PRIMAR... (DDL/DML not supported)");
  it.todo("CREATE TABLE IF NOT EXISTS industry_info (a BIGINT(20) NOT NULL AUT... (DDL/DML not supported)");
  it.todo("CREATE TABLE test (ts TIMESTAMP, ts_tz TIMESTAMPTZ, ts_ltz TIMESTAM... (DDL/DML not supported)");
  it.todo("ALTER TABLE test_table ALTER COLUMN test_column SET DATA TYPE LONGTEXT (DDL/DML not supported)");
  it.todo("CREATE TABLE t (c DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURR... (DDL/DML not supported)");
  it.todo("CREATE TABLE `foo` (a VARCHAR(10), KEY idx_a (a DESC)) (DDL/DML not supported)");
  it.todo("CREATE TABLE `foo` (a VARCHAR(10), UNIQUE INDEX idx_a (a)) (DDL/DML not supported)");
  it.todo("insert into t(i) values (default) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT UNSIGNED) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARA... (DDL/DML not supported)");
  it.todo("CREATE TABLE x (id int not null auto_increment, primary key (id)) (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER INDEX i INVISIBLE (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER INDEX i VISIBLE (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER COLUMN c SET INVISIBLE (DDL/DML not supported)");
  it.todo("ALTER TABLE t ALTER COLUMN c SET VISIBLE (DDL/DML not supported)");
  it.todo("UPDATE foo JOIN bar ON TRUE SET foo.a = bar.a WHERE foo.id = bar.id (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT, created_at DATE) PARTITION BY RANGE (id) (P... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT, name VARCHAR(50)) PARTITION BY RANGE (id) (... (DDL/DML not supported)");
  it.todo("CREATE TABLE orders (id INT, order_date DATE) PARTITION BY RANGE (Y... (DDL/DML not supported)");
  it.todo("CREATE TABLE sales (id INT, sale_date DATE) PARTITION BY RANGE (MON... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT, region VARCHAR(10)) PARTITION BY LIST (id) ... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (id INT) PARTITION BY LIST (id) (PARTITION p0 VALUES... (DDL/DML not supported)");
  it.todo("CREATE TABLE employees (id INT, store_id INT) PARTITION BY LIST (st... (DDL/DML not supported)");
});

describe("Mysql: identity", () => {
  it.todo("SELECT HIGH_PRIORITY STRAIGHT_JOIN SQL_CALC_FOUND_ROWS * FROM t (unsupported syntax)");
  it.todo("SELECT CAST(COALESCE(`id`, 'NULL') AS CHAR CHARACTER SET binary) (unsupported syntax)");
  it.todo("SELECT e.* FROM e STRAIGHT_JOIN p ON e.x = p.y (unsupported syntax)");
  it.todo("ALTER TABLE test_table ALTER COLUMN test_column SET DEFAULT 1 (DDL/DML not supported)");
  it.todo("SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:00.0000') (unsupported syntax)");
  it.todo("SELECT @var1 := 1, @var2 (unsupported syntax)");
  it.todo("UNLOCK TABLES (command not supported)");
  it.todo("LOCK TABLES `app_fields` WRITE (check_command_warning)");
  it.todo("SELECT 1 XOR 0 (unsupported syntax)");
  it.todo("SELECT 1 && 0 (unsupported syntax)");
  it.todo("SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 (unsupported syntax)");
  it.todo("SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt (unsupported syntax)");
  it.todo("SELECT /*+ INDEX(t, i) */ c1 FROM t WHERE c2 = 'value' (unsupported syntax)");
  it.todo("SELECT @a MEMBER OF(@c), @b MEMBER OF(@c) (unsupported syntax)");
  it.todo("SELECT JSON_ARRAY(4, 5) MEMBER OF('[[3,4],[4,5]]') (unsupported syntax)");
  it.todo("SELECT CAST('[4,5]' AS JSON) MEMBER OF('[[3,4],[4,5]]') (unsupported syntax)");
  it.todo(`SELECT 'ab' MEMBER OF('[23, "abc", 17, "ab", 10]') (unsupported syntax)`);
  it.todo("SELECT * FROM foo WHERE 'ab' MEMBER OF(content) (unsupported syntax)");
  it.todo("SELECT CURRENT_TIMESTAMP(6) (unsupported syntax)");
  it("SELECT CURRENT_ROLE()", () => {
    validateIdentity("SELECT CURRENT_ROLE()");
  });
  it.todo("SELECT CURTIME() (unsupported syntax)");
  it.todo("x ->> '$.name' (unsupported syntax)");
  it("SELECT CAST(`a`.`b` AS CHAR) FROM foo", () => {
    validateIdentity("SELECT CAST(`a`.`b` AS CHAR) FROM foo");
  });
  it.todo("SELECT TRIM(LEADING 'bla' FROM ' XXX ') (unsupported syntax)");
  it.todo("SELECT TRIM(TRAILING 'bla' FROM ' XXX ') (unsupported syntax)");
  it.todo("SELECT TRIM(BOTH 'bla' FROM ' XXX ') (unsupported syntax)");
  it.todo("SELECT TRIM('bla' FROM ' XXX ') (unsupported syntax)");
  it.todo("@@GLOBAL.max_connections (unsupported syntax)");
  it.todo("CREATE TABLE A LIKE B (DDL/DML not supported)");
  it.todo("SELECT * FROM t1, t2 FOR SHARE OF t1, t2 SKIP LOCKED (unsupported clause)");
  it.todo("SELECT a || b (unsupported syntax)");
  it.todo("SELECT * FROM source, JSON_TABLE(source.links, '$.org[*]' COLUMNS(r... (unsupported clause)");
  it.todo("SELECT * FROM x ORDER BY BINARY a (unsupported syntax)");
  it.todo("SELECT * FROM foo WHERE 3 MEMBER OF(JSON_EXTRACT(info, '$.value')) (unsupported syntax)");
  it.todo("SELECT * FROM t1, t2, t3 FOR SHARE OF t1 NOWAIT FOR UPDATE OF t2, t... (unsupported clause)");
  it.todo("REPLACE INTO table SELECT id FROM table2 WHERE cnt > 100 (check_command_warning)");
  it("CAST(x AS VARCHAR) -> CAST(x AS CHAR)", () => {
    validateIdentity("CAST(x AS VARCHAR)", "CAST(x AS CHAR)");
  });
  it.todo("SELECT * FROM foo WHERE 3 MEMBER OF(info->'$.value') (unsupported syntax)");
  it.todo("SELECT 1 AS row (unsupported syntax)");
  it.todo("SELECT * FROM table1 USE INDEX (col1_index, col2_index) WHERE col1 ... (unsupported syntax)");
  it.todo("SELECT * FROM table1 IGNORE INDEX (col3_index) WHERE col1 = 1 AND c... (unsupported syntax)");
  it.todo("SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDE... (unsupported syntax)");
  it.todo("SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1, i1) (unsupported syntax)");
  it.todo("SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2) (unsupported syntax)");
  it.todo("SELECT * FROM t1 USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE ... (unsupported syntax)");
  it.todo("SET @var_name = expr (command not supported)");
  it.todo("SET @name = 43 (command not supported)");
  it.todo("SET @total_tax = (SELECT SUM(tax) FROM taxable_transactions) (command not supported)");
  it.todo("SET GLOBAL max_connections = 1000 (command not supported)");
  it.todo("SET @@GLOBAL.max_connections = 1000 (command not supported)");
  it.todo("SET SESSION sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET LOCAL sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET @@SESSION.sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET @@LOCAL.sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET @@sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET sql_mode = 'TRADITIONAL' (command not supported)");
  it.todo("SET PERSIST max_connections = 1000 (command not supported)");
  it.todo("SET @@PERSIST.max_connections = 1000 (command not supported)");
  it.todo("SET PERSIST_ONLY back_log = 100 (command not supported)");
  it.todo("SET @@PERSIST_ONLY.back_log = 100 (command not supported)");
  it.todo("SET @@SESSION.max_join_size = DEFAULT (command not supported)");
  it.todo("SET @@SESSION.max_join_size = @@GLOBAL.max_join_size (command not supported)");
  it.todo("SET @x = 1, SESSION sql_mode = '' (command not supported)");
  it.todo("SET GLOBAL max_connections = 1000, sort_buffer_size = 1000000 (command not supported)");
  it.todo("SET @@GLOBAL.sort_buffer_size = 50000, sort_buffer_size = 1000000 (command not supported)");
  it.todo("SET CHARACTER SET 'utf8' (command not supported)");
  it.todo("SET CHARACTER SET utf8 (command not supported)");
  it.todo("SET CHARACTER SET DEFAULT (command not supported)");
  it.todo("SET NAMES 'utf8' (command not supported)");
  it.todo("SET NAMES DEFAULT (command not supported)");
  it.todo("SET NAMES 'utf8' COLLATE 'utf8_unicode_ci' (command not supported)");
  it.todo("SET NAMES utf8 COLLATE utf8_unicode_ci (command not supported)");
  it.todo("SET autocommit = ON (command not supported)");
  it.todo("SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE (command not supported)");
  it.todo("SET TRANSACTION READ ONLY (command not supported)");
  it.todo("SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE (command not supported)");
  it("DATABASE() -> SCHEMA()", () => {
    validateIdentity("DATABASE()", "SCHEMA()");
  });
  it.todo("SET GLOBAL sort_buffer_size = 1000000, SESSION sort_buffer_size = 1... (command not supported)");
  it.todo("SET @@GLOBAL.sort_buffer_size = 1000000, @@LOCAL.sort_buffer_size =... (command not supported)");
  it.todo("INTERVAL '1' YEAR (unsupported syntax)");
  it.todo("DATE_ADD(x, INTERVAL '1' YEAR) (unsupported syntax)");
  it("CHAR(0)", () => {
    validateIdentity("CHAR(0)");
  });
  it("CHAR(77, 121, 83, 81, '76')", () => {
    validateIdentity("CHAR(77, 121, 83, 81, '76')");
  });
  it.todo("CHAR(77, 77.3, '77.3' USING utf8mb4) (unsupported syntax)");
  it.todo("SELECT * FROM t1 PARTITION(p0) (unsupported syntax)");
  it.todo("SELECT @var1 := 1, @var2 (unsupported syntax) (2)");
  it.todo("SELECT @var1, @var2 := @var1 (unsupported syntax)");
  it.todo("SELECT @var1 := COUNT(*) FROM t1 (unsupported syntax)");
  it.todo("SET @var1 := 1 (command not supported)");
  it.todo("SELECT DISTINCTROW tbl.col FROM tbl (unsupported syntax)");
  it("ATAN(y, x)", () => {
    validateIdentity("ATAN(y, x)");
  });
  it.todo("SELECT 'foo' SOUNDS LIKE 'bar' (unsupported syntax)");
  it.todo("SELECT 'foo' NOT SOUNDS LIKE 'bar' (unsupported syntax)");
  it.todo("SELECT SUBSTR(1 FROM 2 FOR 3) (unsupported syntax)");
  it("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result", () => {
    validateIdentity("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result");
  });
  it.todo("SELECT CHARSET(CHAR(100 USING utf8)) (unsupported syntax)");
  it("SELECT VERSION()", () => {
    validateIdentity("SELECT VERSION()");
  });
});

describe("Mysql: types", () => {
  it.todo("test_types: unresolvable for-loop iterable");
  it.todo("test_types: unresolvable for-loop iterable (2)");
  it("CAST(x AS ENUM('a', 'b'))", () => {
    validateIdentity("CAST(x AS ENUM('a', 'b'))");
  });
  it("CAST(x AS SET('a', 'b'))", () => {
    validateIdentity("CAST(x AS SET('a', 'b'))");
  });
  it("CAST(x AS MEDIUMINT) + CAST(y AS YEAR(4)) -> CAST(x AS SIGNED) + CAST(y AS YEAR(4))", () => {
    validateIdentity("CAST(x AS MEDIUMINT) + CAST(y AS YEAR(4))", "CAST(x AS SIGNED) + CAST(y AS YEAR(4))");
  });
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax)");
  it.todo("CAST(x AS TIMESTAMPTZ) (unsupported syntax)");
  it.todo("CAST(x AS TIMESTAMPLTZ) (unsupported syntax)");
  it("mysql -> mysql: CAST(x AS MEDIUMTEXT) + CAST(y AS LONGTEXT) + CAST(z AS TINYTEXT)", () => {
    const result = transpile("CAST(x AS MEDIUMTEXT) + CAST(y AS LONGTEXT) + CAST(z AS TINYTEXT)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS CHAR) + CAST(y AS CHAR) + CAST(z AS CHAR)");
  });
  it.todo("mysql -> spark: CAST(x AS MEDIUMTEXT) + CAST(y AS LONGTEXT) + CAST(z AS TINYTEXT) (cross-dialect transform)");
  it("mysql -> mysql: CAST(x AS MEDIUMBLOB) + CAST(y AS LONGBLOB) + CAST(z AS TINYBLOB)", () => {
    const result = transpile("CAST(x AS MEDIUMBLOB) + CAST(y AS LONGBLOB) + CAST(z AS TINYBLOB)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS CHAR) + CAST(y AS CHAR) + CAST(z AS CHAR)");
  });
  it.todo("mysql -> spark: CAST(x AS MEDIUMBLOB) + CAST(y AS LONGBLOB) + CAST(z AS TINYBLOB) (cross-dialect transform)");
});

describe("Mysql: canonical_functions", () => {
  it("SELECT LEFT('str', 2) -> SELECT LEFT('str', 2)", () => {
    validateIdentity("SELECT LEFT('str', 2)", "SELECT LEFT('str', 2)");
  });
  it.todo("SELECT INSTR('str', 'substr') (unsupported syntax)");
  it("SELECT UCASE('foo') -> SELECT UPPER('foo')", () => {
    validateIdentity("SELECT UCASE('foo')", "SELECT UPPER('foo')");
  });
  it("SELECT LCASE('foo') -> SELECT LOWER('foo')", () => {
    validateIdentity("SELECT LCASE('foo')", "SELECT LOWER('foo')");
  });
  it("SELECT DAY_OF_MONTH('2023-01-01') -> SELECT DAYOFMONTH('2023-01-01')", () => {
    validateIdentity("SELECT DAY_OF_MONTH('2023-01-01')", "SELECT DAYOFMONTH('2023-01-01')");
  });
  it("SELECT DAY_OF_WEEK('2023-01-01') -> SELECT DAYOFWEEK('2023-01-01')", () => {
    validateIdentity("SELECT DAY_OF_WEEK('2023-01-01')", "SELECT DAYOFWEEK('2023-01-01')");
  });
  it("SELECT DAY_OF_YEAR('2023-01-01') -> SELECT DAYOFYEAR('2023-01-01')", () => {
    validateIdentity("SELECT DAY_OF_YEAR('2023-01-01')", "SELECT DAYOFYEAR('2023-01-01')");
  });
  it("SELECT WEEK_OF_YEAR('2023-01-01') -> SELECT WEEKOFYEAR('2023-01-01')", () => {
    validateIdentity("SELECT WEEK_OF_YEAR('2023-01-01')", "SELECT WEEKOFYEAR('2023-01-01')");
  });
  it("mysql -> mysql: CHAR(10)", () => {
    const result = transpile("CHAR(10)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CHAR(10)");
  });
  it.todo("mysql -> presto: CHAR(10) (cross-dialect transform)");
  it.todo("mysql -> sqlite: CHAR(10) (cross-dialect transform)");
  it.todo("mysql -> tsql: CHAR(10) (cross-dialect transform)");
  it.todo("CREATE TABLE t (foo VARBINARY(5)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (foo BLOB) (DDL/DML not supported)");
});

describe("Mysql: escape", () => {
  it(`'"abc"'`, () => {
    validateIdentity(`'"abc"'`);
  });
  it("'\\'a' -> '''a'", () => {
    validateIdentity("'\\'a'", "'''a'");
  });
  it(`"'abc'" -> '''abc'''`, () => {
    validateIdentity(`"'abc'"`, "'''abc'''");
  });
  it.todo("'a \\' b '' ' (unsupported syntax)");
  it.todo(`'\\"' (unsupported syntax)`);
  it(`'\\\\"a'`, () => {
    validateIdentity(`'\\\\"a'`);
  });
  it.todo("'\t' (unsupported syntax)");
  it.todo("'\\j' (unsupported syntax)");
});

describe("Mysql: introducers", () => {
  it.todo("_utf8mb4 'hola' (unsupported syntax)");
  it.todo("N'some text' (unsupported syntax)");
  it.todo("_latin1 x'4D7953514C' (unsupported syntax)");
});

describe("Mysql: hexadecimal_literal", () => {
  it.todo("SELECT X'1A' (unsupported syntax)");
  it("mysql -> mysql: SELECT 0xz", () => {
    const result = transpile("SELECT 0xz", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT `0xz`");
  });
  it.todo("test_hexadecimal_literal: unresolvable write dict");
  it.todo("test_hexadecimal_literal: unresolvable write dict (2)");
  it.todo("test_hexadecimal_literal: unresolvable write dict (3)");
  it.todo("test_hexadecimal_literal: unresolvable write dict (4)");
  it.todo("test_hexadecimal_literal: unresolvable write dict (5)");
});

describe("Mysql: bits_literal", () => {
  it.todo("test_bits_literal: unresolvable write dict");
  it.todo("test_bits_literal: unresolvable write dict (2)");
});

describe("Mysql: string_literals", () => {
  it.todo('mysql -> mysql: SELECT "2021-01-01" + INTERVAL 1 MONTH (unsupported syntax)');
});

describe("Mysql: convert", () => {
  it.todo("CONVERT(x USING latin1) (unsupported syntax)");
  it.todo("CAST(x AS CHAR CHARACTER SET latin1) (unsupported syntax)");
  it.todo("CONVERT('a' USING binary) (unsupported syntax)");
});

describe("Mysql: match_against", () => {
  it.todo("MATCH(col1, col2, col3) AGAINST('abc') (unsupported syntax)");
  it.todo("MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE) (unsupported syntax)");
  it.todo("MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE WITH QUERY... (unsupported syntax)");
  it.todo("MATCH(col1, col2) AGAINST('abc' IN BOOLEAN MODE) (unsupported syntax)");
  it.todo("MATCH(col1, col2) AGAINST('abc' WITH QUERY EXPANSION) (unsupported syntax)");
  it.todo("MATCH(a.b) AGAINST('abc') (unsupported syntax)");
});

describe("Mysql: date_format", () => {
  it.todo("SELECT DATE_FORMAT('2017-06-15', '%Y') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2017-06-15', '%m') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2017-06-15', '%d') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2017-06-15', '%Y-%m-%d') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2017-06-15 22:23:34', '%H') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2017-06-15', '%w') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2024-08-22 14:53:12', '%a') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2009-10-04 22:23:00', '%a %M %Y') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s') (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT('1900-10-04 22:23:00', '%d %y %a %d %m %b') (unsupported syntax)");
});

describe("Mysql: mysql_time", () => {
  it.todo("TIME_STR_TO_UNIX(x) (unsupported syntax)");
  it("SELECT FROM_UNIXTIME(1711366265, '%Y %D %M')", () => {
    validateIdentity("SELECT FROM_UNIXTIME(1711366265, '%Y %D %M')");
  });
  it.todo("SELECT TO_DAYS(x) (unsupported syntax)");
  it.todo("presto -> mysql: SELECT DATE_DIFF('DAY', y, x) (cross-dialect transform)");
  it.todo("redshift -> mysql: SELECT DATEDIFF(DAY, y, x) (cross-dialect transform)");
  it("mysql -> mysql: SELECT DATEDIFF(x, y)", () => {
    const result = transpile("SELECT DATEDIFF(x, y)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT DATEDIFF(x, y)");
  });
  it.todo("mysql -> presto: SELECT DATEDIFF(x, y) (cross-dialect transform)");
  it.todo("mysql -> redshift: SELECT DATEDIFF(x, y) (cross-dialect transform)");
  it("mysql -> mysql: DAYOFYEAR(x)", () => {
    const result = transpile("DAYOFYEAR(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("DAYOFYEAR(x)");
  });
  it.todo("mysql -> : DAYOFYEAR(x) (cross-dialect transform)");
  it("mysql -> mysql: DAYOFMONTH(x)", () => {
    const result = transpile("DAYOFMONTH(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("DAYOFMONTH(x)");
  });
  it.todo("mysql -> : DAYOFMONTH(x) (cross-dialect transform)");
  it("mysql -> mysql: DAYOFWEEK(x)", () => {
    const result = transpile("DAYOFWEEK(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("DAYOFWEEK(x)");
  });
  it.todo("mysql -> : DAYOFWEEK(x) (cross-dialect transform)");
  it("mysql -> mysql: WEEKOFYEAR(x)", () => {
    const result = transpile("WEEKOFYEAR(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("WEEKOFYEAR(x)");
  });
  it.todo("mysql -> : WEEKOFYEAR(x) (cross-dialect transform)");
  it("mysql -> mysql: DAY(x)", () => {
    const result = transpile("DAY(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("DAY(x)");
  });
  it.todo("mysql -> : DAY(x) (cross-dialect transform)");
  it("mysql -> mysql: WEEK(x)", () => {
    const result = transpile("WEEK(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("WEEK(x)");
  });
  it.todo("mysql -> : WEEK(x) (cross-dialect transform)");
  it("mysql -> mysql: YEAR(x)", () => {
    const result = transpile("YEAR(x)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("YEAR(x)");
  });
  it.todo("mysql -> : YEAR(x) (cross-dialect transform)");
  it.todo(" -> mysql: TS_OR_DS_TO_DATE(x) (unsupported syntax)");
  it.todo(" -> mysql: TS_OR_DS_TO_DATE(x, '%B') (unsupported syntax)");
  it.todo("mysql -> presto: STR_TO_DATE(x, '%Y-%m-%d') (cross-dialect transform)");
  it.todo("mysql -> presto: STR_TO_DATE(x, '%Y-%m-%dT%T') (cross-dialect transform)");
  it.todo("postgres -> mysql: SELECT TO_TIMESTAMP(col) (cross-dialect transform)");
  it("mysql -> mysql: SELECT FROM_UNIXTIME(col)", () => {
    const result = transpile("SELECT FROM_UNIXTIME(col)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT FROM_UNIXTIME(col)");
  });
  it.todo("mysql -> postgres: SELECT FROM_UNIXTIME(col) (cross-dialect transform)");
  it.todo("mysql -> redshift: SELECT FROM_UNIXTIME(col) (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.123456+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.123+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15-08:00', 'America/Los_A... (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15-08:00', 'America/Los_A... (unsupported syntax) (2)");
});

describe("Mysql: mysql_time_python311", () => {
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.12345+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.1234+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.12+00:00') (unsupported syntax)");
  it.todo("SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.1+00:00') (unsupported syntax)");
});

describe("Mysql: mysql", () => {
  it.todo("mysql -> duckdb: SELECT CHAR_LENGTH('foo') (cross-dialect transform)");
  it("mysql -> mysql: SELECT CHAR_LENGTH('foo')", () => {
    const result = transpile("SELECT CHAR_LENGTH('foo')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT CHAR_LENGTH('foo')");
  });
  it.todo("mysql -> postgres: SELECT CHAR_LENGTH('foo') (cross-dialect transform)");
  it.todo("mysql -> duckdb: SELECT CHARACTER_LENGTH('foo') (cross-dialect transform)");
  it("mysql -> mysql: SELECT CHARACTER_LENGTH('foo')", () => {
    const result = transpile("SELECT CHARACTER_LENGTH('foo')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT CHAR_LENGTH('foo')");
  });
  it.todo("mysql -> postgres: SELECT CHARACTER_LENGTH('foo') (cross-dialect transform)");
  it.todo("CURDATE() (unsupported syntax)");
  it.todo("postgres -> mysql: SELECT '11' || '22' (unsupported syntax)");
  it("mysql -> mysql: SELECT CONCAT('11', '22')", () => {
    const result = transpile("SELECT CONCAT('11', '22')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT CONCAT('11', '22')");
  });
  it.todo("mysql -> postgres: SELECT CONCAT('11', '22') (unsupported syntax)");
  it.todo("SELECT department, GROUP_CONCAT(name) AS employee_names FROM data G... (unsupported syntax)");
  it("mysql -> mysql: SELECT UNIX_TIMESTAMP(CAST('2024-04-29 12:00:00' AS DATETIME))", () => {
    const result = transpile("SELECT UNIX_TIMESTAMP(CAST('2024-04-29 12:00:00' AS DATETIME))", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_TIMESTAMP(CAST('2024-04-29 12:00:00' AS DATETIME))");
  });
  it.todo("postgres -> mysql: SELECT EXTRACT(epoch FROM TIMESTAMP '2024-04-29 12:00:00') (unsupported syntax)");
  it("sqlite -> mysql: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')", () => {
    const result = transpile("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')");
  });
  it("mysql -> mysql: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')", () => {
    const result = transpile("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')");
  });
  it.todo("mysql -> sqlite: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]') (unsupported syntax)");
  it("sqlite -> mysql: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", () => {
    const result = transpile("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')");
  });
  it("mysql -> mysql: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", () => {
    const result = transpile("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')");
  });
  it("mysql -> sqlite: SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", () => {
    const result = transpile("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')");
  });
  it.todo("postgres -> mysql: SELECT * FROM x FULL JOIN y ON x.id = y.id ORDER BY 1 LIMIT 0 (cross-dialect transform)");
  it.todo("postgres -> mysql: SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.x = t2.x (cross-dialect transform)");
  it.todo("postgres -> mysql: SELECT * FROM t1 FULL OUTER JOIN t2 USING (x)  (cross-dialect transform)");
  it.todo("postgres -> mysql: SELECT * FROM t1 FULL OUTER JOIN t2 USING (x, y)  (cross-dialect transform)");
  it.todo("a XOR b (unsupported syntax)");
  it.todo("SELECT * FROM test LIMIT 0 + 1, 0 + 1 (unsupported syntax)");
  it("mysql -> mysql: CAST(x AS TEXT)", () => {
    const result = transpile("CAST(x AS TEXT)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS CHAR)");
  });
  it.todo("mysql -> presto: CAST(x AS TEXT) (cross-dialect transform)");
  it.todo("mysql -> starrocks: CAST(x AS TEXT) (cross-dialect transform)");
  it("mysql -> mysql: CAST(x AS SIGNED)", () => {
    const result = transpile("CAST(x AS SIGNED)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS SIGNED)");
  });
  it("mysql -> mysql: CAST(x AS SIGNED INTEGER)", () => {
    const result = transpile("CAST(x AS SIGNED INTEGER)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS SIGNED)");
  });
  it("mysql -> mysql: CAST(x AS UNSIGNED)", () => {
    const result = transpile("CAST(x AS UNSIGNED)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS UNSIGNED)");
  });
  it("mysql -> mysql: CAST(x AS UNSIGNED INTEGER)", () => {
    const result = transpile("CAST(x AS UNSIGNED INTEGER)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("CAST(x AS UNSIGNED)");
  });
  it.todo("TIME_STR_TO_TIME(x) (unsupported syntax)");
  it.todo(`SELECT 17 MEMBER OF('[23, "abc", 17, "ab", 10]') (unsupported syntax)`);
  it.todo("SELECT DATE_ADD('2023-06-23 12:00:00', INTERVAL 2 * 2 MONTH) FROM foo (unsupported syntax)");
  it.todo("mysql -> mysql: SELECT * FROM t LOCK IN SHARE MODE (unsupported clause)");
  it.todo("SELECT DATE(DATE_SUB(`dt`, INTERVAL DAYOFMONTH(`dt`) - 1 DAY)) AS _... (unsupported syntax)");
  it.todo("SELECT name FROM temp WHERE name = ? FOR UPDATE (unsupported clause)");
  it.todo("SELECT a FROM tbl FOR UPDATE (unsupported clause)");
  it.todo("SELECT a FROM tbl FOR SHARE (unsupported clause)");
  it.todo("GROUP_CONCAT(DISTINCT x ORDER BY y DESC) (unsupported syntax)");
  it.todo("GROUP_CONCAT(x ORDER BY y SEPARATOR z) (unsupported syntax)");
  it.todo("GROUP_CONCAT(DISTINCT x ORDER BY y DESC SEPARATOR '') (unsupported syntax)");
  it.todo("GROUP_CONCAT(a, b, c SEPARATOR ',') (unsupported syntax)");
  it.todo("GROUP_CONCAT(a, b, c SEPARATOR '') (unsupported syntax)");
  it.todo("GROUP_CONCAT(DISTINCT a, b, c SEPARATOR '') (unsupported syntax)");
  it.todo("GROUP_CONCAT(a, b, c ORDER BY d SEPARATOR '') (unsupported syntax)");
  it.todo("GROUP_CONCAT(DISTINCT a, b, c ORDER BY d SEPARATOR '') (unsupported syntax)");
  it.todo("CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 CHARACTER SET... (DDL/DML not supported)");
  it.todo("CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARA... (DDL/DML not supported)");
  it.todo("CREATE TABLE z (a INT DEFAULT NULL, PRIMARY KEY (a)) ENGINE=InnoDB ... (DDL/DML not supported)");
  it.todo("\n            CREATE TABLE `t_customer_account` (\n              `id`... (pretty=True not supported)");
});

describe("Mysql: show_events", () => {
  it.todo("test_show_events: assertIsInstance call");
  it.todo("test_show_events: assertEqual call");
  it.todo("test_show_events: assertEqual call (2)");
  it.todo("test_show_events: assertEqual call (3)");
  it.todo("test_show_events: assertEqual call (4)");
  it.todo("test_show_events: assertEqual call (5)");
  it.todo("test_show_events: assertEqual call (6)");
  it.todo("test_show_events: assertIsNone call");
  it.todo("test_show_events: assertIsInstance call (2)");
  it.todo("test_show_events: assertEqual call (7)");
  it.todo("test_show_events: assertEqual call (8)");
  it.todo("test_show_events: assertEqual call (9)");
  it.todo("test_show_events: assertEqual call (10)");
  it.todo("test_show_events: assertEqual call (11)");
  it.todo("test_show_events: assertEqual call (12)");
  it.todo("test_show_events: assertIsNone call (2)");
});

describe("Mysql: show_columns", () => {
  it.todo("test_show_columns: assertIsInstance call");
  it.todo("test_show_columns: assertEqual call");
  it.todo("test_show_columns: assertEqual call (2)");
  it.todo("test_show_columns: assertFalse call");
  it.todo("test_show_columns: assertIsInstance call (2)");
  it.todo("test_show_columns: assertEqual call (3)");
  it.todo("test_show_columns: assertTrue call");
  it.todo("test_show_columns: assertEqual call (4)");
  it.todo("test_show_columns: assertIsInstance call (3)");
  it.todo("test_show_columns: assertEqual call (5)");
});

describe("Mysql: show_name", () => {
  it.todo("test_show_name: assertIsInstance call");
  it.todo("test_show_name: assertEqual call");
  it.todo("test_show_name: assertEqual call (2)");
  it.todo("test_show_name: assertIsInstance call (2)");
  it.todo("test_show_name: assertEqual call (3)");
  it.todo("test_show_name: assertEqual call (4)");
  it.todo("test_show_name: assertIsInstance call (3)");
  it.todo("test_show_name: assertEqual call (5)");
  it.todo("test_show_name: assertEqual call (6)");
  it.todo("test_show_name: assertIsInstance call (4)");
  it.todo("test_show_name: assertEqual call (7)");
  it.todo("test_show_name: assertEqual call (8)");
  it.todo("test_show_name: assertIsInstance call (5)");
  it.todo("test_show_name: assertEqual call (9)");
  it.todo("test_show_name: assertEqual call (10)");
  it.todo("test_show_name: assertIsInstance call (6)");
  it.todo("test_show_name: assertEqual call (11)");
  it.todo("test_show_name: assertEqual call (12)");
  it.todo("test_show_name: assertIsInstance call (7)");
  it.todo("test_show_name: assertEqual call (13)");
  it.todo("test_show_name: assertEqual call (14)");
  it.todo("test_show_name: assertIsInstance call (8)");
  it.todo("test_show_name: assertEqual call (15)");
  it.todo("test_show_name: assertEqual call (16)");
  it.todo("test_show_name: assertIsInstance call (9)");
  it.todo("test_show_name: assertEqual call (17)");
  it.todo("test_show_name: assertEqual call (18)");
});

describe("Mysql: show_grants", () => {
  it.todo("test_show_grants: assertIsInstance call");
  it.todo("test_show_grants: assertEqual call");
  it.todo("test_show_grants: assertEqual call (2)");
});

describe("Mysql: show_engine", () => {
  it.todo("test_show_engine: assertIsInstance call");
  it.todo("test_show_engine: assertEqual call");
  it.todo("test_show_engine: assertEqual call (2)");
  it.todo("test_show_engine: assertFalse call");
  it.todo("test_show_engine: assertEqual call (3)");
  it.todo("test_show_engine: assertEqual call (4)");
  it.todo("test_show_engine: assertTrue call");
});

describe("Mysql: show_errors", () => {
  it.todo("test_show_errors: assertIsInstance call");
  it.todo("test_show_errors: assertEqual call");
  it.todo("test_show_errors: assertEqual call (2)");
  it.todo("test_show_errors: assertEqual call (3)");
  it.todo("test_show_errors: assertIsInstance call (2)");
  it.todo("test_show_errors: assertEqual call (4)");
  it.todo("test_show_errors: assertEqual call (5)");
  it.todo("test_show_errors: assertEqual call (6)");
});

describe("Mysql: show_index", () => {
  it.todo("test_show_index: assertIsInstance call");
  it.todo("test_show_index: assertEqual call");
  it.todo("test_show_index: assertEqual call (2)");
  it.todo("test_show_index: assertEqual call (3)");
  it.todo("SHOW INDEX FROM bar.foo (command not supported)");
});

describe("Mysql: show_db_like_or_where_sql", () => {
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call");
  it.todo("test_show_db_like_or_where_sql: assertEqual call");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (2)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (3)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (4)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (2)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (5)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (6)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (3)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (7)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (4)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (8)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (9)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (10)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (11)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (5)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (12)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (13)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (6)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (14)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (7)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (15)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (16)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (17)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (18)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (8)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (19)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (20)");
  it.todo("test_show_db_like_or_where_sql: assertIsInstance call (9)");
  it.todo("test_show_db_like_or_where_sql: assertEqual call (21)");
});

describe("Mysql: show_processlist", () => {
  it.todo("test_show_processlist: assertIsInstance call");
  it.todo("test_show_processlist: assertEqual call");
  it.todo("test_show_processlist: assertFalse call");
  it.todo("test_show_processlist: assertEqual call (2)");
  it.todo("test_show_processlist: assertTrue call");
});

describe("Mysql: show_profile", () => {
  it.todo("test_show_profile: assertIsInstance call");
  it.todo("test_show_profile: assertEqual call");
  it.todo("test_show_profile: assertEqual call (2)");
  it.todo("test_show_profile: assertEqual call (3)");
  it.todo("test_show_profile: assertEqual call (4)");
  it.todo("test_show_profile: assertEqual call (5)");
  it.todo("test_show_profile: assertEqual call (6)");
  it.todo("test_show_profile: assertEqual call (7)");
});

describe("Mysql: show_replica_status", () => {
  it.todo("test_show_replica_status: assertIsInstance call");
  it.todo("test_show_replica_status: assertEqual call");
  it.todo("test_show_replica_status: assertIsInstance call (2)");
  it.todo("test_show_replica_status: assertEqual call (2)");
  it.todo("test_show_replica_status: assertEqual call (3)");
});

describe("Mysql: show_tables", () => {
  it.todo("test_show_tables: assertIsInstance call");
  it.todo("test_show_tables: assertEqual call");
  it.todo("test_show_tables: assertTrue call");
  it.todo("test_show_tables: assertEqual call (2)");
  it.todo("test_show_tables: assertIsInstance call (2)");
  it.todo("test_show_tables: assertEqual call (3)");
});

describe("Mysql: set_variable", () => {
  it.todo("test_set_variable: assertEqual call");
  it.todo("test_set_variable: assertIsInstance call");
  it.todo("test_set_variable: assertEqual call (2)");
  it.todo("test_set_variable: assertEqual call (3)");
  it.todo("test_set_variable: assertEqual call (4)");
  it.todo("test_set_variable: assertIsInstance call (2)");
  it.todo("test_set_variable: assertIsInstance call (3)");
  it.todo("test_set_variable: assertIsInstance call (4)");
  it.todo("test_set_variable: assertEqual call (5)");
  it.todo("test_set_variable: assertEqual call (6)");
  it.todo("test_set_variable: assertEqual call (7)");
  it.todo("test_set_variable: assertEqual call (8)");
  it.todo("test_set_variable: assertEqual call (9)");
  it.todo("test_set_variable: assertEqual call (10)");
});

describe("Mysql: json_object", () => {
  it("SELECT JSON_OBJECT('id', 87, 'name', 'carrot')", () => {
    validateIdentity("SELECT JSON_OBJECT('id', 87, 'name', 'carrot')");
  });
});

describe("Mysql: is_null", () => {
  it.todo("SELECT ISNULL(x) (unsupported syntax)");
});

describe("Mysql: monthname", () => {
  it.todo("MONTHNAME(x) (unsupported syntax)");
});

describe("Mysql: safe_div", () => {
  it.todo("mysql -> bigquery: a / b (cross-dialect transform)");
  it.todo("mysql -> clickhouse: a / b (cross-dialect transform)");
  it.todo("mysql -> databricks: a / b (cross-dialect transform)");
  it.todo("mysql -> duckdb: a / b (cross-dialect transform)");
  it.todo("mysql -> hive: a / b (cross-dialect transform)");
  it("mysql -> mysql: a / b", () => {
    const result = transpile("a / b", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("a / b");
  });
  it.todo("mysql -> oracle: a / b (cross-dialect transform)");
  it.todo("mysql -> snowflake: a / b (cross-dialect transform)");
  it.todo("mysql -> spark: a / b (cross-dialect transform)");
  it.todo("mysql -> starrocks: a / b (cross-dialect transform)");
  it.todo("mysql -> drill: a / b (cross-dialect transform)");
  it.todo("mysql -> postgres: a / b (cross-dialect transform)");
  it.todo("mysql -> presto: a / b (cross-dialect transform)");
  it.todo("mysql -> redshift: a / b (cross-dialect transform)");
  it.todo("mysql -> sqlite: a / b (cross-dialect transform)");
  it.todo("mysql -> teradata: a / b (cross-dialect transform)");
  it.todo("mysql -> trino: a / b (cross-dialect transform)");
  it.todo("mysql -> tsql: a / b (cross-dialect transform)");
});

describe("Mysql: timestamp_trunc", () => {
  it.todo("test_timestamp_trunc: unresolvable for-loop iterable");
});

describe("Mysql: at_time_zone", () => {
  it.todo("SELECT foo AT TIME ZONE 'UTC' (unsupported syntax)");
  it.todo("test_at_time_zone: assert statement");
});

describe("Mysql: json_value", () => {
  it.todo("test_json_value: unresolvable SQL string");
  it.todo("test_json_value: unresolvable SQL string (2)");
  it.todo("test_json_value: unresolvable SQL string (3)");
  it.todo("test_json_value: unresolvable SQL string (4)");
  it.todo("test_json_value: unresolvable SQL string (5)");
});

describe("Mysql: grant", () => {
  it.todo("test_grant: unresolvable for-loop iterable");
});

describe("Mysql: revoke", () => {
  it.todo("test_revoke: unresolvable for-loop iterable");
});

describe("Mysql: explain", () => {
  it.todo("EXPLAIN ANALYZE SELECT * FROM t (command not supported)");
  it.todo("test_explain: assertIsInstance call");
  it.todo("test_explain: assertEqual call");
  it.todo("DESCRIBE FORMAT=JSON UPDATE test SET test_col = 'abc' (command not supported)");
  it.todo("DESCRIBE FORMAT=TRADITIONAL UPDATE test SET test_col = 'abc' (command not supported)");
  it.todo("DESCRIBE FORMAT=TREE UPDATE test SET test_col = 'abc' (command not supported)");
});

describe("Mysql: number_format", () => {
  it.todo("mysql -> duckdb: SELECT FORMAT(12332.123456, 4) (cross-dialect transform)");
  it("mysql -> mysql: SELECT FORMAT(12332.123456, 4)", () => {
    const result = transpile("SELECT FORMAT(12332.123456, 4)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT FORMAT(12332.123456, 4)");
  });
  it.todo("mysql -> duckdb: SELECT FORMAT(12332.1, 4) (cross-dialect transform)");
  it("mysql -> mysql: SELECT FORMAT(12332.1, 4)", () => {
    const result = transpile("SELECT FORMAT(12332.1, 4)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT FORMAT(12332.1, 4)");
  });
  it.todo("mysql -> duckdb: SELECT FORMAT(12332.2, 0) (cross-dialect transform)");
  it("mysql -> mysql: SELECT FORMAT(12332.2, 0)", () => {
    const result = transpile("SELECT FORMAT(12332.2, 0)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT FORMAT(12332.2, 0)");
  });
  it.todo("SELECT FORMAT(12332.2, 2, 'de_DE') (UnsupportedError in write)");
});

describe("Mysql: analyze", () => {
  it.todo("ANALYZE LOCAL TABLE tbl (command not supported)");
  it.todo("ANALYZE NO_WRITE_TO_BINLOG TABLE tbl (command not supported)");
  it.todo("ANALYZE tbl UPDATE HISTOGRAM ON col1 (command not supported)");
  it.todo("ANALYZE tbl UPDATE HISTOGRAM ON col1 USING DATA 'json_data' (command not supported)");
  it.todo("ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS (command not supported)");
  it.todo("ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS AUTO UPDATE (command not supported)");
  it.todo("ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS MANUAL UPDATE (command not supported)");
  it.todo("ANALYZE tbl DROP HISTOGRAM ON col1 (command not supported)");
});

describe("Mysql: utc_time", () => {
  it.todo("UTC_TIME() (assert_is check)");
  it.todo("UTC_TIME(6) (assert_is check)");
  it.todo("UTC_TIMESTAMP() (assert_is check)");
  it.todo("UTC_TIMESTAMP(6) (assert_is check)");
});

describe("Mysql: mod", () => {
  it.todo("x % y (assert_is check)");
  it.todo("x MOD y (assert_is check)");
  it.todo("MOD(x, y) (assert_is check)");
});

describe("Mysql: numeric_trunc", () => {
  it.todo("TRUNCATE(3.14159, 2) (assert_is check)");
  it.todo("TRUNCATE(price, 0) (assert_is check)");
  it.todo("TRUNC(3.14159, 2) (assert_is check)");
  it.todo("TRUNCATE(3.14159, 2) (DDL/DML not supported)");
});

describe("Mysql: valid_interval_units", () => {
  it.todo("DATE_ADD(base_date, INTERVAL day_interval SECOND_MICROSECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval MINUTE_MICROSECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval MINUTE_SECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval HOUR_MICROSECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval HOUR_SECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval HOUR_MINUTE) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval DAY_MICROSECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval DAY_SECOND) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval DAY_MINUTE) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval DAY_HOUR) (unsupported syntax)");
  it.todo("DATE_ADD(base_date, INTERVAL day_interval YEAR_MONTH) (unsupported syntax)");
});
