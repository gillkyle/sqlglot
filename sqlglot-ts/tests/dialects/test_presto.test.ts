// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "presto";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Presto: cast", () => {
  it.todo("DEALLOCATE PREPARE my_query (check_command_warning)");
  it.todo("DESCRIBE INPUT x (check_command_warning)");
  it.todo("DESCRIBE OUTPUT x (check_command_warning)");
  it.todo("SELECT * FROM x qualify (unsupported clause)");
  it("CAST(x AS IPADDRESS)", () => {
    validateIdentity("CAST(x AS IPADDRESS)");
  });
  it("CAST(x AS IPPREFIX)", () => {
    validateIdentity("CAST(x AS IPPREFIX)");
  });
  it("CAST(TDIGEST_AGG(1) AS TDIGEST)", () => {
    validateIdentity("CAST(TDIGEST_AGG(1) AS TDIGEST)");
  });
  it("CAST(x AS HYPERLOGLOG)", () => {
    validateIdentity("CAST(x AS HYPERLOGLOG)");
  });
  it.todo("RESET SESSION hive.optimized_reader_enabled (check_command_warning)");
  it.todo("TIMESTAMP '2025-06-20 11:22:29 Europe/Prague' (unsupported syntax)");
  it("tsql -> presto: CAST(x AS BIT)", () => {
    const result = transpile("CAST(x AS BIT)", { readDialect: "tsql", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS BOOLEAN)");
  });
  it("presto -> presto: CAST(x AS BOOLEAN)", () => {
    const result = transpile("CAST(x AS BOOLEAN)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS BOOLEAN)");
  });
  it("presto -> tsql: CAST(x AS BOOLEAN)", () => {
    const result = transpile("CAST(x AS BOOLEAN)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("CAST(x AS BIT)");
  });
  it.todo("presto -> duckdb: SELECT FROM_ISO8601_TIMESTAMP('2020-05-11T11:15:05') (unsupported syntax)");
  it("presto -> presto: SELECT FROM_ISO8601_TIMESTAMP('2020-05-11T11:15:05')", () => {
    const result = transpile("SELECT FROM_ISO8601_TIMESTAMP('2020-05-11T11:15:05')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT FROM_ISO8601_TIMESTAMP('2020-05-11T11:15:05')");
  });
  it("presto -> oracle: CAST(x AS INTERVAL YEAR TO MONTH)", () => {
    const result = transpile("CAST(x AS INTERVAL YEAR TO MONTH)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("CAST(x AS INTERVAL YEAR TO MONTH)");
  });
  it("presto -> presto: CAST(x AS INTERVAL YEAR TO MONTH)", () => {
    const result = transpile("CAST(x AS INTERVAL YEAR TO MONTH)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS INTERVAL YEAR TO MONTH)");
  });
  it("presto -> oracle: CAST(x AS INTERVAL DAY TO SECOND)", () => {
    const result = transpile("CAST(x AS INTERVAL DAY TO SECOND)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("CAST(x AS INTERVAL DAY TO SECOND)");
  });
  it("presto -> presto: CAST(x AS INTERVAL DAY TO SECOND)", () => {
    const result = transpile("CAST(x AS INTERVAL DAY TO SECOND)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS INTERVAL DAY TO SECOND)");
  });
  it("postgres -> presto: SELECT CAST('10C' AS INTEGER)", () => {
    const result = transpile("SELECT CAST('10C' AS INTEGER)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('10C' AS INTEGER)");
  });
  it("presto -> presto: SELECT CAST('10C' AS INTEGER)", () => {
    const result = transpile("SELECT CAST('10C' AS INTEGER)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('10C' AS INTEGER)");
  });
  it("redshift -> presto: SELECT CAST('10C' AS INTEGER)", () => {
    const result = transpile("SELECT CAST('10C' AS INTEGER)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST('10C' AS INTEGER)");
  });
  it.todo("SELECT CAST('1970-01-01 00:00:00' AS TIMESTAMP) (unsupported syntax)");
  it("hive -> presto: UNBASE64(x)", () => {
    const result = transpile("UNBASE64(x)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("FROM_BASE64(x)");
  });
  it("presto -> hive: FROM_BASE64(x)", () => {
    const result = transpile("FROM_BASE64(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("UNBASE64(x)");
  });
  it("presto -> presto: FROM_BASE64(x)", () => {
    const result = transpile("FROM_BASE64(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("FROM_BASE64(x)");
  });
  it("hive -> presto: BASE64(x)", () => {
    const result = transpile("BASE64(x)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_BASE64(x)");
  });
  it("presto -> hive: TO_BASE64(x)", () => {
    const result = transpile("TO_BASE64(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("BASE64(x)");
  });
  it("presto -> presto: TO_BASE64(x)", () => {
    const result = transpile("TO_BASE64(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_BASE64(x)");
  });
  it.todo("CAST(a AS ARRAY(INT)) (unsupported syntax)");
  it("presto -> bigquery: CAST(a AS VARCHAR)", () => {
    const result = transpile("CAST(a AS VARCHAR)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("CAST(a AS STRING)");
  });
  it.todo("presto -> duckdb: CAST(a AS VARCHAR) (cross-dialect transform)");
  it("presto -> presto: CAST(a AS VARCHAR)", () => {
    const result = transpile("CAST(a AS VARCHAR)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(a AS VARCHAR)");
  });
  it("presto -> spark: CAST(a AS VARCHAR)", () => {
    const result = transpile("CAST(a AS VARCHAR)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(a AS STRING)");
  });
  it.todo("CAST(ARRAY[1, 2] AS ARRAY(BIGINT)) (unsupported syntax)");
  it.todo("CAST(MAP(ARRAY['key'], ARRAY[1]) AS MAP(VARCHAR, INT)) (unsupported syntax)");
  it.todo("CAST(MAP(ARRAY['a','b','c'], ARRAY[ARRAY[1], ARRAY[2], ARRAY[3]]) A... (unsupported syntax)");
  it("presto -> duckdb: CAST(x AS TIME(5) WITH TIME ZONE)", () => {
    const result = transpile("CAST(x AS TIME(5) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(x AS TIMETZ)");
  });
  it("presto -> postgres: CAST(x AS TIME(5) WITH TIME ZONE)", () => {
    const result = transpile("CAST(x AS TIME(5) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS TIMETZ(5))");
  });
  it("presto -> presto: CAST(x AS TIME(5) WITH TIME ZONE)", () => {
    const result = transpile("CAST(x AS TIME(5) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS TIME(5) WITH TIME ZONE)");
  });
  it("presto -> redshift: CAST(x AS TIME(5) WITH TIME ZONE)", () => {
    const result = transpile("CAST(x AS TIME(5) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("CAST(x AS TIME(5) WITH TIME ZONE)");
  });
  it.todo("presto -> bigquery: CAST(x AS TIMESTAMP(9) WITH TIME ZONE) (unsupported syntax)");
  it.todo("presto -> duckdb: CAST(x AS TIMESTAMP(9) WITH TIME ZONE) (unsupported syntax)");
  it("presto -> presto: CAST(x AS TIMESTAMP(9) WITH TIME ZONE)", () => {
    const result = transpile("CAST(x AS TIMESTAMP(9) WITH TIME ZONE)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(x AS TIMESTAMP(9) WITH TIME ZONE)");
  });
  it.todo("presto -> hive: CAST(x AS TIMESTAMP(9) WITH TIME ZONE) (unsupported syntax)");
  it.todo("presto -> spark: CAST(x AS TIMESTAMP(9) WITH TIME ZONE) (unsupported syntax)");
});

describe("Presto: replace", () => {
  it("presto -> bigquery: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("presto -> duckdb: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("presto -> hive: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("presto -> snowflake: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("presto -> spark: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("presto -> presto: REPLACE(subject, pattern)", () => {
    const result = transpile("REPLACE(subject, pattern)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REPLACE(subject, pattern, '')");
  });
  it("bigquery -> presto: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("duckdb -> presto: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("hive -> presto: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("spark -> presto: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> presto: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> bigquery: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> duckdb: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> hive: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> snowflake: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> spark: REPLACE(subject, pattern, replacement)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
  it("presto -> presto: REPLACE(subject, pattern, replacement) (2)", () => {
    const result = transpile("REPLACE(subject, pattern, replacement)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REPLACE(subject, pattern, replacement)");
  });
});

describe("Presto: regex", () => {
  it("presto -> presto: REGEXP_REPLACE('abcd', '[ab]')", () => {
    const result = transpile("REGEXP_REPLACE('abcd', '[ab]')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_REPLACE('abcd', '[ab]', '')");
  });
  it("presto -> spark: REGEXP_REPLACE('abcd', '[ab]')", () => {
    const result = transpile("REGEXP_REPLACE('abcd', '[ab]')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_REPLACE('abcd', '[ab]', '')");
  });
  it("presto -> duckdb: REGEXP_LIKE(a, 'x')", () => {
    const result = transpile("REGEXP_LIKE(a, 'x')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_MATCHES(a, 'x')");
  });
  it("presto -> presto: REGEXP_LIKE(a, 'x')", () => {
    const result = transpile("REGEXP_LIKE(a, 'x')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_LIKE(a, 'x')");
  });
  it("presto -> hive: REGEXP_LIKE(a, 'x')", () => {
    const result = transpile("REGEXP_LIKE(a, 'x')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
  it("presto -> spark: REGEXP_LIKE(a, 'x')", () => {
    const result = transpile("REGEXP_LIKE(a, 'x')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
  it("presto -> duckdb: SPLIT(x, 'a.')", () => {
    const result = transpile("SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STR_SPLIT(x, 'a.')");
  });
  it("presto -> presto: SPLIT(x, 'a.')", () => {
    const result = transpile("SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SPLIT(x, 'a.')");
  });
  it.todo("presto -> hive: SPLIT(x, 'a.') (unsupported syntax)");
  it.todo("presto -> spark: SPLIT(x, 'a.') (unsupported syntax)");
  it("presto -> duckdb: REGEXP_SPLIT(x, 'a.')", () => {
    const result = transpile("REGEXP_SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STR_SPLIT_REGEX(x, 'a.')");
  });
  it("presto -> presto: REGEXP_SPLIT(x, 'a.')", () => {
    const result = transpile("REGEXP_SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_SPLIT(x, 'a.')");
  });
  it("presto -> hive: REGEXP_SPLIT(x, 'a.')", () => {
    const result = transpile("REGEXP_SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SPLIT(x, 'a.')");
  });
  it("presto -> spark: REGEXP_SPLIT(x, 'a.')", () => {
    const result = transpile("REGEXP_SPLIT(x, 'a.')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SPLIT(x, 'a.')");
  });
  it.todo("presto -> duckdb: CARDINALITY(x) (cross-dialect transform)");
  it("presto -> presto: CARDINALITY(x)", () => {
    const result = transpile("CARDINALITY(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CARDINALITY(x)");
  });
  it.todo("presto -> hive: CARDINALITY(x) (cross-dialect transform)");
  it.todo("presto -> spark: CARDINALITY(x) (cross-dialect transform)");
  it("presto -> hive: ARRAY_JOIN(x, '-', 'a')", () => {
    const result = transpile("ARRAY_JOIN(x, '-', 'a')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CONCAT_WS('-', x)");
  });
  it("presto -> spark: ARRAY_JOIN(x, '-', 'a')", () => {
    const result = transpile("ARRAY_JOIN(x, '-', 'a')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ARRAY_JOIN(x, '-', 'a')");
  });
  it.todo("presto -> bigquery: STRPOS(haystack, needle, occurrence) (unsupported syntax)");
  it.todo("presto -> oracle: STRPOS(haystack, needle, occurrence) (unsupported syntax)");
  it("presto -> presto: STRPOS(haystack, needle, occurrence)", () => {
    const result = transpile("STRPOS(haystack, needle, occurrence)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("STRPOS(haystack, needle, occurrence)");
  });
  it("presto -> tableau: STRPOS(haystack, needle, occurrence)", () => {
    const result = transpile("STRPOS(haystack, needle, occurrence)", { readDialect: DIALECT, writeDialect: "tableau" })[0];
    expect(result).toBe("FINDNTH(haystack, needle, occurrence)");
  });
  it("presto -> trino: STRPOS(haystack, needle, occurrence)", () => {
    const result = transpile("STRPOS(haystack, needle, occurrence)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("STRPOS(haystack, needle, occurrence)");
  });
  it.todo("presto -> teradata: STRPOS(haystack, needle, occurrence) (unsupported syntax)");
});

describe("Presto: time", () => {
  it.todo("test_time: assertEqual call");
  it("FROM_UNIXTIME(a, b)", () => {
    validateIdentity("FROM_UNIXTIME(a, b)");
  });
  it("FROM_UNIXTIME(a, b, c)", () => {
    validateIdentity("FROM_UNIXTIME(a, b, c)");
  });
  it("TRIM(a, b)", () => {
    validateIdentity("TRIM(a, b)");
  });
  it("VAR_POP(a)", () => {
    validateIdentity("VAR_POP(a)");
  });
  it("presto -> presto: SELECT FROM_UNIXTIME(col) FROM tbl", () => {
    const result = transpile("SELECT FROM_UNIXTIME(col) FROM tbl", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT FROM_UNIXTIME(col) FROM tbl");
  });
  it.todo("presto -> spark: SELECT FROM_UNIXTIME(col) FROM tbl (cross-dialect transform)");
  it.todo("presto -> trino: SELECT FROM_UNIXTIME(col) FROM tbl (cross-dialect transform)");
  it.todo("DATE_FORMAT(x, '%Y-%m-%d %H:%i:%S') (unsupported syntax)");
  it.todo("presto -> duckdb: DATE_PARSE(x, '%Y-%m-%d %H:%i:%S') (cross-dialect transform)");
  it("presto -> presto: DATE_PARSE(x, '%Y-%m-%d %H:%i:%S')", () => {
    const result = transpile("DATE_PARSE(x, '%Y-%m-%d %H:%i:%S')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_PARSE(x, '%Y-%m-%d %T')");
  });
  it.todo("presto -> hive: DATE_PARSE(x, '%Y-%m-%d %H:%i:%S') (unsupported syntax)");
  it.todo("presto -> spark: DATE_PARSE(x, '%Y-%m-%d %H:%i:%S') (cross-dialect transform)");
  it.todo("presto -> duckdb: DATE_PARSE(x, '%Y-%m-%d') (cross-dialect transform)");
  it("presto -> presto: DATE_PARSE(x, '%Y-%m-%d')", () => {
    const result = transpile("DATE_PARSE(x, '%Y-%m-%d')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_PARSE(x, '%Y-%m-%d')");
  });
  it.todo("presto -> hive: DATE_PARSE(x, '%Y-%m-%d') (unsupported syntax)");
  it.todo("presto -> spark: DATE_PARSE(x, '%Y-%m-%d') (cross-dialect transform)");
  it.todo("DATE_FORMAT(x, '%T') (unsupported syntax)");
  it.todo("presto -> duckdb: DATE_PARSE(SUBSTR(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it("presto -> presto: DATE_PARSE(SUBSTR(x, 1, 10), '%Y-%m-%d')", () => {
    const result = transpile("DATE_PARSE(SUBSTR(x, 1, 10), '%Y-%m-%d')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d')");
  });
  it.todo("presto -> hive: DATE_PARSE(SUBSTR(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it.todo("presto -> spark: DATE_PARSE(SUBSTR(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it.todo("presto -> duckdb: DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it("presto -> presto: DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d')", () => {
    const result = transpile("DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d')");
  });
  it.todo("presto -> hive: DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it.todo("presto -> spark: DATE_PARSE(SUBSTRING(x, 1, 10), '%Y-%m-%d') (cross-dialect transform)");
  it.todo("presto -> duckdb: FROM_UNIXTIME(x) (cross-dialect transform)");
  it("presto -> presto: FROM_UNIXTIME(x)", () => {
    const result = transpile("FROM_UNIXTIME(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("FROM_UNIXTIME(x)");
  });
  it.todo("presto -> hive: FROM_UNIXTIME(x) (cross-dialect transform)");
  it.todo("presto -> spark: FROM_UNIXTIME(x) (cross-dialect transform)");
  it("presto -> duckdb: TO_UNIXTIME(x)", () => {
    const result = transpile("TO_UNIXTIME(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EPOCH(x)");
  });
  it("presto -> presto: TO_UNIXTIME(x)", () => {
    const result = transpile("TO_UNIXTIME(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_UNIXTIME(x)");
  });
  it("presto -> hive: TO_UNIXTIME(x)", () => {
    const result = transpile("TO_UNIXTIME(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("UNIX_TIMESTAMP(x)");
  });
  it("presto -> spark: TO_UNIXTIME(x)", () => {
    const result = transpile("TO_UNIXTIME(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UNIX_TIMESTAMP(x)");
  });
  it("presto -> duckdb: DATE_ADD('DAY', 1, x)", () => {
    const result = transpile("DATE_ADD('DAY', 1, x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x + INTERVAL 1 DAY");
  });
  it("presto -> presto: DATE_ADD('DAY', 1, x)", () => {
    const result = transpile("DATE_ADD('DAY', 1, x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_ADD('DAY', 1, x)");
  });
  it("presto -> hive: DATE_ADD('DAY', 1, x)", () => {
    const result = transpile("DATE_ADD('DAY', 1, x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DATE_ADD(x, 1)");
  });
  it("presto -> spark: DATE_ADD('DAY', 1, x)", () => {
    const result = transpile("DATE_ADD('DAY', 1, x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DATE_ADD(x, 1)");
  });
  it("presto -> presto: DATE_ADD('DAY', 1 * -1, x)", () => {
    const result = transpile("DATE_ADD('DAY', 1 * -1, x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_ADD('DAY', 1 * -1, x)");
  });
  it.todo("NOW() (unsupported syntax)");
  it.todo("SELECT DATE_ADD('DAY', 1, CAST(CURRENT_DATE AS TIMESTAMP)) (unsupported syntax)");
  it.todo("spark -> presto: DAYOFWEEK(CAST('2012-08-08 01:00:00' AS TIMESTAMP)) (unsupported syntax)");
  it.todo("DAY_OF_WEEK(CAST('2012-08-08 01:00:00' AS TIMESTAMP)) (unsupported syntax)");
  it.todo("DAY_OF_MONTH(timestamp '2012-08-08 01:00:00') (unsupported syntax)");
  it.todo("DAY_OF_YEAR(timestamp '2012-08-08 01:00:00') (unsupported syntax)");
  it.todo("WEEK_OF_YEAR(timestamp '2012-08-08 01:00:00') (unsupported syntax)");
  it.todo("SELECT CAST('2012-10-31 00:00' AS TIMESTAMP) AT TIME ZONE 'America/... (unsupported syntax)");
  it.todo("spark -> presto: SELECT FROM_UTC_TIMESTAMP(TIMESTAMP '2012-10-31 00:00', 'America/Sao_P... (unsupported syntax)");
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax)");
  it.todo("CAST(x AS TIMESTAMP) (unsupported syntax) (2)");
  it("presto -> duckdb: TIMESTAMP(x, '12:00:00')", () => {
    const result = transpile("TIMESTAMP(x, '12:00:00')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TIMESTAMP(x, '12:00:00')");
  });
  it("presto -> presto: TIMESTAMP(x, '12:00:00')", () => {
    const result = transpile("TIMESTAMP(x, '12:00:00')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TIMESTAMP(x, '12:00:00')");
  });
  it("presto -> presto: DATE_ADD('DAY', x, y)", () => {
    const result = transpile("DATE_ADD('DAY', x, y)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_ADD('DAY', CAST(x AS BIGINT), y)");
  });
  it("presto -> presto: DATE_ADD('DAY', CAST(x AS BIGINT), y)", () => {
    const result = transpile("DATE_ADD('DAY', CAST(x AS BIGINT), y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("DATE_ADD('DAY', CAST(x AS BIGINT), y)");
  });
  it("DATE_ADD('DAY', 1, y)", () => {
    validateIdentity("DATE_ADD('DAY', 1, y)");
  });
  it("presto -> presto: SELECT DATE_ADD('MINUTE', 30, col)", () => {
    const result = transpile("SELECT DATE_ADD('MINUTE', 30, col)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT DATE_ADD('MINUTE', 30, col)");
  });
  it("presto -> trino: SELECT DATE_ADD('MINUTE', 30, col)", () => {
    const result = transpile("SELECT DATE_ADD('MINUTE', 30, col)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT DATE_ADD('MINUTE', 30, col)");
  });
  it("DATE_ADD('DAY', FLOOR(5), y)", () => {
    validateIdentity("DATE_ADD('DAY', FLOOR(5), y)");
  });
  it("SELECT DATE_ADD('DAY', MOD(5, 2.5), y), DATE_ADD('DAY', CEIL(5.5), y) -> SELECT DATE_AD...", () => {
    validateIdentity("SELECT DATE_ADD('DAY', MOD(5, 2.5), y), DATE_ADD('DAY', CEIL(5.5), y)", "SELECT DATE_ADD('DAY', CAST(5 % 2.5 AS BIGINT), y), DATE_ADD('DAY', CAST(CEIL(5.5) AS BIGINT), y)");
  });
  it("spark -> presto: TIMESTAMPADD(MINUTE, FLOOR(EXTRACT(MINUTE FROM CURRENT_TIMESTAMP)/30)*...", () => {
    const result = transpile("TIMESTAMPADD(MINUTE, FLOOR(EXTRACT(MINUTE FROM CURRENT_TIMESTAMP)/30)*30, col)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_ADD('MINUTE', CAST(FLOOR(CAST(EXTRACT(MINUTE FROM CURRENT_TIMESTAMP) AS DOUBLE) / NULLIF(30, 0)) * 30 AS BIGINT), col)");
  });
  it("presto -> presto: SELECT WEEK(y)", () => {
    const result = transpile("SELECT WEEK(y)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT WEEK_OF_YEAR(y)");
  });
  it.todo("presto -> spark: SELECT WEEK_OF_YEAR(y) (cross-dialect transform)");
  it("presto -> presto: SELECT WEEK_OF_YEAR(y)", () => {
    const result = transpile("SELECT WEEK_OF_YEAR(y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT WEEK_OF_YEAR(y)");
  });
  it("presto -> trino: SELECT WEEK_OF_YEAR(y)", () => {
    const result = transpile("SELECT WEEK_OF_YEAR(y)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("SELECT WEEK_OF_YEAR(y)");
  });
});

describe("Presto: ddl", () => {
  it.todo("CREATE TABLE test WITH (FORMAT = 'PARQUET') AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE TABLE test STORED AS 'PARQUET' AS SELECT 1 (DDL/DML not supported)");
  it.todo("CREATE TABLE test WITH (FORMAT = 'PARQUET', X = '1', Z = '2') AS SE... (DDL/DML not supported)");
  it.todo("CREATE TABLE x (w VARCHAR, y INTEGER, z INTEGER) WITH (PARTITIONED_... (DDL/DML not supported)");
  it.todo("CREATE TABLE x WITH (bucket_by = ARRAY['y'], bucket_count = 64) AS ... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (col_a ROW(struct_col_a INTEGER, stru... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (col_a ROW(struct_col_a INTEGER, stru... (DDL/DML not supported) (2)");
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it.todo("CREATE OR REPLACE VIEW x (cola) SELECT 1 as cola (DDL/DML not supported)");
  it.todo(`CREATE TABLE IF NOT EXISTS x ("cola" INTEGER, "ds" TEXT) COMMENT 'c... (DDL/DML not supported)`);
  it.todo("CREATE OR REPLACE VIEW v SECURITY DEFINER AS SELECT id FROM t (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE VIEW v SECURITY INVOKER AS SELECT id FROM t (DDL/DML not supported)");
});

describe("Presto: quotes", () => {
  it.todo("'''' (unsupported syntax)");
  it("presto -> duckdb: 'x'", () => {
    const result = transpile("'x'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'x'");
  });
  it("presto -> presto: 'x'", () => {
    const result = transpile("'x'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'x'");
  });
  it("presto -> hive: 'x'", () => {
    const result = transpile("'x'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'x'");
  });
  it("presto -> spark: 'x'", () => {
    const result = transpile("'x'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'x'");
  });
  it.todo("'''x''' (unsupported syntax)");
  it.todo("'''x' (unsupported syntax)");
  it.todo("x IN ('a', 'a''b') (unsupported syntax)");
});

describe("Presto: unnest", () => {
  it.todo("SELECT a FROM x CROSS JOIN UNNEST(ARRAY(y)) AS t (a) (unsupported syntax)");
  it.todo("SELECT a FROM x CROSS JOIN UNNEST(ARRAY(y)) AS t (a) CROSS JOIN b (unsupported syntax)");
});

describe("Presto: unicode_string", () => {
  it("presto -> oracle: u&'Hello winter \\2603 !'", () => {
    const result = transpile("u&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("U'Hello winter \\2603 !'");
  });
  it("presto -> presto: u&'Hello winter \\2603 !'", () => {
    const result = transpile("u&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("U&'Hello winter \\2603 !'");
  });
  it("presto -> snowflake: u&'Hello winter \\2603 !'", () => {
    const result = transpile("u&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> spark: u&'Hello winter \\2603 !'", () => {
    const result = transpile("u&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> oracle: u&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("u&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("U'Hello winter \\2603 !'");
  });
  it("presto -> presto: u&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("u&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("U&'Hello winter #2603 !' UESCAPE '#'");
  });
  it("presto -> snowflake: u&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("u&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> spark: u&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("u&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> oracle: U&'Hello winter \\2603 !'", () => {
    const result = transpile("U&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("U'Hello winter \\2603 !'");
  });
  it("presto -> presto: U&'Hello winter \\2603 !'", () => {
    const result = transpile("U&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("U&'Hello winter \\2603 !'");
  });
  it("presto -> snowflake: U&'Hello winter \\2603 !'", () => {
    const result = transpile("U&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> spark: U&'Hello winter \\2603 !'", () => {
    const result = transpile("U&'Hello winter \\2603 !'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> oracle: U&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("U&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("U'Hello winter \\2603 !'");
  });
  it("presto -> presto: U&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("U&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("U&'Hello winter #2603 !' UESCAPE '#'");
  });
  it("presto -> snowflake: U&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("U&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
  it("presto -> spark: U&'Hello winter #2603 !' UESCAPE '#'", () => {
    const result = transpile("U&'Hello winter #2603 !' UESCAPE '#'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'Hello winter \\u2603 !'");
  });
});

describe("Presto: presto", () => {
  it.todo("test_presto: assertEqual call");
  it.todo("SELECT COALESCE(ELEMENT_AT(MAP_FROM_ENTRIES(ARRAY[(51, '1')]), id),... (UnsupportedError in write)");
  it.todo("SELECT ELEMENT_AT(ARRAY[1, 2, 3], 4) (unsupported syntax)");
  it.todo("SELECT a FROM t GROUP BY a, ROLLUP (b), ROLLUP (c), ROLLUP (d) (unsupported clause)");
  it.todo("SELECT a FROM test TABLESAMPLE BERNOULLI (50) (unsupported clause)");
  it.todo("SELECT a FROM test TABLESAMPLE SYSTEM (75) (unsupported clause)");
  it.todo("string_agg(x, ',') (unsupported syntax)");
  it("SELECT * FROM x OFFSET 1 LIMIT 1", () => {
    validateIdentity("SELECT * FROM x OFFSET 1 LIMIT 1");
  });
  it.todo("SELECT * FROM x OFFSET 1 FETCH FIRST 1 ROWS ONLY (unsupported clause)");
  it("SELECT BOOL_OR(a > 10) FROM asd AS T(a)", () => {
    validateIdentity("SELECT BOOL_OR(a > 10) FROM asd AS T(a)");
  });
  it.todo("TRUNCATE(3.14159, 2) (assert_is check)");
  it.todo("TRUNCATE(3.14159) (assert_is check)");
  it.todo("TRUNCATE(3.14159, 2) (DDL/DML not supported)");
  it.todo("SELECT * FROM (VALUES (1)) (unsupported syntax)");
  it("START TRANSACTION READ WRITE, ISOLATION LEVEL SERIALIZABLE", () => {
    validateIdentity("START TRANSACTION READ WRITE, ISOLATION LEVEL SERIALIZABLE");
  });
  it("START TRANSACTION ISOLATION LEVEL REPEATABLE READ", () => {
    validateIdentity("START TRANSACTION ISOLATION LEVEL REPEATABLE READ");
  });
  it("APPROX_PERCENTILE(a, b, c, d)", () => {
    validateIdentity("APPROX_PERCENTILE(a, b, c, d)");
  });
  it("SELECT SPLIT_TO_MAP('a:1;b:2;a:3', ';', ':', (k, v1, v2) -> CONCAT(v1, v2))", () => {
    validateIdentity("SELECT SPLIT_TO_MAP('a:1;b:2;a:3', ';', ':', (k, v1, v2) -> CONCAT(v1, v2))");
  });
  it("SELECT * FROM example.testdb.customer_orders FOR VERSION AS OF 8954597067493422955", () => {
    validateIdentity("SELECT * FROM example.testdb.customer_orders FOR VERSION AS OF 8954597067493422955");
  });
  it.todo("SELECT * FROM example.testdb.customer_orders FOR TIMESTAMP AS OF CA... (unsupported syntax)");
  it.todo("SELECT origin_state, destination_state, origin_zip, SUM(package_wei... (unsupported clause)");
  it.todo("SELECT origin_state, destination_state, origin_zip, SUM(package_wei... (unsupported clause) (2)");
  it("SELECT JSON_EXTRACT_SCALAR(CAST(extra AS JSON), '$.value_b'), COUNT(*) FROM table_a GRO...", () => {
    validateIdentity("SELECT JSON_EXTRACT_SCALAR(CAST(extra AS JSON), '$.value_b'), COUNT(*) FROM table_a GROUP BY DISTINCT (JSON_EXTRACT_SCALAR(CAST(extra AS JSON), '$.value_b'))");
  });
  it("duckdb -> presto: SELECT LAST_DAY(CAST('2008-11-25' AS DATE))", () => {
    const result = transpile("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))");
  });
  it("presto -> duckdb: SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))", () => {
    const result = transpile("SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT LAST_DAY(CAST('2008-11-25' AS DATE))");
  });
  it("presto -> presto: SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))", () => {
    const result = transpile("SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT LAST_DAY_OF_MONTH(CAST('2008-11-25' AS DATE))");
  });
  it("bigquery -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("clickhouse -> presto: SELECT argMax(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT argMax(a.id, a.timestamp) FROM a", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("duckdb -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("snowflake -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("spark -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("teradata -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> bigquery: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> clickhouse: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT argMax(a.id, a.timestamp) FROM a");
  });
  it("presto -> duckdb: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MAX(a.id, a.timestamp) FROM a");
  });
  it("presto -> presto: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> snowflake: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> spark: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> teradata: SELECT MAX_BY(a.id, a.timestamp) FROM a", () => {
    const result = transpile("SELECT MAX_BY(a.id, a.timestamp) FROM a", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("SELECT MAX_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> clickhouse: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT argMin(a.id, a.timestamp) FROM a");
  });
  it("presto -> duckdb: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARG_MIN(a.id, a.timestamp, 3) FROM a");
  });
  it("presto -> presto: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a");
  });
  it("presto -> snowflake: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a");
  });
  it("presto -> spark: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT MIN_BY(a.id, a.timestamp) FROM a");
  });
  it("presto -> teradata: SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", () => {
    const result = transpile("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("SELECT MIN_BY(a.id, a.timestamp, 3) FROM a");
  });
  it(`presto -> bigquery: JSON '"foo"'`, () => {
    const result = transpile(`JSON '"foo"'`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`PARSE_JSON('"foo"')`);
  });
  it(`presto -> postgres: JSON '"foo"'`, () => {
    const result = transpile(`JSON '"foo"'`, { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe(`CAST('"foo"' AS JSON)`);
  });
  it(`presto -> presto: JSON '"foo"'`, () => {
    const result = transpile(`JSON '"foo"'`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`JSON_PARSE('"foo"')`);
  });
  it(`presto -> snowflake: JSON '"foo"'`, () => {
    const result = transpile(`JSON '"foo"'`, { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe(`PARSE_JSON('"foo"')`);
  });
  it("presto -> presto: SELECT ROW(1, 2)", () => {
    const result = transpile("SELECT ROW(1, 2)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT ROW(1, 2)");
  });
  it("presto -> spark: SELECT ROW(1, 2)", () => {
    const result = transpile("SELECT ROW(1, 2)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT STRUCT(1, 2)");
  });
  it.todo("bigquery -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it("clickhouse -> presto: any(x)", () => {
    const result = transpile("any(x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("ARBITRARY(x)");
  });
  it.todo("databricks -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("doris -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("drill -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it("hive -> presto: FIRST(x)", () => {
    const result = transpile("FIRST(x)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("ARBITRARY(x)");
  });
  it.todo("mysql -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("oracle -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("redshift -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("snowflake -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it.todo("spark -> presto: ANY_VALUE(x) (cross-dialect transform)");
  it("spark2 -> presto: FIRST(x)", () => {
    const result = transpile("FIRST(x)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("ARBITRARY(x)");
  });
  it.todo("presto -> bigquery: ARBITRARY(x) (cross-dialect transform)");
  it("presto -> clickhouse: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("any(x)");
  });
  it.todo("presto -> databricks: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> doris: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> drill: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> duckdb: ARBITRARY(x) (cross-dialect transform)");
  it("presto -> hive: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("FIRST(x)");
  });
  it.todo("presto -> mysql: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> oracle: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> postgres: ARBITRARY(x) (cross-dialect transform)");
  it("presto -> presto: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARBITRARY(x)");
  });
  it.todo("presto -> redshift: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> snowflake: ARBITRARY(x) (cross-dialect transform)");
  it.todo("presto -> spark: ARBITRARY(x) (cross-dialect transform)");
  it("presto -> spark2: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("FIRST(x)");
  });
  it("presto -> sqlite: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("MAX(x)");
  });
  it("presto -> tsql: ARBITRARY(x)", () => {
    const result = transpile("ARBITRARY(x)", { readDialect: DIALECT, writeDialect: "tsql" })[0];
    expect(result).toBe("MAX(x)");
  });
  it("spark -> presto: STARTSWITH('abc', 'a')", () => {
    const result = transpile("STARTSWITH('abc', 'a')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("STARTS_WITH('abc', 'a')");
  });
  it("presto -> presto: STARTS_WITH('abc', 'a')", () => {
    const result = transpile("STARTS_WITH('abc', 'a')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("STARTS_WITH('abc', 'a')");
  });
  it("presto -> snowflake: STARTS_WITH('abc', 'a')", () => {
    const result = transpile("STARTS_WITH('abc', 'a')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("STARTSWITH('abc', 'a')");
  });
  it("presto -> spark: STARTS_WITH('abc', 'a')", () => {
    const result = transpile("STARTS_WITH('abc', 'a')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("STARTSWITH('abc', 'a')");
  });
  it("spark -> presto: ISNAN(x)", () => {
    const result = transpile("ISNAN(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("IS_NAN(x)");
  });
  it("presto -> presto: IS_NAN(x)", () => {
    const result = transpile("IS_NAN(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IS_NAN(x)");
  });
  it("presto -> spark: IS_NAN(x)", () => {
    const result = transpile("IS_NAN(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ISNAN(x)");
  });
  it("presto -> spark2: IS_NAN(x)", () => {
    const result = transpile("IS_NAN(x)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("ISNAN(x)");
  });
  it.todo("presto -> presto: VALUES 1, 2, 3 (unsupported syntax)");
  it.todo("presto -> trino: INTERVAL '1 day' (unsupported syntax)");
  it.todo("(5 * INTERVAL '7' DAY) (unsupported syntax)");
  it.todo("(5 * INTERVAL '7' DAY) (unsupported syntax) (2)");
  it("redshift -> presto: SELECT LEFT(a, 3), RIGHT(a, 3)", () => {
    const result = transpile("SELECT LEFT(a, 3), RIGHT(a, 3)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SUBSTRING(a, 1, 3), SUBSTRING(a, LENGTH(a) - (3 - 1))");
  });
  it.todo("WITH RECURSIVE t(n) AS (SELECT 1 AS n UNION ALL SELECT n + 1 AS n F... (unsupported syntax)");
  it.todo("WITH RECURSIVE t(n, k) AS (SELECT 1 AS n, 2 AS k) SELECT SUM(n) FROM t (unsupported syntax)");
  it.todo("WITH RECURSIVE t1(n) AS (SELECT 1 AS n), t2(n) AS (SELECT 2 AS n) S... (unsupported syntax)");
  it.todo("WITH RECURSIVE t(n, _c_0) AS (SELECT 1 AS n, (1 + 2)) SELECT * FROM t (unsupported syntax)");
  it.todo('WITH RECURSIVE t(n, "1") AS (SELECT n, 1 FROM tbl) SELECT * FROM t (unsupported syntax)');
  it("presto -> presto: SELECT JSON_OBJECT(KEY 'key1' VALUE 1, KEY 'key2' VALUE TRUE)", () => {
    const result = transpile("SELECT JSON_OBJECT(KEY 'key1' VALUE 1, KEY 'key2' VALUE TRUE)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT JSON_OBJECT('key1': 1, 'key2': TRUE)");
  });
  it("presto -> hive: ARRAY_AGG(x ORDER BY y DESC)", () => {
    const result = transpile("ARRAY_AGG(x ORDER BY y DESC)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("COLLECT_LIST(x)");
  });
  it("presto -> presto: ARRAY_AGG(x ORDER BY y DESC)", () => {
    const result = transpile("ARRAY_AGG(x ORDER BY y DESC)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ARRAY_AGG(x ORDER BY y DESC)");
  });
  it("presto -> spark: ARRAY_AGG(x ORDER BY y DESC)", () => {
    const result = transpile("ARRAY_AGG(x ORDER BY y DESC)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("COLLECT_LIST(x)");
  });
  it("presto -> trino: ARRAY_AGG(x ORDER BY y DESC)", () => {
    const result = transpile("ARRAY_AGG(x ORDER BY y DESC)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("ARRAY_AGG(x ORDER BY y DESC)");
  });
  it('presto -> duckdb: SELECT a."b" FROM "foo"', () => {
    const result = transpile('SELECT a."b" FROM "foo"', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe('SELECT a."b" FROM "foo"');
  });
  it('presto -> presto: SELECT a."b" FROM "foo"', () => {
    const result = transpile('SELECT a."b" FROM "foo"', { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe('SELECT a."b" FROM "foo"');
  });
  it('presto -> spark: SELECT a."b" FROM "foo"', () => {
    const result = transpile('SELECT a."b" FROM "foo"', { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT a.`b` FROM `foo`");
  });
  it.todo("SELECT ARRAY[1, 2] (unsupported syntax)");
  it("presto -> duckdb: SELECT APPROX_DISTINCT(a) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a) FROM foo", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a) FROM foo");
  });
  it("presto -> presto: SELECT APPROX_DISTINCT(a) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a) FROM foo", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT APPROX_DISTINCT(a) FROM foo");
  });
  it("presto -> hive: SELECT APPROX_DISTINCT(a) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a) FROM foo", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a) FROM foo");
  });
  it("presto -> spark: SELECT APPROX_DISTINCT(a) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a) FROM foo", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a) FROM foo");
  });
  it("presto -> duckdb: SELECT APPROX_DISTINCT(a, 0.1) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a, 0.1) FROM foo", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a) FROM foo");
  });
  it("presto -> presto: SELECT APPROX_DISTINCT(a, 0.1) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a, 0.1) FROM foo", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT APPROX_DISTINCT(a, 0.1) FROM foo");
  });
  it("presto -> hive: SELECT APPROX_DISTINCT(a, 0.1) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a, 0.1) FROM foo", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a) FROM foo");
  });
  it("presto -> spark: SELECT APPROX_DISTINCT(a, 0.1) FROM foo", () => {
    const result = transpile("SELECT APPROX_DISTINCT(a, 0.1) FROM foo", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(a, 0.1) FROM foo");
  });
  it.todo("SELECT APPROX_DISTINCT(a, 0.1) FROM foo (UnsupportedError in write)");
  it("presto -> presto: SELECT JSON_EXTRACT(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT(x, '$.name')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT(x, '$.name')");
  });
  it("presto -> hive: SELECT JSON_EXTRACT(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT(x, '$.name')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(x, '$.name')");
  });
  it("presto -> spark: SELECT JSON_EXTRACT(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT(x, '$.name')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(x, '$.name')");
  });
  it("presto -> presto: SELECT JSON_EXTRACT_SCALAR(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT_SCALAR(x, '$.name')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(x, '$.name')");
  });
  it("presto -> hive: SELECT JSON_EXTRACT_SCALAR(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT_SCALAR(x, '$.name')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(x, '$.name')");
  });
  it("presto -> spark: SELECT JSON_EXTRACT_SCALAR(x, '$.name')", () => {
    const result = transpile("SELECT JSON_EXTRACT_SCALAR(x, '$.name')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(x, '$.name')");
  });
  it("presto -> presto: ''", () => {
    const result = transpile("''", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("''");
  });
  it("presto -> hive: ''", () => {
    const result = transpile("''", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("''");
  });
  it("presto -> spark: ''", () => {
    const result = transpile("''", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("''");
  });
  it("presto -> duckdb: SELECT ARRAY_SORT(x, (left, right) -> -1)", () => {
    const result = transpile("SELECT ARRAY_SORT(x, (left, right) -> -1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT ARRAY_SORT(x)");
  });
  it("presto -> presto: SELECT ARRAY_SORT(x, (left, right) -> -1)", () => {
    const result = transpile("SELECT ARRAY_SORT(x, (left, right) -> -1)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe('SELECT ARRAY_SORT(x, ("left", "right") -> -1)');
  });
  it.todo("presto -> hive: SELECT ARRAY_SORT(x, (left, right) -> -1) (unsupported syntax)");
  it("presto -> spark: SELECT ARRAY_SORT(x, (left, right) -> -1)", () => {
    const result = transpile("SELECT ARRAY_SORT(x, (left, right) -> -1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT ARRAY_SORT(x, (left, right) -> -1)");
  });
  it("presto -> presto: SELECT ARRAY_SORT(x)", () => {
    const result = transpile("SELECT ARRAY_SORT(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SELECT ARRAY_SORT(x)");
  });
  it.todo("presto -> hive: SELECT ARRAY_SORT(x) (unsupported syntax)");
  it("presto -> spark: SELECT ARRAY_SORT(x)", () => {
    const result = transpile("SELECT ARRAY_SORT(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT ARRAY_SORT(x)");
  });
  it.todo("SELECT ARRAY_SORT(x, (left, right) -> -1) (UnsupportedError in write)");
  it.todo("MAP(a, b) (UnsupportedError in write)");
  it.todo("MAP(ARRAY(a, b), ARRAY(c, d)) (unsupported syntax)");
  it.todo("MAP(ARRAY('a'), ARRAY('b')) (unsupported syntax)");
  it.todo("SELECT * FROM UNNEST(ARRAY['7', '14']) AS x (unsupported syntax)");
  it.todo("SELECT * FROM UNNEST(ARRAY['7', '14']) AS x(y) (unsupported syntax)");
  it.todo("WITH RECURSIVE t(n) AS (VALUES (1) UNION ALL SELECT n+1 FROM t WHER... (UnsupportedError in write)");
  it.todo("SELECT a, b, c, d, sum(y) FROM z GROUP BY CUBE(a) ROLLUP(a), GROUPI... (unsupported clause)");
  it.todo("JSON_FORMAT(CAST(MAP_FROM_ENTRIES(ARRAY[('action_type', 'at')]) AS ... (unsupported syntax)");
  it("presto -> bigquery: JSON_FORMAT(x)", () => {
    const result = transpile("JSON_FORMAT(x)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("TO_JSON_STRING(x)");
  });
  it("presto -> duckdb: JSON_FORMAT(x)", () => {
    const result = transpile("JSON_FORMAT(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST(TO_JSON(x) AS TEXT)");
  });
  it("presto -> presto: JSON_FORMAT(x)", () => {
    const result = transpile("JSON_FORMAT(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("JSON_FORMAT(x)");
  });
  it("presto -> spark: JSON_FORMAT(x)", () => {
    const result = transpile("JSON_FORMAT(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("TO_JSON(x)");
  });
  it(`presto -> bigquery: JSON_FORMAT(JSON '"x"')`, () => {
    const result = transpile(`JSON_FORMAT(JSON '"x"')`, { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe(`TO_JSON_STRING(PARSE_JSON('"x"'))`);
  });
  it(`presto -> duckdb: JSON_FORMAT(JSON '"x"')`, () => {
    const result = transpile(`JSON_FORMAT(JSON '"x"')`, { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`CAST(TO_JSON(JSON('"x"')) AS TEXT)`);
  });
  it(`presto -> presto: JSON_FORMAT(JSON '"x"')`, () => {
    const result = transpile(`JSON_FORMAT(JSON '"x"')`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`JSON_FORMAT(JSON_PARSE('"x"'))`);
  });
  it(`presto -> spark: JSON_FORMAT(JSON '"x"')`, () => {
    const result = transpile(`JSON_FORMAT(JSON '"x"')`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe(`REGEXP_EXTRACT(TO_JSON(FROM_JSON('["x"]', SCHEMA_OF_JSON('["x"]'))), '^.(.*).$', 1)`);
  });
  it(`presto -> spark: SELECT JSON_FORMAT(JSON '{"a": 1, "b": "c"}')`, () => {
    const result = transpile(`SELECT JSON_FORMAT(JSON '{"a": 1, "b": "c"}')`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe(`SELECT REGEXP_EXTRACT(TO_JSON(FROM_JSON('[{"a": 1, "b": "c"}]', SCHEMA_OF_JSON('[{"a": 1, "b": "c"}]'))), '^.(.*).$', 1)`);
  });
  it("presto -> spark: SELECT JSON_FORMAT(JSON '[1, 2, 3]')", () => {
    const result = transpile("SELECT JSON_FORMAT(JSON '[1, 2, 3]')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT REGEXP_EXTRACT(TO_JSON(FROM_JSON('[[1, 2, 3]]', SCHEMA_OF_JSON('[[1, 2, 3]]'))), '^.(.*).$', 1)");
  });
  it("presto -> presto: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("trino -> presto: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("duckdb -> presto: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("snowflake -> presto: REGEXP_SUBSTR('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_SUBSTR('abc', '(a)(b)(c)')", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("presto -> presto: REGEXP_EXTRACT('abc', '(a)(b)(c)') (2)", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("presto -> trino: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("presto -> duckdb: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("presto -> snowflake: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("REGEXP_SUBSTR('abc', '(a)(b)(c)')");
  });
  it("presto -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 0)");
  });
  it("presto -> spark2: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 0)");
  });
  it("presto -> spark: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 0)");
  });
  it("presto -> databricks: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 0)");
  });
  it("presto -> presto: CURRENT_USER", () => {
    const result = transpile("CURRENT_USER", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_USER");
  });
  it("trino -> presto: CURRENT_USER", () => {
    const result = transpile("CURRENT_USER", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_USER");
  });
  it("snowflake -> presto: CURRENT_USER()", () => {
    const result = transpile("CURRENT_USER()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_USER");
  });
  it("presto -> trino: CURRENT_USER", () => {
    const result = transpile("CURRENT_USER", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("CURRENT_USER");
  });
  it("presto -> snowflake: CURRENT_USER", () => {
    const result = transpile("CURRENT_USER", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("CURRENT_USER()");
  });
  it("SELECT id, FIRST_VALUE(is_deleted) OVER (PARTITION BY id) AS first_is_deleted, NTH_VALU...", () => {
    validateIdentity("SELECT id, FIRST_VALUE(is_deleted) OVER (PARTITION BY id) AS first_is_deleted, NTH_VALUE(is_deleted, 2) OVER (PARTITION BY id) AS nth_is_deleted, LAST_VALUE(is_deleted) OVER (PARTITION BY id) AS last_is_deleted FROM my_table");
  });
  it("presto -> presto: SELECT NULLABLE FROM system.jdbc.types", () => {
    const result = transpile("SELECT NULLABLE FROM system.jdbc.types", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT NULLABLE FROM system.jdbc.types");
  });
  it("trino -> presto: SELECT NULLABLE FROM system.jdbc.types", () => {
    const result = transpile("SELECT NULLABLE FROM system.jdbc.types", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT NULLABLE FROM system.jdbc.types");
  });
});

describe("Presto: encode_decode", () => {
  it("FROM_UTF8(x, y)", () => {
    validateIdentity("FROM_UTF8(x, y)");
  });
  it("duckdb -> presto: ENCODE(x)", () => {
    const result = transpile("ENCODE(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_UTF8(x)");
  });
  it("spark -> presto: ENCODE(x, 'utf-8')", () => {
    const result = transpile("ENCODE(x, 'utf-8')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("TO_UTF8(x)");
  });
  it("presto -> duckdb: TO_UTF8(x)", () => {
    const result = transpile("TO_UTF8(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ENCODE(x)");
  });
  it("presto -> presto: TO_UTF8(x)", () => {
    const result = transpile("TO_UTF8(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_UTF8(x)");
  });
  it("presto -> spark: TO_UTF8(x)", () => {
    const result = transpile("TO_UTF8(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ENCODE(x, 'utf-8')");
  });
  it("duckdb -> presto: DECODE(x)", () => {
    const result = transpile("DECODE(x)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("FROM_UTF8(x)");
  });
  it("spark -> presto: DECODE(x, 'utf-8')", () => {
    const result = transpile("DECODE(x, 'utf-8')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("FROM_UTF8(x)");
  });
  it("presto -> duckdb: FROM_UTF8(x)", () => {
    const result = transpile("FROM_UTF8(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("DECODE(x)");
  });
  it("presto -> presto: FROM_UTF8(x)", () => {
    const result = transpile("FROM_UTF8(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("FROM_UTF8(x)");
  });
  it("presto -> spark: FROM_UTF8(x)", () => {
    const result = transpile("FROM_UTF8(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DECODE(x, 'utf-8')");
  });
  it.todo("ENCODE(x, 'invalid') (UnsupportedError in write)");
  it.todo("DECODE(x, 'invalid') (UnsupportedError in write)");
});

describe("Presto: hex_unhex", () => {
  it("presto -> spark: TO_HEX(x)", () => {
    const result = transpile("TO_HEX(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("HEX(x)");
  });
  it("presto -> spark: FROM_HEX(x)", () => {
    const result = transpile("FROM_HEX(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UNHEX(x)");
  });
  it("presto -> presto: HEX(x)", () => {
    const result = transpile("HEX(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TO_HEX(x)");
  });
  it("presto -> presto: UNHEX(x)", () => {
    const result = transpile("UNHEX(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("FROM_HEX(x)");
  });
});

describe("Presto: json", () => {
  it.todo(`SELECT JSON_EXTRACT_SCALAR(TRY(FILTER(CAST(JSON_EXTRACT('{"k1": [{"... (unsupported syntax)`);
  it.todo("SELECT CAST(JSON '[1,23,456]' AS ARRAY(INTEGER)) (unsupported syntax)");
  it(`presto -> spark: SELECT CAST(JSON '{"k1":1,"k2":23,"k3":456}' AS MAP(VARCHAR, INTEGER))`, () => {
    const result = transpile(`SELECT CAST(JSON '{"k1":1,"k2":23,"k3":456}' AS MAP(VARCHAR, INTEGER))`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe(`SELECT FROM_JSON('{"k1":1,"k2":23,"k3":456}', 'MAP<STRING, INT>')`);
  });
  it(`presto -> presto: SELECT CAST(JSON '{"k1":1,"k2":23,"k3":456}' AS MAP(VARCHAR, INTEGER))`, () => {
    const result = transpile(`SELECT CAST(JSON '{"k1":1,"k2":23,"k3":456}' AS MAP(VARCHAR, INTEGER))`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`SELECT CAST(JSON_PARSE('{"k1":1,"k2":23,"k3":456}') AS MAP(VARCHAR, INTEGER))`);
  });
  it.todo("SELECT CAST(ARRAY [1, 23, 456] AS JSON) (unsupported syntax)");
});

describe("Presto: match_recognize", () => {
  it.todo("SELECT\n  *\nFROM orders\nMATCH_RECOGNIZE (\n  PARTITION BY custkey\n  O... (pretty=True not supported)");
});

describe("Presto: to_char", () => {
  it("presto -> bigquery: TO_CHAR(ts, 'dd')", () => {
    const result = transpile("TO_CHAR(ts, 'dd')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%d', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'dd') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'hh')", () => {
    const result = transpile("TO_CHAR(ts, 'hh')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%H', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'hh') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'hh24')", () => {
    const result = transpile("TO_CHAR(ts, 'hh24')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%H', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'hh24') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'mi')", () => {
    const result = transpile("TO_CHAR(ts, 'mi')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%M', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'mi') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'mm')", () => {
    const result = transpile("TO_CHAR(ts, 'mm')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%m', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'mm') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'ss')", () => {
    const result = transpile("TO_CHAR(ts, 'ss')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%S', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'ss') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'yyyy')", () => {
    const result = transpile("TO_CHAR(ts, 'yyyy')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%Y', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'yyyy') (unsupported syntax)");
  it("presto -> bigquery: TO_CHAR(ts, 'yy')", () => {
    const result = transpile("TO_CHAR(ts, 'yy')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("FORMAT_DATE('%y', ts)");
  });
  it.todo("presto -> presto: TO_CHAR(ts, 'yy') (unsupported syntax)");
});

describe("Presto: signum", () => {
  it("presto -> presto: SIGN(x)", () => {
    const result = transpile("SIGN(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SIGN(x)");
  });
  it("spark -> presto: SIGNUM(x)", () => {
    const result = transpile("SIGNUM(x)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SIGN(x)");
  });
  it("starrocks -> presto: SIGN(x)", () => {
    const result = transpile("SIGN(x)", { readDialect: "starrocks", writeDialect: DIALECT })[0];
    expect(result).toBe("SIGN(x)");
  });
  it("presto -> presto: SIGN(x) (2)", () => {
    const result = transpile("SIGN(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SIGN(x)");
  });
  it("presto -> spark: SIGN(x)", () => {
    const result = transpile("SIGN(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SIGN(x)");
  });
  it("presto -> starrocks: SIGN(x)", () => {
    const result = transpile("SIGN(x)", { readDialect: DIALECT, writeDialect: "starrocks" })[0];
    expect(result).toBe("SIGN(x)");
  });
});

describe("Presto: json_vs_row_extract", () => {
  it.todo("test_json_vs_row_extract: assertEqual call");
  it.todo("test_json_vs_row_extract: assertEqual call (2)");
  it.todo("test_json_vs_row_extract: assertEqual call (3)");
  it.todo("test_json_vs_row_extract: assertEqual call (4)");
  it.todo("test_json_vs_row_extract: assertEqual call (5)");
  it.todo("test_json_vs_row_extract: assertEqual call (6)");
});

describe("Presto: analyze", () => {
  it.todo("ANALYZE tbl (command not supported)");
  it.todo("ANALYZE tbl WITH (prop1=val1, prop2=val2) (command not supported)");
});

describe("Presto: bit_aggs", () => {
  it("presto -> presto: BITWISE_AND_AGG(x)", () => {
    const result = transpile("BITWISE_AND_AGG(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_AND_AGG(x)");
  });
  it("trino -> presto: BITWISE_AND_AGG(x)", () => {
    const result = transpile("BITWISE_AND_AGG(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_AND_AGG(x)");
  });
  it("oracle -> presto: BITWISE_AND_AGG(x)", () => {
    const result = transpile("BITWISE_AND_AGG(x)", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_AND_AGG(x)");
  });
  it("presto -> presto: BITWISE_OR_AGG(x)", () => {
    const result = transpile("BITWISE_OR_AGG(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_OR_AGG(x)");
  });
  it("trino -> presto: BITWISE_OR_AGG(x)", () => {
    const result = transpile("BITWISE_OR_AGG(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_OR_AGG(x)");
  });
  it("oracle -> presto: BITWISE_OR_AGG(x)", () => {
    const result = transpile("BITWISE_OR_AGG(x)", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_OR_AGG(x)");
  });
  it("presto -> presto: BITWISE_XOR_AGG(x)", () => {
    const result = transpile("BITWISE_XOR_AGG(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_XOR_AGG(x)");
  });
  it("trino -> presto: BITWISE_XOR_AGG(x)", () => {
    const result = transpile("BITWISE_XOR_AGG(x)", { readDialect: "trino", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_XOR_AGG(x)");
  });
  it("oracle -> presto: BITWISE_XOR_AGG(x)", () => {
    const result = transpile("BITWISE_XOR_AGG(x)", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("BITWISE_XOR_AGG(x)");
  });
});

describe("Presto: initcap", () => {
  it.todo("presto -> presto: INITCAP(col) (unsupported syntax)");
});
