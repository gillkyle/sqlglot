// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "dremio";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Dremio: type_mappings", () => {
  it("CAST(x AS SMALLINT) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS SMALLINT)", "CAST(x AS INT)");
  });
  it("CAST(x AS TINYINT) -> CAST(x AS INT)", () => {
    validateIdentity("CAST(x AS TINYINT)", "CAST(x AS INT)");
  });
  it("CAST(x AS BINARY) -> CAST(x AS VARBINARY)", () => {
    validateIdentity("CAST(x AS BINARY)", "CAST(x AS VARBINARY)");
  });
  it("CAST(x AS TEXT) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS TEXT)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS NCHAR) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS NCHAR)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS CHAR) -> CAST(x AS VARCHAR)", () => {
    validateIdentity("CAST(x AS CHAR)", "CAST(x AS VARCHAR)");
  });
  it("CAST(x AS TIMESTAMPNTZ) -> CAST(x AS TIMESTAMP)", () => {
    validateIdentity("CAST(x AS TIMESTAMPNTZ)", "CAST(x AS TIMESTAMP)");
  });
  it("CAST(x AS DATETIME) -> CAST(x AS TIMESTAMP)", () => {
    validateIdentity("CAST(x AS DATETIME)", "CAST(x AS TIMESTAMP)");
  });
  it("CAST(x AS ARRAY) -> CAST(x AS LIST)", () => {
    validateIdentity("CAST(x AS ARRAY)", "CAST(x AS LIST)");
  });
  it("CAST(x AS BIT) -> CAST(x AS BOOLEAN)", () => {
    validateIdentity("CAST(x AS BIT)", "CAST(x AS BOOLEAN)");
  });
});

describe("Dremio: concat_coalesce", () => {
  it("dremio -> dremio: SELECT CONCAT('a', NULL)", () => {
    const result = transpile("SELECT CONCAT('a', NULL)", { readDialect: DIALECT, writeDialect: "dremio" })[0];
    expect(result).toBe("SELECT CONCAT('a', NULL)");
  });
  it.todo("dremio -> : SELECT CONCAT('a', NULL) (cross-dialect transform)");
});

describe("Dremio: typed_division", () => {
  it.todo("test_typed_division: assert statement");
  it.todo("test_typed_division: assert statement (2)");
});

describe("Dremio: user_defined_types_unsupported", () => {
  it.todo("test_user_defined_types_unsupported: parse_one call");
});

describe("Dremio: null_ordering", () => {
  it.todo("SELECT * FROM t ORDER BY a NULLS LAST (unsupported syntax)");
  it.todo("SELECT * FROM t ORDER BY a DESC NULLS LAST (unsupported syntax)");
  it.todo("SELECT * FROM t ORDER BY a NULLS FIRST (unsupported syntax)");
  it.todo("SELECT * FROM t ORDER BY a DESC NULLS FIRST (unsupported syntax)");
});

describe("Dremio: convert_timezone", () => {
  it("dremio -> dremio: SELECT CONVERT_TIMEZONE('America/Chicago', DateColumn)", () => {
    const result = transpile("SELECT CONVERT_TIMEZONE('America/Chicago', DateColumn)", { readDialect: DIALECT, writeDialect: "dremio" })[0];
    expect(result).toBe("SELECT CONVERT_TIMEZONE('America/Chicago', DateColumn)");
  });
  it.todo("dremio -> : SELECT CONVERT_TIMEZONE('America/Chicago', DateColumn) (unsupported syntax)");
});

describe("Dremio: interval_plural", () => {
  it.todo("INTERVAL '7' DAYS (unsupported syntax)");
});

describe("Dremio: limit_only_literals", () => {
  it.todo("SELECT * FROM t LIMIT 1 + 1 (unsupported syntax)");
});

describe("Dremio: multi_arg_distinct_unsupported", () => {
  it("SELECT COUNT(DISTINCT a, b) FROM t -> SELECT COUNT(DISTINCT CASE WHEN a IS NULL THEN NU...", () => {
    validateIdentity("SELECT COUNT(DISTINCT a, b) FROM t", "SELECT COUNT(DISTINCT CASE WHEN a IS NULL THEN NULL WHEN b IS NULL THEN NULL ELSE (a, b) END) FROM t");
  });
});

describe("Dremio: time_mapping", () => {
  it.todo("test_time_mapping: unresolvable SQL string");
  it.todo("test_time_mapping: unresolvable SQL string (2)");
});

describe("Dremio: to_char_special", () => {
  it.todo("test_to_char_special: assert statement");
  it.todo("test_to_char_special: assert statement (2)");
  it.todo("test_to_char_special: assert statement (3)");
  it.todo("test_to_char_special: assert statement (4)");
  it.todo("test_to_char_special: assert statement (5)");
  it.todo("test_to_char_special: assert statement (6)");
  it.todo("test_to_char_special: assert statement (7)");
});

describe("Dremio: date_add", () => {
  it("SELECT DATE_ADD(col, 1)", () => {
    validateIdentity("SELECT DATE_ADD(col, 1)");
  });
  it("SELECT DATE_ADD(col, CAST(1 AS INTERVAL HOUR))", () => {
    validateIdentity("SELECT DATE_ADD(col, CAST(1 AS INTERVAL HOUR))");
  });
  it.todo("SELECT DATE_ADD(TIMESTAMP '2022-01-01 12:00:00', CAST(-1 AS INTERVA... (unsupported syntax)");
});

describe("Dremio: date_sub", () => {
  it("SELECT DATE_SUB(col, 1)", () => {
    validateIdentity("SELECT DATE_SUB(col, 1)");
  });
  it("SELECT DATE_SUB(col, CAST(1 AS INTERVAL HOUR))", () => {
    validateIdentity("SELECT DATE_SUB(col, CAST(1 AS INTERVAL HOUR))");
  });
  it.todo("SELECT DATE_SUB(TIMESTAMP '2022-01-01 12:00:00', CAST(-1 AS INTERVA... (unsupported syntax)");
});

describe("Dremio: datetime_parsing", () => {
  it.todo("SELECT DATE_FORMAT(CAST('2025-08-18 15:30:00' AS TIMESTAMP), 'yyyy-... (unsupported syntax)");
});

describe("Dremio: array_generate_range", () => {
  it("dremio -> dremio: ARRAY_GENERATE_RANGE(1, 4)", () => {
    const result = transpile("ARRAY_GENERATE_RANGE(1, 4)", { readDialect: "dremio", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_GENERATE_RANGE(1, 4)");
  });
  it.todo("dremio -> duckdb: ARRAY_GENERATE_RANGE(1, 4) (unsupported syntax)");
});

describe("Dremio: current_date_utc", () => {
  it("SELECT CURRENT_DATE_UTC", () => {
    validateIdentity("SELECT CURRENT_DATE_UTC");
  });
  it("SELECT CURRENT_DATE_UTC() -> SELECT CURRENT_DATE_UTC", () => {
    validateIdentity("SELECT CURRENT_DATE_UTC()", "SELECT CURRENT_DATE_UTC");
  });
});

describe("Dremio: repeatstr", () => {
  it("SELECT REPEAT(x, 5)", () => {
    validateIdentity("SELECT REPEAT(x, 5)");
  });
  it("SELECT REPEATSTR(x, 5) -> SELECT REPEAT(x, 5)", () => {
    validateIdentity("SELECT REPEATSTR(x, 5)", "SELECT REPEAT(x, 5)");
  });
});

describe("Dremio: regexp_like", () => {
  it("dremio -> dremio: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "dremio" })[0];
    expect(result).toBe("REGEXP_LIKE(x, y)");
  });
  it("dremio -> duckdb: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_MATCHES(x, y)");
  });
  it("dremio -> presto: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_LIKE(x, y)");
  });
  it("dremio -> hive: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x RLIKE y");
  });
  it("dremio -> spark: REGEXP_MATCHES(x, y)", () => {
    const result = transpile("REGEXP_MATCHES(x, y)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x RLIKE y");
  });
  it("REGEXP_MATCHES(x, y) -> REGEXP_LIKE(x, y)", () => {
    validateIdentity("REGEXP_MATCHES(x, y)", "REGEXP_LIKE(x, y)");
  });
});

describe("Dremio: date_part", () => {
  it.todo("SELECT DATE_PART('YEAR', date '2021-04-01') (unsupported syntax)");
});

describe("Dremio: datetype", () => {
  it("DATETYPE(2024,2,2) -> DATE('2024-02-02')", () => {
    validateIdentity("DATETYPE(2024,2,2)", "DATE('2024-02-02')");
  });
  it("DATETYPE(x,y,z) -> CAST(CONCAT(x, '-', y, '-', z) AS DATE)", () => {
    validateIdentity("DATETYPE(x,y,z)", "CAST(CONCAT(x, '-', y, '-', z) AS DATE)");
  });
});

describe("Dremio: try_cast", () => {
  it("dremio -> dremio: CAST(a AS FLOAT)", () => {
    const result = transpile("CAST(a AS FLOAT)", { readDialect: "dremio", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(a AS FLOAT)");
  });
  it(" -> dremio: TRY_CAST(a AS FLOAT)", () => {
    const result = transpile("TRY_CAST(a AS FLOAT)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(a AS FLOAT)");
  });
  it("hive -> dremio: CAST(a AS FLOAT)", () => {
    const result = transpile("CAST(a AS FLOAT)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(a AS FLOAT)");
  });
});
