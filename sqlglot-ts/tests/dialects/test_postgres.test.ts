// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "postgres";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Postgres: postgres", () => {
  it.todo("test_postgres: assertIsInstance call");
  it.todo("test_postgres: assertEqual call");
  it.todo("test_postgres: unresolvable SQL string");
  it("SELECT GET_BIT(CAST(44 AS BIT(10)), 6)", () => {
    validateIdentity("SELECT GET_BIT(CAST(44 AS BIT(10)), 6)");
  });
  it.todo("SELECT * FROM t GROUP BY ROLLUP (a || '^' || b) (unsupported clause)");
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it.todo("SELECT MODE() WITHIN GROUP (ORDER BY status DESC) AS most_common FR... (unsupported clause)");
  it("SELECT ST_DISTANCE(gg1, gg2, FALSE) AS sphere_dist", () => {
    validateIdentity("SELECT ST_DISTANCE(gg1, gg2, FALSE) AS sphere_dist");
  });
  it("SHA384(x)", () => {
    validateIdentity("SHA384(x)");
  });
  it("1.x -> 1. AS x", () => {
    validateIdentity("1.x", "1. AS x");
  });
  it.todo("|/ x (unsupported syntax)");
  it.todo("||/ x (unsupported syntax)");
  it.todo("SELECT EXTRACT(QUARTER FROM CAST('2025-04-26' AS DATE)) (unsupported syntax)");
  it("SELECT DATE_TRUNC('QUARTER', CAST('2025-04-26' AS DATE))", () => {
    validateIdentity("SELECT DATE_TRUNC('QUARTER', CAST('2025-04-26' AS DATE))");
  });
  it.todo("STRING_TO_ARRAY('xx~^~yy~^~zz', '~^~', 'yy') (unsupported syntax)");
  it("SELECT x FROM t WHERE CAST($1 AS TEXT) = 'ok'", () => {
    validateIdentity("SELECT x FROM t WHERE CAST($1 AS TEXT) = 'ok'");
  });
  it.todo("SELECT * FROM t TABLESAMPLE SYSTEM (50) REPEATABLE (55) (unsupported clause)");
  it.todo("x @@ y (unsupported syntax)");
  it("CAST(x AS MONEY)", () => {
    validateIdentity("CAST(x AS MONEY)");
  });
  it("CAST(x AS INT4RANGE)", () => {
    validateIdentity("CAST(x AS INT4RANGE)");
  });
  it("CAST(x AS INT4MULTIRANGE)", () => {
    validateIdentity("CAST(x AS INT4MULTIRANGE)");
  });
  it("CAST(x AS INT8RANGE)", () => {
    validateIdentity("CAST(x AS INT8RANGE)");
  });
  it("CAST(x AS INT8MULTIRANGE)", () => {
    validateIdentity("CAST(x AS INT8MULTIRANGE)");
  });
  it("CAST(x AS NUMRANGE)", () => {
    validateIdentity("CAST(x AS NUMRANGE)");
  });
  it("CAST(x AS NUMMULTIRANGE)", () => {
    validateIdentity("CAST(x AS NUMMULTIRANGE)");
  });
  it("CAST(x AS TSRANGE)", () => {
    validateIdentity("CAST(x AS TSRANGE)");
  });
  it("CAST(x AS TSMULTIRANGE)", () => {
    validateIdentity("CAST(x AS TSMULTIRANGE)");
  });
  it("CAST(x AS TSTZRANGE)", () => {
    validateIdentity("CAST(x AS TSTZRANGE)");
  });
  it("CAST(x AS TSTZMULTIRANGE)", () => {
    validateIdentity("CAST(x AS TSTZMULTIRANGE)");
  });
  it("CAST(x AS DATERANGE)", () => {
    validateIdentity("CAST(x AS DATERANGE)");
  });
  it("CAST(x AS DATEMULTIRANGE)", () => {
    validateIdentity("CAST(x AS DATEMULTIRANGE)");
  });
  it("x$", () => {
    validateIdentity("x$");
  });
  it("LENGTH(x)", () => {
    validateIdentity("LENGTH(x)");
  });
  it("LENGTH(x, utf8)", () => {
    validateIdentity("LENGTH(x, utf8)");
  });
  it("CHAR_LENGTH(x) -> LENGTH(x)", () => {
    validateIdentity("CHAR_LENGTH(x)", "LENGTH(x)");
  });
  it("CHARACTER_LENGTH(x) -> LENGTH(x)", () => {
    validateIdentity("CHARACTER_LENGTH(x)", "LENGTH(x)");
  });
  it.todo("SELECT ARRAY[1, 2, 3] (unsupported syntax)");
  it.todo("SELECT ARRAY(SELECT 1) (unsupported syntax)");
  it.todo("STRING_AGG(x, y) (unsupported syntax)");
  it.todo("STRING_AGG(x, ',' ORDER BY y) (unsupported syntax)");
  it.todo("STRING_AGG(x, ',' ORDER BY y DESC) (unsupported syntax)");
  it.todo("STRING_AGG(DISTINCT x, ',' ORDER BY y DESC) (unsupported syntax)");
  it("SELECT CASE WHEN SUBSTRING('abcdefg') IN ('ab') THEN 1 ELSE 0 END", () => {
    validateIdentity("SELECT CASE WHEN SUBSTRING('abcdefg') IN ('ab') THEN 1 ELSE 0 END");
  });
  it.todo("COMMENT ON TABLE mytable IS 'this' (command not supported)");
  it.todo("COMMENT ON MATERIALIZED VIEW my_view IS 'this' (command not supported)");
  it.todo("SELECT e'\\xDEADBEEF' (unsupported syntax)");
  it.todo("SELECT CAST(e'\\176' AS BYTEA) (unsupported syntax)");
  it.todo("SELECT * FROM x WHERE SUBSTRING('Thomas' FROM '...$') IN ('mas') (unsupported syntax)");
  it.todo("SELECT TRIM(' X' FROM ' XXX ') (unsupported syntax)");
  it.todo("SELECT TRIM(LEADING 'bla' FROM ' XXX ' COLLATE utf8_bin) (unsupported syntax)");
  it.todo('SELECT * FROM JSON_TO_RECORDSET(z) AS y("rank" INT) (unsupported clause)');
  it.todo("SELECT ~x (unsupported syntax)");
  it.todo("x ~ 'y' (unsupported syntax)");
  it.todo("x ~* 'y' (unsupported syntax)");
  it.todo("SELECT * FROM r CROSS JOIN LATERAL UNNEST(ARRAY[1]) AS s(location) (unsupported syntax)");
  it("CAST(1 AS DECIMAL) / CAST(2 AS DECIMAL) * -100", () => {
    validateIdentity("CAST(1 AS DECIMAL) / CAST(2 AS DECIMAL) * -100");
  });
  it.todo("EXEC AS myfunc @id = 123 (check_command_warning)");
  it.todo("SELECT CURRENT_SCHEMA (unsupported syntax)");
  it("SELECT CURRENT_USER", () => {
    validateIdentity("SELECT CURRENT_USER");
  });
  it("SELECT CURRENT_ROLE", () => {
    validateIdentity("SELECT CURRENT_ROLE");
  });
  it("SELECT VERSION()", () => {
    validateIdentity("SELECT VERSION()");
  });
  it.todo("SELECT * FROM ONLY t1 (unsupported syntax)");
  it("SELECT INTERVAL '-1 MONTH'", () => {
    validateIdentity("SELECT INTERVAL '-1 MONTH'");
  });
  it("SELECT INTERVAL '4.1 DAY'", () => {
    validateIdentity("SELECT INTERVAL '4.1 DAY'");
  });
  it("SELECT INTERVAL '3.14159 HOUR'", () => {
    validateIdentity("SELECT INTERVAL '3.14159 HOUR'");
  });
  it("SELECT INTERVAL '2.5 MONTH'", () => {
    validateIdentity("SELECT INTERVAL '2.5 MONTH'");
  });
  it("SELECT INTERVAL '-10.75 MINUTE'", () => {
    validateIdentity("SELECT INTERVAL '-10.75 MINUTE'");
  });
  it("SELECT INTERVAL '0.123456789 SECOND'", () => {
    validateIdentity("SELECT INTERVAL '0.123456789 SECOND'");
  });
  it.todo("SELECT SUM(x) OVER (PARTITION BY y ORDER BY interval ROWS BETWEEN U... (unsupported clause)");
  it.todo("SELECT * FROM test_data, LATERAL JSONB_ARRAY_ELEMENTS(data) WITH OR... (unsupported clause)");
  it.todo("SELECT id, name FROM xml_data AS t, XMLTABLE('/root/user' PASSING t... (unsupported clause)");
  it.todo("SELECT id, value FROM xml_content AS t, XMLTABLE(XMLNAMESPACES('htt... (unsupported clause)");
  it.todo("SELECT * FROM t WHERE some_column >= CURRENT_DATE + INTERVAL '1 day... (unsupported syntax)");
  it.todo(`UPDATE "x" SET "y" = CAST('0 days 60.000000 seconds' AS INTERVAL) W... (DDL/DML not supported)`);
  it.todo("WITH t1 AS MATERIALIZED (SELECT 1), t2 AS NOT MATERIALIZED (SELECT ... (unsupported syntax)");
  it.todo(`LAST_VALUE("col1") OVER (ORDER BY "col2" RANGE BETWEEN INTERVAL '1 ... (unsupported clause)`);
  it.todo('ALTER TABLE ONLY "Album" ADD CONSTRAINT "FK_AlbumArtistId" FOREIGN ... (DDL/DML not supported)');
  it.todo('ALTER TABLE ONLY "Album" ADD CONSTRAINT "FK_AlbumArtistId" FOREIGN ... (DDL/DML not supported) (2)');
  it.todo("SELECT * FROM JSON_ARRAY_ELEMENTS('[1,true, [2,false]]') WITH ORDIN... (unsupported clause)");
  it.todo("SELECT * FROM JSON_ARRAY_ELEMENTS('[1,true, [2,false]]') WITH ORDIN... (unsupported clause) (2)");
  it.todo("SELECT * FROM JSON_ARRAY_ELEMENTS('[1,true, [2,false]]') WITH ORDIN... (unsupported clause) (3)");
  it.todo("SELECT SUM(x) OVER a, SUM(y) OVER b FROM c WINDOW a AS (PARTITION B... (unsupported syntax)");
  it.todo("SELECT CASE WHEN SUBSTRING('abcdefg' FROM 1) IN ('ab') THEN 1 ELSE ... (unsupported syntax)");
  it.todo("SELECT CASE WHEN SUBSTRING('abcdefg' FROM 1 FOR 2) IN ('ab') THEN 1... (unsupported syntax)");
  it.todo(`SELECT * FROM "x" WHERE SUBSTRING("x"."foo" FROM 1 FOR 2) IN ('mas') (unsupported syntax)`);
  it.todo(`SELECT * FROM x WHERE SUBSTRING('Thomas' FROM '%#"o_a#"_' FOR '#') ... (unsupported syntax)`);
  it.todo("SELECT SUBSTRING('bla' + 'foo' || 'bar' FROM 3 - 1 + 5 FOR 4 + SOME... (unsupported syntax)");
  it("SELECT TO_TIMESTAMP(1284352323.5), TO_TIMESTAMP('05 Dec 2000', 'DD Mon YYYY')", () => {
    validateIdentity("SELECT TO_TIMESTAMP(1284352323.5), TO_TIMESTAMP('05 Dec 2000', 'DD Mon YYYY')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 AM', 'DD Mon YYYY HH:MI AM')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 AM', 'DD Mon YYYY HH:MI AM')");
  });
  it("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 PM', 'DD Mon YYYY HH:MI PM')", () => {
    validateIdentity("SELECT TO_TIMESTAMP('05 Dec 2000 10:00 PM', 'DD Mon YYYY HH:MI PM')");
  });
  it.todo("SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.ba... (unsupported clause)");
  it.todo("SELECT c.oid, n.nspname, c.relname FROM pg_catalog.pg_class AS c LE... (unsupported syntax)");
  it.todo("SELECT e'foo \\' bar' (unsupported syntax)");
  it.todo("SELECT e'\\n' (unsupported syntax)");
  it.todo("SELECT e'\\t' (unsupported syntax)");
  it.todo("SELECT e'update table_name set a = \\'foo\\' where 1 = 0' AS x FROM tab (unsupported syntax)");
  it.todo("select count() OVER(partition by a order by a range offset precedin... (unsupported syntax)");
  it.todo("SELECT SUBSTRING('Thomas' FOR 3 FROM 2) (unsupported syntax)");
  it.todo("SELECT ARRAY[1, 2, 3] <@ ARRAY[1, 2] (unsupported syntax)");
  it.todo("SELECT DATE_PART('isodow'::varchar(6), current_date) (unsupported syntax)");
  it.todo("END WORK AND NO CHAIN (unsupported syntax)");
  it.todo("END AND CHAIN (unsupported syntax)");
  it.todo("x ? 'x' (unsupported syntax)");
  it.todo("SELECT $$a$$ (unsupported syntax)");
  it.todo("SELECT $$Dianne's horse$$ (unsupported syntax)");
  it.todo("SELECT $$The price is $9.95$$ AS msg (unsupported syntax)");
  it.todo("COMMENT ON TABLE mytable IS $$doc this$$ (command not supported)");
  it.todo("UPDATE MYTABLE T1 SET T1.COL = 13 (DDL/DML not supported)");
  it.todo("x !~ 'y' (unsupported syntax)");
  it.todo("x !~* 'y' (unsupported syntax)");
  it.todo("x ~~ 'y' (unsupported syntax)");
  it.todo("x ~~* 'y' (unsupported syntax)");
  it.todo("x !~~ 'y' (unsupported syntax)");
  it.todo("x !~~* 'y' (unsupported syntax)");
  it.todo("'45 days'::interval day (unsupported syntax)");
  it.todo("'x' 'y' 'z' (unsupported syntax)");
  it.todo("x::cstring (unsupported syntax)");
  it.todo("x::oid (unsupported syntax)");
  it.todo("x::regclass (unsupported syntax)");
  it.todo("x::regcollation (unsupported syntax)");
  it.todo("x::regconfig (unsupported syntax)");
  it.todo("x::regdictionary (unsupported syntax)");
  it.todo("x::regnamespace (unsupported syntax)");
  it.todo("x::regoper (unsupported syntax)");
  it.todo("x::regoperator (unsupported syntax)");
  it.todo("x::regproc (unsupported syntax)");
  it.todo("x::regprocedure (unsupported syntax)");
  it.todo("x::regrole (unsupported syntax)");
  it.todo("x::regtype (unsupported syntax)");
  it.todo("123::CHARACTER VARYING (unsupported syntax)");
  it.todo("TO_TIMESTAMP(123::DOUBLE PRECISION) (unsupported syntax)");
  it.todo("SELECT to_timestamp(123)::time without time zone (unsupported syntax)");
  it.todo("SELECT SUM(x) OVER (PARTITION BY a ORDER BY d ROWS 1 PRECEDING) (unsupported syntax)");
  it.todo("SELECT SUBSTRING(2022::CHAR(4) || LPAD(3::CHAR(2), 2, '0') FROM 3 F... (unsupported syntax)");
  it.todo("SELECT m.name FROM manufacturers AS m LEFT JOIN LATERAL GET_PRODUCT... (unsupported syntax)");
  it.todo("SELECT p1.id, p2.id, v1, v2 FROM polygons AS p1, polygons AS p2, LA... (unsupported syntax)");
  it.todo("SELECT id, email, CAST(deleted AS TEXT) FROM users WHERE deleted NO... (unsupported syntax)");
  it.todo("SELECT id, email, CAST(deleted AS TEXT) FROM users WHERE NOT delete... (unsupported syntax)");
  it.todo(`'{"x": {"y": 1}}'::json->'x'->'y' (unsupported syntax)`);
  it.todo("'[1,2,3]'::json->>2 (unsupported syntax)");
  it.todo(`'{"a":1,"b":2}'::json->>'b' (unsupported syntax)`);
  it.todo(`'{"a":[1,2,3],"b":[4,5,6]}'::json#>'{a,2}' (unsupported syntax)`);
  it.todo(`'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}' (unsupported syntax)`);
  it.todo("'[1,2,3]'::json->2 (unsupported syntax)");
  it.todo("SELECT JSON_ARRAY_ELEMENTS((foo->'sections')::JSON) AS sections (unsupported clause)");
  it.todo("MERGE INTO x USING (SELECT id) AS y ON a = b WHEN MATCHED THEN UPDA... (DDL/DML not supported)");
  it.todo("SELECT * FROM t1* (unsupported syntax)");
  it.todo("SELECT SUBSTRING('afafa' for 1) (unsupported syntax)");
  it("CAST(x AS INT8) -> CAST(x AS BIGINT)", () => {
    validateIdentity("CAST(x AS INT8)", "CAST(x AS BIGINT)");
  });
  it.todo(`\n            WITH\n              json_data AS (SELECT '{"field_id": ... (pretty=True not supported)`);
  it.todo("x ? y (unsupported syntax)");
  it.todo("mysql -> postgres: SELECT DATE_ADD(CURRENT_TIMESTAMP, INTERVAL -1 QUARTER) (unsupported syntax)");
  it("postgres -> postgres: SELECT CURRENT_TIMESTAMP + INTERVAL '-3 MONTH'", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP + INTERVAL '-3 MONTH'", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP + INTERVAL '-3 MONTH'");
  });
  it.todo("tsql -> postgres: SELECT DATEADD(QUARTER, -1, GETDATE()) (cross-dialect transform)");
  it.todo("SELECT ARRAY[]::INT[] AS foo (unsupported syntax)");
  it.todo("STRING_TO_ARRAY('xx~^~yy~^~zz', '~^~', 'yy') (unsupported syntax) (2)");
  it.todo("SELECT ARRAY[1, 2, 3] @> ARRAY[1, 2] (UnsupportedError in write)");
  it.todo("SELECT REGEXP_REPLACE('mr .', '[^a-zA-Z]', '', 'g') (unsupported syntax)");
  it.todo("CREATE TABLE t (c INT) (DDL/DML not supported)");
  it.todo('postgres -> bigquery: SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5 (unsupported syntax)');
  it.todo('postgres -> duckdb: SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5 (cross-dialect transform)');
  it('postgres -> postgres: SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5', () => {
    const result = transpile('SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5', { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe('SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5');
  });
  it.todo('postgres -> tsql: SELECT * FROM "test_table" ORDER BY RANDOM() LIMIT 5 (cross-dialect transform)');
  it.todo("SELECT (data -> 'en-US') AS acat FROM my_table (unsupported syntax)");
  it.todo("SELECT (data ->> 'en-US') AS acat FROM my_table (unsupported syntax)");
  it.todo("clickhouse -> postgres: SELECT JSONExtractString(x, k1, k2, k3) FROM t (cross-dialect transform)");
  it.todo("redshift -> postgres: SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t (cross-dialect transform)");
  it.todo("postgres -> clickhouse: SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t (cross-dialect transform)");
  it("postgres -> postgres: SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t");
  });
  it.todo("postgres -> redshift: SELECT JSON_EXTRACT_PATH_TEXT(x, k1, k2, k3) FROM t (cross-dialect transform)");
  it.todo("x #> 'y' (unsupported syntax)");
  it.todo("x #>> 'y' (unsupported syntax)");
  it.todo("x -> 'y' -> 0 -> 'z' (unsupported syntax)");
  it.todo(`postgres -> : JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it.todo(`postgres -> bigquery: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it.todo(`postgres -> duckdb: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (unsupported syntax)`);
  it.todo(`postgres -> mysql: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it(`postgres -> postgres: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')`, () => {
    const result = transpile(`JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')`, { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe(`JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4')`);
  });
  it.todo(`postgres -> presto: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it.todo(`postgres -> redshift: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it.todo(`postgres -> spark: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (cross-dialect transform)`);
  it.todo(`postgres -> sqlite: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (unsupported syntax)`);
  it.todo(`postgres -> tsql: JSON_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4') (unsupported syntax)`);
  it.todo(`duckdb -> postgres: '{"farm": ["a", "b", "c"]}' ->> '$.farm[0]' (unsupported syntax)`);
  it.todo(`redshift -> postgres: JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0') (cross-dialect transform)`);
  it.todo(`postgres -> duckdb: JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0') (unsupported syntax)`);
  it(`postgres -> postgres: JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0')`, () => {
    const result = transpile(`JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0')`, { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe(`JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0')`);
  });
  it.todo(`postgres -> redshift: JSON_EXTRACT_PATH_TEXT('{"farm": ["a", "b", "c"]}', 'farm', '0') (cross-dialect transform)`);
  it.todo("duckdb -> postgres: x -> '$.x.y.z' (unsupported syntax)");
  it("postgres -> postgres: JSON_EXTRACT_PATH(x, 'x', 'y', 'z')", () => {
    const result = transpile("JSON_EXTRACT_PATH(x, 'x', 'y', 'z')", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("JSON_EXTRACT_PATH(x, 'x', 'y', 'z')");
  });
  it.todo("postgres -> duckdb: JSON_EXTRACT_PATH(x, 'x', 'y', 'z') (unsupported syntax)");
  it.todo("postgres -> redshift: JSON_EXTRACT_PATH(x, 'x', 'y', 'z') (cross-dialect transform)");
  it.todo("SELECT * FROM t TABLESAMPLE SYSTEM (50) (UnsupportedError in write)");
  it.todo("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) (unsupported clause)");
  it.todo("e'x' (unsupported syntax)");
  it.todo("SELECT DATE_PART('minute', timestamp '2023-01-04 04:05:06.789') (unsupported syntax)");
  it.todo("SELECT DATE_PART('month', date '20220502') (unsupported syntax)");
  it.todo("SELECT (DATE '2016-01-10', DATE '2016-02-01') OVERLAPS (DATE '2016-... (unsupported syntax)");
  it.todo("SELECT DATE_PART('epoch', CAST('2023-01-04 04:05:06.789' AS TIMESTA... (unsupported syntax)");
  it.todo("x ^ y (unsupported syntax)");
  it.todo("x # y (unsupported syntax)");
  it.todo("SELECT GENERATE_SERIES(1, 5) (UnsupportedError in write)");
  it.todo("WITH dates AS (SELECT GENERATE_SERIES('2020-01-01'::DATE, '2024-01-... (unsupported syntax)");
  it.todo("GENERATE_SERIES(a, b, '  2   days  ') (unsupported syntax)");
  it.todo("GENERATE_SERIES('2019-01-01'::TIMESTAMP, NOW(), '1day') (unsupported syntax)");
  it.todo("SELECT * FROM GENERATE_SERIES(a, b) (unsupported syntax)");
  it.todo("SELECT * FROM t CROSS JOIN GENERATE_SERIES(2, 4) (unsupported syntax)");
  it.todo("SELECT * FROM t CROSS JOIN GENERATE_SERIES(2, 4) AS s (unsupported syntax)");
  it.todo("SELECT * FROM x FETCH 1 ROW (unsupported syntax)");
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it.todo("SELECT CASE WHEN SUBSTRING('abcdefg' FROM 1 FOR 2) IN ('ab') THEN 1... (unsupported syntax) (2)");
  it.todo("SELECT * FROM x WHERE SUBSTRING(col1 FROM 3 + LENGTH(col1) - 10 FOR... (unsupported syntax)");
  it.todo("SELECT TRIM(BOTH ' XXX ') (unsupported syntax)");
  it.todo("TRIM(LEADING FROM ' XXX ') (unsupported syntax)");
  it.todo("TRIM(TRAILING FROM ' XXX ') (unsupported syntax)");
  it.todo("TRIM(BOTH 'as' FROM 'as string as') (unsupported syntax)");
  it.todo(`SELECT TRIM(LEADING ' XXX ' COLLATE "de_DE") (unsupported syntax)`);
  it.todo(`SELECT TRIM(TRAILING ' XXX ' COLLATE "de_DE") (unsupported syntax)`);
  it("LEVENSHTEIN(col1, col2)", () => {
    validateIdentity("LEVENSHTEIN(col1, col2)");
  });
  it("LEVENSHTEIN_LESS_EQUAL(col1, col2, 1)", () => {
    validateIdentity("LEVENSHTEIN_LESS_EQUAL(col1, col2, 1)");
  });
  it("LEVENSHTEIN(col1, col2, 1, 2, 3)", () => {
    validateIdentity("LEVENSHTEIN(col1, col2, 1, 2, 3)");
  });
  it("LEVENSHTEIN_LESS_EQUAL(col1, col2, 1, 2, 3, 4)", () => {
    validateIdentity("LEVENSHTEIN_LESS_EQUAL(col1, col2, 1, 2, 3, 4)");
  });
  it.todo(`'{"a":1,"b":2}'::json->'b' (unsupported syntax)`);
  it.todo("merge into x as x using (select id) as y on a = b WHEN matched then... (DDL/DML not supported)");
  it.todo("merge into x as z using (select id) as y on a = b WHEN matched then... (DDL/DML not supported)");
  it.todo("merge into x as z using (select id) as y on a = b WHEN matched then... (DDL/DML not supported) (2)");
  it.todo("merge into x using (select id) as y on a = b WHEN matched then upda... (DDL/DML not supported)");
  it.todo("x / y ^ z (unsupported syntax)");
  it("redshift -> postgres: CAST(x AS NAME)", () => {
    const result = transpile("CAST(x AS NAME)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(x AS NAME)");
  });
  it("postgres -> postgres: CAST(x AS NAME)", () => {
    const result = transpile("CAST(x AS NAME)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(x AS NAME)");
  });
  it("postgres -> redshift: CAST(x AS NAME)", () => {
    const result = transpile("CAST(x AS NAME)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("CAST(x AS NAME)");
  });
  it.todo("test_postgres: assertIsInstance call (2)");
  it.todo("COPY tbl (col1, col2) FROM 'file' WITH (FORMAT format, HEADER MATCH... (command not supported)");
  it.todo("COPY tbl (col1, col2) TO 'file' WITH (FORMAT format, HEADER MATCH, ... (command not supported)");
  it.todo("COPY (SELECT * FROM t) TO 'file' WITH (FORMAT format, HEADER MATCH,... (command not supported)");
  it("cast(a as FLOAT) -> CAST(a AS DOUBLE PRECISION)", () => {
    validateIdentity("cast(a as FLOAT)", "CAST(a AS DOUBLE PRECISION)");
  });
  it("cast(a as FLOAT8) -> CAST(a AS DOUBLE PRECISION)", () => {
    validateIdentity("cast(a as FLOAT8)", "CAST(a AS DOUBLE PRECISION)");
  });
  it("cast(a as FLOAT4) -> CAST(a AS REAL)", () => {
    validateIdentity("cast(a as FLOAT4)", "CAST(a AS REAL)");
  });
  it("postgres -> postgres: 1 / DIV(4, 2)", () => {
    const result = transpile("1 / DIV(4, 2)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("1 / DIV(4, 2)");
  });
  it.todo("postgres -> sqlite: 1 / DIV(4, 2) (cross-dialect transform)");
  it.todo("postgres -> duckdb: 1 / DIV(4, 2) (unsupported syntax)");
  it.todo("postgres -> bigquery: 1 / DIV(4, 2) (cross-dialect transform)");
  it.todo("duckdb -> postgres: CAST(4 // 2 AS DECIMAL(5, 3)) (unsupported syntax)");
  it.todo("postgres -> duckdb: CAST(DIV(4, 2) AS DECIMAL(5, 3)) (unsupported syntax)");
  it("postgres -> postgres: CAST(DIV(4, 2) AS DECIMAL(5, 3))", () => {
    const result = transpile("CAST(DIV(4, 2) AS DECIMAL(5, 3))", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CAST(DIV(4, 2) AS DECIMAL(5, 3))");
  });
  it.todo("postgres -> duckdb: SELECT TO_DATE('01/01/2000', 'MM/DD/YYYY') (cross-dialect transform)");
  it("postgres -> postgres: SELECT TO_DATE('01/01/2000', 'MM/DD/YYYY')", () => {
    const result = transpile("SELECT TO_DATE('01/01/2000', 'MM/DD/YYYY')", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT TO_DATE('01/01/2000', 'MM/DD/YYYY')");
  });
  it.todo('SELECT js, js IS JSON AS "json?", js IS JSON VALUE AS "scalar?", js... (unsupported syntax)');
  it.todo('SELECT js, js IS JSON ARRAY WITH UNIQUE KEYS AS "array w. UK?", js ... (unsupported syntax)');
  it.todo("MERGE INTO target_table USING source_table AS source ON target.id =... (DDL/DML not supported)");
  it.todo("SELECT 1 FROM ((VALUES (1)) AS vals(id) LEFT OUTER JOIN tbl ON vals... (unsupported syntax)");
  it.todo("SELECT OVERLAY(a PLACING b FROM 1) (unsupported syntax)");
  it.todo("SELECT OVERLAY(a PLACING b FROM 1 FOR 1) (unsupported syntax)");
  it.todo("ARRAY[1, 2, 3] && ARRAY[1, 2] (assert_is check)");
  it(`postgres -> postgres: SELECT JSONB_EXISTS('{"a": [1,2,3]}', 'a')`, () => {
    const result = transpile(`SELECT JSONB_EXISTS('{"a": [1,2,3]}', 'a')`, { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe(`SELECT JSONB_EXISTS('{"a": [1,2,3]}', 'a')`);
  });
  it.todo(`postgres -> duckdb: SELECT JSONB_EXISTS('{"a": [1,2,3]}', 'a') (cross-dialect transform)`);
  it.todo("WITH t AS (SELECT ARRAY[1, 2, 3] AS col) SELECT * FROM t WHERE 1 <=... (unsupported syntax)");
  it.todo("/*+ some comment*/ SELECT b.foo, b.bar FROM baz AS b (unsupported syntax)");
  it.todo("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY a) FILTER(WHERE ... (unsupported clause)");
  it("postgres -> postgres: SELECT JSON_OBJECT_AGG(k, v) FROM t", () => {
    const result = transpile("SELECT JSON_OBJECT_AGG(k, v) FROM t", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT JSON_OBJECT_AGG(k, v) FROM t");
  });
  it.todo("postgres -> duckdb: SELECT JSON_OBJECT_AGG(k, v) FROM t (cross-dialect transform)");
  it("postgres -> postgres: SELECT JSONB_OBJECT_AGG(k, v) FROM t", () => {
    const result = transpile("SELECT JSONB_OBJECT_AGG(k, v) FROM t", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT JSONB_OBJECT_AGG(k, v) FROM t");
  });
  it.todo("postgres -> duckdb: SELECT JSONB_OBJECT_AGG(k, v) FROM t (cross-dialect transform)");
  it("postgres -> postgres: SELECT DATE_BIN('30 days', timestamp_col, (SELECT MIN(TIMESTAMP) ...", () => {
    const result = transpile("SELECT DATE_BIN('30 days', timestamp_col, (SELECT MIN(TIMESTAMP) from table)) FROM table", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT DATE_BIN('30 days', timestamp_col, (SELECT MIN(TIMESTAMP) FROM table)) FROM table");
  });
  it.todo("postgres -> duckdb: SELECT DATE_BIN('30 days', timestamp_col, (SELECT MIN(TIMESTAMP) fr... (cross-dialect transform)");
  it("postgres -> postgres: SELECT ANY_VALUE(1) AS col", () => {
    const result = transpile("SELECT ANY_VALUE(1) AS col", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT ANY_VALUE(1) AS col");
  });
  it.todo("postgres -> postgres, version=16: SELECT ANY_VALUE(1) AS col (cross-dialect transform)");
  it.todo("postgres -> postgres, version=17.5: SELECT ANY_VALUE(1) AS col (cross-dialect transform)");
  it.todo("postgres -> postgres, version=15: SELECT ANY_VALUE(1) AS col (cross-dialect transform)");
  it.todo("postgres -> postgres, version=13.9: SELECT ANY_VALUE(1) AS col (cross-dialect transform)");
  it.todo("SELECT * FROM foo WHERE id = %s (unsupported syntax)");
  it.todo("SELECT * FROM foo WHERE id = %(id_param)s (unsupported syntax)");
  it.todo("SELECT * FROM foo WHERE id = ? (unsupported syntax)");
  it.todo("a ?| b (assert_is check)");
  it.todo(`SELECT '{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c'] (unsupported syntax)`);
  it.todo("a ?& b (assert_is check)");
  it.todo(`SELECT '["a", "b"]'::jsonb ?& array['a', 'b'] (unsupported syntax)`);
  it.todo("a #- b (assert_is check)");
  it.todo(`SELECT '["a", {"b":1}]'::jsonb #- '{1,b}' (unsupported syntax)`);
  it.todo("SELECT JSON_AGG(DISTINCT name) FROM users (unsupported syntax)");
  it.todo("SELECT JSON_AGG(c1 ORDER BY c1) FROM (VALUES ('c'), ('b'), ('a')) A... (unsupported syntax)");
  it.todo("SELECT JSON_AGG(DISTINCT c1 ORDER BY c1) FROM (VALUES ('c'), ('b'),... (unsupported syntax)");
  it("postgres -> postgres: SELECT REGEXP_REPLACE('aaa', 'a', 'b')", () => {
    const result = transpile("SELECT REGEXP_REPLACE('aaa', 'a', 'b')", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_REPLACE('aaa', 'a', 'b')");
  });
  it("duckdb -> postgres: SELECT REGEXP_REPLACE('aaa', 'a', 'b')", () => {
    const result = transpile("SELECT REGEXP_REPLACE('aaa', 'a', 'b')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_REPLACE('aaa', 'a', 'b')");
  });
  it("postgres -> duckdb: SELECT REGEXP_REPLACE('aaa', 'a', 'b')", () => {
    const result = transpile("SELECT REGEXP_REPLACE('aaa', 'a', 'b')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT REGEXP_REPLACE('aaa', 'a', 'b')");
  });
  it("redshift -> postgres: SELECT TO_CHAR(foo, bar)", () => {
    const result = transpile("SELECT TO_CHAR(foo, bar)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TO_CHAR(foo, bar)");
  });
  it("postgres -> postgres: SELECT TO_CHAR(foo, bar)", () => {
    const result = transpile("SELECT TO_CHAR(foo, bar)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT TO_CHAR(foo, bar)");
  });
  it("postgres -> redshift: SELECT TO_CHAR(foo, bar)", () => {
    const result = transpile("SELECT TO_CHAR(foo, bar)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("SELECT TO_CHAR(foo, bar)");
  });
  it.todo("CREATE TABLE table1 (a INT, b INT, PRIMARY KEY (a)) (DDL/DML not supported)");
  it.todo("SELECT NUMRANGE(1.1, 2.2) -|- NUMRANGE(2.2, 3.3) (unsupported syntax)");
  it.todo("SELECT SLOPE(point '(4,4)', point '(0,0)') (unsupported syntax)");
  it.todo("test_postgres: assertIsNotNone call");
  it.todo("test_postgres: assertIsNone call");
  it.todo("UPDATE foo SET a = bar.a, b = bar.b FROM bar WHERE foo.id = bar.id (DDL/DML not supported)");
  it.todo("SELECT MLEAST(VARIADIC ARRAY[10, -1, 5, 4.4]) (unsupported syntax)");
  it.todo("SELECT MLEAST(VARIADIC ARRAY[]::numeric[]) (unsupported syntax)");
  it.todo("SELECT * FROM schema_name.table_name st WHERE JSON_EXTRACT_PATH_TEX... (unsupported syntax)");
});

describe("Postgres: ddl", () => {
  it.todo("test_ddl: assertIsInstance call");
  it.todo("test_ddl: assertEqual call");
  it.todo('ALTER INDEX "IX_Ratings_Column1" RENAME TO "IX_Ratings_Column2" (DDL/DML not supported)');
  it.todo('CREATE TABLE x (a TEXT COLLATE "de_DE") (DDL/DML not supported)');
  it.todo('CREATE TABLE x (a TEXT COLLATE pg_catalog."default") (DDL/DML not supported)');
  it.todo("CREATE TABLE t (col INT[3][5]) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col INT[3]) (DDL/DML not supported)");
  it.todo("CREATE INDEX IF NOT EXISTS ON t(c) (DDL/DML not supported)");
  it.todo("CREATE INDEX et_vid_idx ON et(vid) INCLUDE (fid) (DDL/DML not supported)");
  it.todo("CREATE INDEX idx_x ON x USING BTREE(x, y) WHERE (NOT y IS NULL) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (elems JSONB[]) (DDL/DML not supported)");
  it.todo("CREATE TABLE public.y (x TSTZRANGE NOT NULL) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (foo HSTORE) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (foo JSONB) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (foo VARCHAR(64)[]) (DDL/DML not supported)");
  it.todo("CREATE TABLE test (foo INT) PARTITION BY HASH(foo) (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) RETURNING a (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) RETURNING a, b (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) RETURNING * (DDL/DML not supported)");
  it.todo("UPDATE tbl_name SET foo = 123 RETURNING a (DDL/DML not supported)");
  it.todo("CREATE TABLE cities_partdef PARTITION OF cities DEFAULT (DDL/DML not supported)");
  it.todo("CREATE TABLE t (c CHAR(2) UNIQUE NOT NULL) INHERITS (t1) (DDL/DML not supported)");
  it.todo("CREATE TABLE s.t (c CHAR(2) UNIQUE NOT NULL) INHERITS (s.t1, s.t2) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION x(INT) RETURNS INT SET search_path = 'public' (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 CONTINUE IDENTITY (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 RESTART IDENTITY (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 CASCADE (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 RESTRICT (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 CONTINUE IDENTITY CASCADE (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 RESTART IDENTITY RESTRICT (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET LOGGED (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET UNLOGGED (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET WITHOUT CLUSTER (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET WITHOUT OIDS (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET ACCESS METHOD method (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET TABLESPACE tablespace (DDL/DML not supported)");
  it.todo("ALTER TABLE t1 SET (fillfactor = 5, autovacuum_enabled = TRUE) (DDL/DML not supported)");
  it.todo("INSERT INTO book (isbn, title) VALUES ($1, $2) ON CONFLICT(isbn) WH... (DDL/DML not supported)");
  it.todo("INSERT INTO newtable AS t(a, b, c) VALUES (1, 2, 3) ON CONFLICT(c) ... (DDL/DML not supported)");
  it.todo("ALTER TABLE tested_table ADD CONSTRAINT unique_example UNIQUE (colu... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION pymax(a INT, b INT) RETURNS INT LANGUAGE plpython3u... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (vid INT NOT NULL, CONSTRAINT ht_vid_nid_fid_idx EXC... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (i INT, a TEXT, PRIMARY KEY (i) INCLUDE (a)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (i INT, PRIMARY KEY (i), EXCLUDE USING gist(col varc... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (i INT, EXCLUDE USING btree(INT4RANGE(vid, nid, '[]'... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (i INT, EXCLUDE USING gin(col1 WITH &&, col2 WITH ||... (DDL/DML not supported)");
  it.todo("CREATE TABLE A (LIKE B INCLUDING CONSTRAINT INCLUDING COMPRESSION E... (DDL/DML not supported)");
  it.todo("CREATE TABLE cust_part3 PARTITION OF customers FOR VALUES WITH (MOD... (DDL/DML not supported)");
  it.todo("CREATE TABLE measurement_y2016m07 PARTITION OF measurement (unitsal... (DDL/DML not supported)");
  it.todo("CREATE TABLE measurement_ym_older PARTITION OF measurement_year_mon... (DDL/DML not supported)");
  it.todo("CREATE TABLE measurement_ym_y2016m11 PARTITION OF measurement_year_... (DDL/DML not supported)");
  it.todo("CREATE TABLE cities_ab PARTITION OF cities (CONSTRAINT city_id_nonz... (DDL/DML not supported)");
  it.todo("CREATE TABLE cities_ab PARTITION OF cities (CONSTRAINT city_id_nonz... (DDL/DML not supported) (2)");
  it.todo("CREATE INDEX foo ON bar.baz USING btree(col1 varchar_pattern_ops AS... (DDL/DML not supported)");
  it.todo("CREATE INDEX index_issues_on_title_trigram ON public.issues USING g... (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON CONFLICT(id) DO NOTHING RETUR... (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON CONFLICT(id) DO UPDATE SET x.... (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON CONFLICT(id) DO UPDATE SET x.... (DDL/DML not supported) (2)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON CONFLICT ON CONSTRAINT pkey D... (DDL/DML not supported)");
  it.todo("INSERT INTO x VALUES (1, 'a', 2.0) ON CONFLICT ON CONSTRAINT pkey D... (DDL/DML not supported) (2)");
  it.todo("DELETE FROM event USING sales AS s WHERE event.eventid = s.eventid ... (DDL/DML not supported)");
  it.todo("WITH t(c) AS (SELECT 1) SELECT * INTO UNLOGGED foo FROM (SELECT c A... (unsupported syntax)");
  it.todo("CREATE TABLE test (x TIMESTAMP WITHOUT TIME ZONE[][]) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION add(integer, integer) RETURNS INT LANGUAGE SQL IMMU... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION add(integer, integer) RETURNS INT LANGUAGE SQL IMMU... (DDL/DML not supported) (2)");
  it.todo("CREATE FUNCTION add(INT, INT) RETURNS INT SET search_path TO 'publi... (check_command_warning)");
  it.todo("CREATE FUNCTION x(INT) RETURNS INT SET foo FROM CURRENT (check_command_warning)");
  it.todo("CREATE FUNCTION add(integer, integer) RETURNS integer AS 'select $1... (check_command_warning)");
  it.todo("CREATE CONSTRAINT TRIGGER my_trigger AFTER INSERT OR DELETE OR UPDA... (check_command_warning)");
  it.todo("CREATE UNLOGGED TABLE foo AS WITH t(c) AS (SELECT 1) SELECT * FROM ... (DDL/DML not supported)");
  it.todo("ALTER TABLE foo ADD COLUMN id BIGINT NOT NULL PRIMARY KEY DEFAULT 1... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col integer ARRAY[3]) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (col integer ARRAY) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION x(INT) RETURNS INT SET search_path TO 'public' (DDL/DML not supported)");
  it.todo("CREATE TABLE test (x TIMESTAMP WITHOUT TIME ZONE[][]) (DDL/DML not supported) (2)");
  it.todo("CREATE OR REPLACE FUNCTION function_name (input_a character varying... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(a INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(IN a INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(OUT a INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(INOUT a INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(VARIADIC a INT[]) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(out INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(inout VARCHAR) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(variadic INT[]) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(a INT, OUT b INT, INOUT c VARCHAR, VARIADIC d I... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE FUNCTION foo(INOUT id UUID) (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE FUNCTION foo(id UUID, OUT created_at TIMESTAMPTZ) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(OUT x INT DEFAULT 5) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(INOUT y VARCHAR DEFAULT 'test') (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(IN a INT DEFAULT 0, OUT b INT) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(VARIADIC args INT[] DEFAULT ARRAY[]::INT[]) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION foo(OUT result INT, IN input INT DEFAULT 10) (DDL/DML not supported)");
  it.todo("CREATE TABLE products (product_no INT UNIQUE, name TEXT, price DECI... (DDL/DML not supported)");
  it.todo("CREATE TABLE products (product_no INT CONSTRAINT must_be_different ... (DDL/DML not supported)");
  it.todo("CREATE TABLE products (product_no INT, name TEXT, price DECIMAL, UN... (DDL/DML not supported)");
  it.todo("CREATE TABLE products (product_no INT UNIQUE, name TEXT, price DECI... (DDL/DML not supported) (2)");
  it.todo("\n            CREATE INDEX index_ci_builds_on_commit_id_and_artifact... (DDL/DML not supported)");
  it.todo("CREATE INDEX index_ci_pipelines_on_project_idandrefandiddesc ON pub... (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE ONLY t1, t2*, ONLY t3, t4, t5* RESTART IDENTITY CASCADE (DDL/DML not supported)");
  it.todo("CREATE TABLE x (a UUID, b BYTEA) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (col INT UNIQUE NULLS NOT DISTINCT DEFAULT 9.99) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (col UUID UNIQUE DEFAULT GEN_RANDOM_UUID()) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (col UUID, UNIQUE NULLS NOT DISTINCT (col)) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (col_a INT GENERATED ALWAYS AS (1 + 2) STORED) (DDL/DML not supported)");
  it.todo("CREATE TABLE tbl (col_a INTERVAL GENERATED ALWAYS AS (a - b) STORED) (DDL/DML not supported)");
  it.todo("CREATE INDEX CONCURRENTLY ix_table_id ON tbl USING btree(id) (DDL/DML not supported)");
  it.todo("CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_table_id ON tbl USING bt... (DDL/DML not supported)");
  it.todo("DROP INDEX ix_table_id (DDL/DML not supported)");
  it.todo("DROP INDEX IF EXISTS ix_table_id (DDL/DML not supported)");
  it.todo("DROP INDEX CONCURRENTLY ix_table_id (DDL/DML not supported)");
  it.todo("DROP INDEX CONCURRENTLY IF EXISTS ix_table_id (DDL/DML not supported)");
  it.todo("\n        CREATE TABLE IF NOT EXISTS public.rental\n        (\n       ... (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH =)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH >=)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH <=)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH <)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH >)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH &&)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH ||)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH @>)) (DDL/DML not supported)");
  it.todo("CREATE TABLE circles (c circle, EXCLUDE USING gist(c WITH <@)) (DDL/DML not supported)");
});

describe("Postgres: unnest", () => {
  it.todo("SELECT * FROM UNNEST(ARRAY[1, 2], ARRAY['foo', 'bar', 'baz']) AS x(... (unsupported syntax)");
  it.todo("postgres -> hive: SELECT UNNEST(c) FROM t (cross-dialect transform)");
  it("postgres -> postgres: SELECT UNNEST(c) FROM t", () => {
    const result = transpile("SELECT UNNEST(c) FROM t", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("SELECT UNNEST(c) FROM t");
  });
  it.todo("postgres -> presto: SELECT UNNEST(c) FROM t (unsupported clause)");
  it.todo("SELECT UNNEST(ARRAY[1]) (unsupported syntax)");
});

describe("Postgres: array_offset", () => {
  it.todo("SELECT col[1] (unsupported syntax)");
  it.todo("test_array_offset: assertEqual call");
});

describe("Postgres: bool_or", () => {
  it("SELECT a, LOGICAL_OR(b) FROM table GROUP BY a -> SELECT a, BOOL_OR(b) FROM table GROUP ...", () => {
    validateIdentity("SELECT a, LOGICAL_OR(b) FROM table GROUP BY a", "SELECT a, BOOL_OR(b) FROM table GROUP BY a");
  });
});

describe("Postgres: string_concat", () => {
  it("SELECT CONCAT('abcde', 2, NULL, 22)", () => {
    validateIdentity("SELECT CONCAT('abcde', 2, NULL, 22)");
  });
  it.todo("postgres -> : CONCAT(a, b) (cross-dialect transform)");
  it.todo("postgres -> clickhouse: CONCAT(a, b) (cross-dialect transform)");
  it.todo("postgres -> duckdb: CONCAT(a, b) (cross-dialect transform)");
  it("postgres -> postgres: CONCAT(a, b)", () => {
    const result = transpile("CONCAT(a, b)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("CONCAT(a, b)");
  });
  it.todo("postgres -> presto: CONCAT(a, b) (cross-dialect transform)");
  it.todo("a || b (unsupported syntax)");
});

describe("Postgres: variance", () => {
  it("VAR_SAMP(x) -> VAR_SAMP(x)", () => {
    validateIdentity("VAR_SAMP(x)", "VAR_SAMP(x)");
  });
  it("VAR_POP(x) -> VAR_POP(x)", () => {
    validateIdentity("VAR_POP(x)", "VAR_POP(x)");
  });
  it("VARIANCE(x) -> VAR_SAMP(x)", () => {
    validateIdentity("VARIANCE(x)", "VAR_SAMP(x)");
  });
  it.todo(" -> postgres: VARIANCE_POP(x) (cross-dialect transform)");
  it("postgres -> postgres: VAR_POP(x)", () => {
    const result = transpile("VAR_POP(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("VAR_POP(x)");
  });
});

describe("Postgres: corr", () => {
  it.todo("SELECT CORR(a, b) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) OVER (PARTITION BY c) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) FILTER(WHERE c > 0) (unsupported syntax)");
  it.todo("SELECT CORR(a, b) FILTER(WHERE c > 0) OVER (PARTITION BY d) (unsupported syntax)");
});

describe("Postgres: regexp_binary", () => {
  it.todo("test_regexp_binary: assertIsInstance call");
  it.todo("test_regexp_binary: assertIsInstance call (2)");
});

describe("Postgres: unnest_json_array", () => {
  it.todo("test_unnest_json_array: unresolvable SQL string");
});

describe("Postgres: rows_from", () => {
  it.todo("SELECT * FROM ROWS FROM (FUNC1(col1, col2)) (unsupported syntax)");
  it.todo('SELECT * FROM ROWS FROM (FUNC1(col1) AS alias1("col1" TEXT), FUNC2(... (unsupported clause)');
  it.todo('SELECT * FROM table1, ROWS FROM (FUNC1(col1) AS alias1("col1" TEXT)... (unsupported clause)');
});

describe("Postgres: array_length", () => {
  it.todo("SELECT ARRAY_LENGTH(ARRAY[1, 2, 3], 1) (unsupported syntax)");
  it.todo("bigquery -> postgres: ARRAY_LENGTH(arr) (cross-dialect transform)");
  it.todo("duckdb -> postgres: ARRAY_LENGTH(arr) (cross-dialect transform)");
  it.todo("presto -> postgres: CARDINALITY(arr) (cross-dialect transform)");
  it.todo("drill -> postgres: REPEATED_COUNT(arr) (cross-dialect transform)");
  it.todo("teradata -> postgres: CARDINALITY(arr) (cross-dialect transform)");
  it.todo("hive -> postgres: SIZE(arr) (cross-dialect transform)");
  it.todo("spark2 -> postgres: SIZE(arr) (cross-dialect transform)");
  it.todo("spark -> postgres: SIZE(arr) (cross-dialect transform)");
  it.todo("databricks -> postgres: SIZE(arr) (cross-dialect transform)");
  it.todo("postgres -> duckdb: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> presto: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> teradata: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> bigquery: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> drill: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> clickhouse: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> hive: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> spark2: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> spark: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("postgres -> databricks: ARRAY_LENGTH(arr, 1) (cross-dialect transform)");
  it.todo("ARRAY_LENGTH(arr, foo) (UnsupportedError in write)");
});

describe("Postgres: xmlelement", () => {
  it.todo("SELECT XMLELEMENT(NAME foo) (unsupported syntax)");
  it.todo("SELECT XMLELEMENT(NAME foo, XMLATTRIBUTES('xyz' AS bar)) (unsupported syntax)");
  it.todo("SELECT XMLELEMENT(NAME test, XMLATTRIBUTES(a, b)) FROM test (unsupported syntax)");
  it.todo("SELECT XMLELEMENT(NAME foo, XMLATTRIBUTES(CURRENT_DATE AS bar), 'co... (unsupported syntax)");
  it.todo(`SELECT XMLELEMENT(NAME "foo$bar", XMLATTRIBUTES('xyz' AS "a&b")) (unsupported syntax)`);
  it.todo("SELECT XMLELEMENT(NAME foo, XMLATTRIBUTES('xyz' AS bar), XMLELEMENT... (unsupported syntax)");
});

describe("Postgres: analyze", () => {
  it.todo("ANALYZE TBL (command not supported)");
  it.todo("ANALYZE TBL(col1, col2) (command not supported)");
  it.todo("ANALYZE VERBOSE SKIP_LOCKED TBL(col1, col2) (command not supported)");
  it.todo("ANALYZE BUFFER_USAGE_LIMIT 1337 TBL (command not supported)");
});

describe("Postgres: recursive_cte", () => {
  it.todo("WITH RECURSIVE search_tree(id, link, data) AS (SELECT t.id, t.link,... (unsupported syntax)");
  it.todo("WITH RECURSIVE search_tree(id, link, data) AS (SELECT t.id, t.link,... (unsupported syntax) (2)");
  it.todo("WITH RECURSIVE search_graph(id, link, data, depth) AS (SELECT g.id,... (unsupported syntax)");
});

describe("Postgres: json_extract", () => {
  it.todo("SELECT foo -> 1 (unsupported syntax)");
  it.todo("SELECT foo -> '12' (unsupported syntax)");
  it.todo("SELECT foo ->> 1 (unsupported syntax)");
  it.todo("SELECT foo ->> '12' (unsupported syntax)");
});

describe("Postgres: round", () => {
  it("ROUND(x)", () => {
    validateIdentity("ROUND(x)");
  });
  it("ROUND(x, y)", () => {
    validateIdentity("ROUND(x, y)");
  });
  it("ROUND(CAST(x AS DOUBLE PRECISION))", () => {
    validateIdentity("ROUND(CAST(x AS DOUBLE PRECISION))");
  });
  it("ROUND(CAST(x AS DECIMAL), 4)", () => {
    validateIdentity("ROUND(CAST(x AS DECIMAL), 4)");
  });
  it("ROUND(CAST(x AS INT), 4)", () => {
    validateIdentity("ROUND(CAST(x AS INT), 4)");
  });
  it.todo("postgres -> postgres: ROUND(x::DOUBLE, 4) (unsupported syntax)");
  it.todo("hive -> postgres: ROUND(x::DOUBLE, 4) (unsupported syntax)");
  it.todo("bigquery -> postgres: ROUND(x::DOUBLE, 4) (unsupported syntax)");
  it.todo("duckdb -> postgres: ROUND(x::DECIMAL, 4) (unsupported syntax)");
});

describe("Postgres: datatype", () => {
  it.todo("test_datatype: assertEqual call");
  it.todo("CREATE TABLE foo (data XML) (DDL/DML not supported)");
});

describe("Postgres: locks", () => {
  it.todo("SELECT 1 FROM foo AS x FOR SHARE OF x (unsupported clause)");
  it.todo("SELECT 1 FROM foo AS x FOR UPDATE OF x (unsupported clause)");
  it.todo("SELECT 1 FROM foo AS x FOR NO KEY UPDATE OF x (unsupported clause)");
  it.todo("SELECT 1 FROM foo AS x FOR KEY SHARE OF x (unsupported syntax)");
});

describe("Postgres: grant", () => {
  it.todo("test_grant: unresolvable for-loop iterable");
  it.todo("GRANT EXECUTE ON FUNCTION calculate_bonus(integer) TO analyst (command not supported)");
  it.todo("test_grant: unresolvable for-loop iterable (2)");
});

describe("Postgres: revoke", () => {
  it.todo("test_revoke: unresolvable for-loop iterable");
  it.todo("REVOKE EXECUTE ON FUNCTION calculate_bonus(integer) FROM analyst (command not supported)");
  it.todo("test_revoke: unresolvable for-loop iterable (2)");
});

describe("Postgres: begin_transaction", () => {
  it.todo("BEGIN (command not supported)");
  it.todo("BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SER... (assert_is check)");
  it.todo("BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED, ISOLATION LEVEL R... (assert_is check)");
  it.todo("BEGIN TRANSACTION NOT DEFFERABLE, NOT DEFFERABLE (assert_is check)");
  it.todo("BEGIN TRANSACTION READ WRITE, READ WRITE (assert_is check)");
  it.todo("BEGIN TRANSACTION DEFERRABLE, DEFERRABLE (assert_is check)");
  it.todo("BEGIN WORK ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SERIALIZABLE (assert_is check)");
  it.todo("BEGIN WORK ISOLATION LEVEL READ COMMITTED, ISOLATION LEVEL READ COM... (assert_is check)");
  it.todo("BEGIN WORK NOT DEFFERABLE, NOT DEFFERABLE (assert_is check)");
  it.todo("BEGIN WORK READ WRITE, READ WRITE (assert_is check)");
  it.todo("BEGIN WORK DEFERRABLE, DEFERRABLE (assert_is check)");
});

describe("Postgres: interval_span", () => {
  it("INTERVAL '1 01:'", () => {
    validateIdentity("INTERVAL '1 01:'");
  });
  it("INTERVAL '1 01:00'", () => {
    validateIdentity("INTERVAL '1 01:00'");
  });
  it("INTERVAL '1.5 01:'", () => {
    validateIdentity("INTERVAL '1.5 01:'");
  });
  it("INTERVAL '-0.25 01:'", () => {
    validateIdentity("INTERVAL '-0.25 01:'");
  });
  it("INTERVAL '1 01:01:'", () => {
    validateIdentity("INTERVAL '1 01:01:'");
  });
  it("INTERVAL '1 01:01:' (2)", () => {
    validateIdentity("INTERVAL '1 01:01:'");
  });
  it("INTERVAL '1 01:01:01'", () => {
    validateIdentity("INTERVAL '1 01:01:01'");
  });
  it("INTERVAL '1 01:01:01.01'", () => {
    validateIdentity("INTERVAL '1 01:01:01.01'");
  });
  it("INTERVAL '1.5 01:01:'", () => {
    validateIdentity("INTERVAL '1.5 01:01:'");
  });
  it("INTERVAL '-0.25 01:01:'", () => {
    validateIdentity("INTERVAL '-0.25 01:01:'");
  });
  it.todo("test_interval_span: unresolvable SQL string");
  it.todo("test_interval_span: assertIsInstance call");
});
