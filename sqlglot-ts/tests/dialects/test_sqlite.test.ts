// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "sqlite";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Sqlite: sqlite", () => {
  it("SELECT * FROM t AS t INDEXED BY s.i", () => {
    validateIdentity("SELECT * FROM t AS t INDEXED BY s.i");
  });
  it("SELECT * FROM t INDEXED BY s.i", () => {
    validateIdentity("SELECT * FROM t INDEXED BY s.i");
  });
  it("SELECT * FROM t INDEXED BY i", () => {
    validateIdentity("SELECT * FROM t INDEXED BY i");
  });
  it("SELECT * FROM t NOT INDEXED", () => {
    validateIdentity("SELECT * FROM t NOT INDEXED");
  });
  it("SELECT match FROM t", () => {
    validateIdentity("SELECT match FROM t");
  });
  it("SELECT rowid FROM t1 WHERE t1 MATCH 'lorem'", () => {
    validateIdentity("SELECT rowid FROM t1 WHERE t1 MATCH 'lorem'");
  });
  it("SELECT RANK() OVER (RANGE CURRENT ROW) FROM tbl", () => {
    validateIdentity("SELECT RANK() OVER (RANGE CURRENT ROW) FROM tbl");
  });
  it("UNHEX(a, b)", () => {
    validateIdentity("UNHEX(a, b)");
  });
  it("SELECT DATE()", () => {
    validateIdentity("SELECT DATE()");
  });
  it("SELECT DATE('now', 'start of month', '+1 month', '-1 day')", () => {
    validateIdentity("SELECT DATE('now', 'start of month', '+1 month', '-1 day')");
  });
  it("SELECT DATETIME(1092941466, 'unixepoch')", () => {
    validateIdentity("SELECT DATETIME(1092941466, 'unixepoch')");
  });
  it("SELECT DATETIME(1092941466, 'auto')", () => {
    validateIdentity("SELECT DATETIME(1092941466, 'auto')");
  });
  it("SELECT DATETIME(1092941466, 'unixepoch', 'localtime')", () => {
    validateIdentity("SELECT DATETIME(1092941466, 'unixepoch', 'localtime')");
  });
  it("SELECT UNIXEPOCH()", () => {
    validateIdentity("SELECT UNIXEPOCH()");
  });
  it("SELECT JULIANDAY('now') - JULIANDAY('1776-07-04')", () => {
    validateIdentity("SELECT JULIANDAY('now') - JULIANDAY('1776-07-04')");
  });
  it("SELECT UNIXEPOCH() - UNIXEPOCH('2004-01-01 02:34:56')", () => {
    validateIdentity("SELECT UNIXEPOCH() - UNIXEPOCH('2004-01-01 02:34:56')");
  });
  it("SELECT DATE('now', 'start of year', '+9 months', 'weekday 2')", () => {
    validateIdentity("SELECT DATE('now', 'start of year', '+9 months', 'weekday 2')");
  });
  it("SELECT (JULIANDAY('now') - 2440587.5) * 86400.0", () => {
    validateIdentity("SELECT (JULIANDAY('now') - 2440587.5) * 86400.0");
  });
  it("SELECT UNIXEPOCH('now', 'subsec')", () => {
    validateIdentity("SELECT UNIXEPOCH('now', 'subsec')");
  });
  it("SELECT TIMEDIFF('now', '1809-02-12')", () => {
    validateIdentity("SELECT TIMEDIFF('now', '1809-02-12')");
  });
  it.todo("SELECT * FROM GENERATE_SERIES(1, 5) (unsupported syntax)");
  it.todo("SELECT INSTR(haystack, needle) (unsupported syntax)");
  it.todo("SELECT a, SUM(b) OVER (ORDER BY a ROWS BETWEEN -1 PRECEDING AND 1 F... (unsupported clause)");
  it("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[2]', '$[0]', '$[1]')", () => {
    validateIdentity("SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[2]', '$[0]', '$[1]')");
  });
  it.todo(`SELECT item AS "item", some AS "some" FROM data WHERE (item = 'valu... (unsupported syntax)`);
  it("SELECT a FROM t1 WHERE a NOT NULL AND a NOT NULL ORDER BY a -> SELECT a FROM t1 WHERE N...", () => {
    validateIdentity("SELECT a FROM t1 WHERE a NOT NULL AND a NOT NULL ORDER BY a", "SELECT a FROM t1 WHERE NOT a IS NULL AND NOT a IS NULL ORDER BY a");
  });
  it("SELECT a, b FROM t1 WHERE b + a NOT NULL ORDER BY 1 -> SELECT a, b FROM t1 WHERE NOT b ...", () => {
    validateIdentity("SELECT a, b FROM t1 WHERE b + a NOT NULL ORDER BY 1", "SELECT a, b FROM t1 WHERE NOT b + a IS NULL ORDER BY 1");
  });
  it("SELECT * FROM t1, t2 -> SELECT * FROM t1 CROSS JOIN t2", () => {
    validateIdentity("SELECT * FROM t1, t2", "SELECT * FROM t1 CROSS JOIN t2");
  });
  it.todo("ALTER TABLE t RENAME a TO b (DDL/DML not supported)");
  it("sqlite -> sqlite: SELECT LIKE(y, x)", () => {
    const result = transpile("SELECT LIKE(y, x)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT x LIKE y");
  });
  it("sqlite -> sqlite: SELECT GLOB('*y*', 'xyz')", () => {
    const result = transpile("SELECT GLOB('*y*', 'xyz')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT 'xyz' GLOB '*y*'");
  });
  it("sqlite -> sqlite: SELECT LIKE('%y%', 'xyz', '')", () => {
    const result = transpile("SELECT LIKE('%y%', 'xyz', '')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT 'xyz' LIKE '%y%' ESCAPE ''");
  });
  it(" -> sqlite: CURRENT_DATE", () => {
    const result = transpile("CURRENT_DATE", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_DATE");
  });
  it("snowflake -> sqlite: CURRENT_DATE()", () => {
    const result = transpile("CURRENT_DATE()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_DATE");
  });
  it(" -> sqlite: CURRENT_TIME", () => {
    const result = transpile("CURRENT_TIME", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_TIME");
  });
  it(" -> sqlite: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("snowflake -> sqlite: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("snowflake -> sqlite: SELECT CAST('2020-01-01 16:03:05' AS DATE)", () => {
    const result = transpile("SELECT CAST('2020-01-01 16:03:05' AS DATE)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE('2020-01-01 16:03:05')");
  });
  it("sqlite -> sqlite: SELECT CAST([a].[b] AS SMALLINT) FROM foo", () => {
    const result = transpile("SELECT CAST([a].[b] AS SMALLINT) FROM foo", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe('SELECT CAST("a"."b" AS INTEGER) FROM foo');
  });
  it("sqlite -> spark: SELECT CAST([a].[b] AS SMALLINT) FROM foo", () => {
    const result = transpile("SELECT CAST([a].[b] AS SMALLINT) FROM foo", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT CAST(`a`.`b` AS SMALLINT) FROM foo");
  });
  it("sqlite -> sqlite: EDITDIST3(col1, col2)", () => {
    const result = transpile("EDITDIST3(col1, col2)", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("EDITDIST3(col1, col2)");
  });
  it("spark -> sqlite: LEVENSHTEIN(col1, col2)", () => {
    const result = transpile("LEVENSHTEIN(col1, col2)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("EDITDIST3(col1, col2)");
  });
  it("sqlite -> sqlite: EDITDIST3(col1, col2) (2)", () => {
    const result = transpile("EDITDIST3(col1, col2)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("EDITDIST3(col1, col2)");
  });
  it("sqlite -> spark: EDITDIST3(col1, col2)", () => {
    const result = transpile("EDITDIST3(col1, col2)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LEVENSHTEIN(col1, col2)");
  });
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it("snowflake -> sqlite: LEAST(x)", () => {
    const result = transpile("LEAST(x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("x");
  });
  it("snowflake -> sqlite: MIN(x)", () => {
    const result = transpile("MIN(x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("MIN(x)");
  });
  it("sqlite -> snowflake: MIN(x)", () => {
    const result = transpile("MIN(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("MIN(x)");
  });
  it("snowflake -> sqlite: LEAST(x, y, z)", () => {
    const result = transpile("LEAST(x, y, z)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("MIN(x, y, z)");
  });
  it("sqlite -> snowflake: MIN(x, y, z)", () => {
    const result = transpile("MIN(x, y, z)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("LEAST(x, y, z)");
  });
  it("sqlite -> : UNICODE(x)", () => {
    const result = transpile("UNICODE(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("UNICODE(x)");
  });
  it.todo("sqlite -> mysql: UNICODE(x) (unsupported syntax)");
  it("sqlite -> oracle: UNICODE(x)", () => {
    const result = transpile("UNICODE(x)", { readDialect: DIALECT, writeDialect: "oracle" })[0];
    expect(result).toBe("ASCII(UNISTR(x))");
  });
  it("sqlite -> postgres: UNICODE(x)", () => {
    const result = transpile("UNICODE(x)", { readDialect: DIALECT, writeDialect: "postgres" })[0];
    expect(result).toBe("ASCII(x)");
  });
  it("sqlite -> redshift: UNICODE(x)", () => {
    const result = transpile("UNICODE(x)", { readDialect: DIALECT, writeDialect: "redshift" })[0];
    expect(result).toBe("ASCII(x)");
  });
  it("sqlite -> spark: UNICODE(x)", () => {
    const result = transpile("UNICODE(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ASCII(x)");
  });
  it("SELECT * FROM station WHERE city IS NOT '' -> SELECT * FROM station WHERE NOT city IS ''", () => {
    validateIdentity("SELECT * FROM station WHERE city IS NOT ''", "SELECT * FROM station WHERE NOT city IS ''");
  });
  it("SELECT JSON_OBJECT('col1', 1, 'col2', '1')", () => {
    validateIdentity("SELECT JSON_OBJECT('col1', 1, 'col2', '1')");
  });
  it.todo('CREATE TABLE "foo t" ("foo t id" TEXT NOT NULL, PRIMARY KEY ("foo t... (DDL/DML not supported)');
  it.todo("REPLACE INTO foo (x, y) VALUES (1, 2) (check_command_warning)");
  it.todo("ATTACH DATABASE 'foo' AS schema_name (command not supported)");
  it.todo("ATTACH DATABASE NOT EXISTS(SELECT 1) AS schema_name (command not supported)");
  it.todo("ATTACH DATABASE IIF(NOT EXISTS(SELECT 1), 'foo1', 'foo2') AS schema... (command not supported)");
  it.todo("ATTACH DATABASE 'foo' || '.foo2' AS schema_name (command not supported)");
  it.todo("DETACH DATABASE schema_name (command not supported)");
  it("SELECT * FROM t WHERE NULL IS y", () => {
    validateIdentity("SELECT * FROM t WHERE NULL IS y");
  });
  it("SELECT * FROM t WHERE NULL IS NOT y -> SELECT * FROM t WHERE NOT NULL IS y", () => {
    validateIdentity("SELECT * FROM t WHERE NULL IS NOT y", "SELECT * FROM t WHERE NOT NULL IS y");
  });
  it("SELECT SQLITE_VERSION()", () => {
    validateIdentity("SELECT SQLITE_VERSION()");
  });
});

describe("Sqlite: strftime", () => {
  it("SELECT STRFTIME('%Y/%m/%d', 'now')", () => {
    validateIdentity("SELECT STRFTIME('%Y/%m/%d', 'now')");
  });
  it("SELECT STRFTIME('%Y-%m-%d', '2016-10-16', 'start of month')", () => {
    validateIdentity("SELECT STRFTIME('%Y-%m-%d', '2016-10-16', 'start of month')");
  });
  it("SELECT STRFTIME('%s') -> SELECT STRFTIME('%s', CURRENT_TIMESTAMP)", () => {
    validateIdentity("SELECT STRFTIME('%s')", "SELECT STRFTIME('%s', CURRENT_TIMESTAMP)");
  });
  it.todo("sqlite -> duckdb: SELECT STRFTIME('%Y-%m-%d', '2020-01-01 12:05:03') (unsupported syntax)");
  it("sqlite -> sqlite: SELECT STRFTIME('%Y-%m-%d', '2020-01-01 12:05:03')", () => {
    const result = transpile("SELECT STRFTIME('%Y-%m-%d', '2020-01-01 12:05:03')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT STRFTIME('%Y-%m-%d', '2020-01-01 12:05:03')");
  });
  it.todo("sqlite -> duckdb: SELECT STRFTIME('%Y-%m-%d', CURRENT_TIMESTAMP) (unsupported syntax)");
  it("sqlite -> sqlite: SELECT STRFTIME('%Y-%m-%d', CURRENT_TIMESTAMP)", () => {
    const result = transpile("SELECT STRFTIME('%Y-%m-%d', CURRENT_TIMESTAMP)", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT STRFTIME('%Y-%m-%d', CURRENT_TIMESTAMP)");
  });
});

describe("Sqlite: datediff", () => {
  it("sqlite -> sqlite: DATEDIFF(a, b, 'day')", () => {
    const result = transpile("DATEDIFF(a, b, 'day')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("CAST((JULIANDAY(a) - JULIANDAY(b)) AS INTEGER)");
  });
  it("sqlite -> sqlite: DATEDIFF(a, b, 'hour')", () => {
    const result = transpile("DATEDIFF(a, b, 'hour')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("CAST((JULIANDAY(a) - JULIANDAY(b)) * 24.0 AS INTEGER)");
  });
  it("sqlite -> sqlite: DATEDIFF(a, b, 'year')", () => {
    const result = transpile("DATEDIFF(a, b, 'year')", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("CAST((JULIANDAY(a) - JULIANDAY(b)) / 365.0 AS INTEGER)");
  });
});

describe("Sqlite: hexadecimal_literal", () => {
  it.todo("sqlite -> sqlite: SELECT 0XCC (unsupported syntax)");
  it.todo("sqlite -> mysql: SELECT 0XCC (unsupported syntax)");
});

describe("Sqlite: window_null_treatment", () => {
  it("sqlite -> sqlite: SELECT FIRST_VALUE(Name) OVER (PARTITION BY AlbumId ORDER BY Bytes DE...", () => {
    const result = transpile("SELECT FIRST_VALUE(Name) OVER (PARTITION BY AlbumId ORDER BY Bytes DESC) AS LargestTrack FROM tracks", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT FIRST_VALUE(Name) OVER (PARTITION BY AlbumId ORDER BY Bytes DESC) AS LargestTrack FROM tracks");
  });
});

describe("Sqlite: longvarchar_dtype", () => {
  it.todo("CREATE TABLE foo (bar LONGVARCHAR) (DDL/DML not supported)");
});

describe("Sqlite: warnings", () => {
  it("SELECT * FROM t AS t(c1, c2) -> SELECT * FROM t AS t", () => {
    validateIdentity("SELECT * FROM t AS t(c1, c2)", "SELECT * FROM t AS t");
  });
  it.todo("test_warnings: assertIn call");
});

describe("Sqlite: trunc", () => {
  it.todo("TRUNC(3.14) (assert_is check)");
  it.todo("TRUNC(3.14, 2) (assert_is check)");
  it.todo("test_trunc: assertIn call");
});

describe("Sqlite: ddl", () => {
  it.todo("CREATE TABLE a (b, c, UNIQUE (b, c) ON CONFLICT IGNORE) (DDL/DML not supported)");
  it.todo("CREATE TABLE a (b, c, UNIQUE (b, c) ON CONFLICT IGNORE) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE a (b, c, UNIQUE (b, c) ON CONFLICT IGNORE) (DDL/DML not supported) (3)");
  it.todo("CREATE TABLE a (b, c, UNIQUE (b, c) ON CONFLICT IGNORE) (DDL/DML not supported) (4)");
  it.todo("CREATE TABLE a (b, c, UNIQUE (b, c) ON CONFLICT IGNORE) (DDL/DML not supported) (5)");
  it.todo("CREATE TABLE over (x, y) (DDL/DML not supported)");
  it.todo("INSERT OR ABORT INTO foo (x, y) VALUES (1, 2) (DDL/DML not supported)");
  it.todo("INSERT OR FAIL INTO foo (x, y) VALUES (1, 2) (DDL/DML not supported)");
  it.todo("INSERT OR IGNORE INTO foo (x, y) VALUES (1, 2) (DDL/DML not supported)");
  it.todo("INSERT OR REPLACE INTO foo (x, y) VALUES (1, 2) (DDL/DML not supported)");
  it.todo("INSERT OR ROLLBACK INTO foo (x, y) VALUES (1, 2) (DDL/DML not supported)");
  it.todo("CREATE TABLE foo (id INTEGER PRIMARY KEY ASC) (DDL/DML not supported)");
  it.todo("CREATE TEMPORARY TABLE foo (id INTEGER) (DDL/DML not supported)");
  it.todo('\n            CREATE TABLE "Track"\n            (\n                CON... (pretty=True not supported)');
  it.todo("CREATE TABLE z (a INTEGER UNIQUE PRIMARY KEY AUTOINCREMENT) (DDL/DML not supported)");
  it.todo('CREATE TABLE "x" ("Name" NVARCHAR(200) NOT NULL) (DDL/DML not supported)');
  it.todo("CREATE TABLE store (store_id INTEGER PRIMARY KEY AUTOINCREMENT, mgr... (DDL/DML not supported)");
});

describe("Sqlite: analyze", () => {
  it.todo("ANALYZE tbl (command not supported)");
  it.todo("ANALYZE schma.tbl (command not supported)");
});
