// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "teradata";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Teradata: teradata", () => {
  it.todo("teradata -> : RANDOM(l, u) (cross-dialect transform)");
  it("teradata -> teradata: RANDOM(l, u)", () => {
    const result = transpile("RANDOM(l, u)", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("RANDOM(l, u)");
  });
  it("TO_NUMBER(expr, fmt, nlsparam)", () => {
    validateIdentity("TO_NUMBER(expr, fmt, nlsparam)");
  });
  it("SELECT TOP 10 * FROM tbl", () => {
    validateIdentity("SELECT TOP 10 * FROM tbl");
  });
  it.todo("SELECT * FROM tbl SAMPLE 5 (unsupported clause)");
  it.todo("SELECT * FROM tbl SAMPLE 0.33, .25, .1 (unsupported clause)");
  it.todo("databricks -> teradata: USE tduser (command not supported)");
  it.todo("teradata -> databricks: DATABASE tduser (command not supported)");
  it("teradata -> teradata: DATABASE tduser", () => {
    const result = transpile("DATABASE tduser", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("DATABASE tduser");
  });
  it("SELECT 0x1d -> SELECT X'1d'", () => {
    validateIdentity("SELECT 0x1d", "SELECT X'1d'");
  });
  it.todo("SELECT X'1D' (unsupported syntax)");
  it.todo("SELECT x'1d' (unsupported syntax)");
  it.todo("RENAME TABLE emp TO employee (assert_is check)");
});

describe("Teradata: translate", () => {
  it.todo("TRANSLATE(x USING LATIN_TO_UNICODE) (unsupported syntax)");
  it("TRANSLATE(x USING LATIN_TO_UNICODE WITH ERROR)", () => {
    validateIdentity("TRANSLATE(x USING LATIN_TO_UNICODE WITH ERROR)");
  });
});

describe("Teradata: locking", () => {
  it("LOCKING ROW FOR ACCESS SELECT * FROM table1", () => {
    validateIdentity("LOCKING ROW FOR ACCESS SELECT * FROM table1");
  });
  it("LOCKING TABLE table1 FOR ACCESS SELECT col1, col2 FROM table1", () => {
    validateIdentity("LOCKING TABLE table1 FOR ACCESS SELECT col1, col2 FROM table1");
  });
  it.todo("LOCKING ROW FOR SHARE SELECT * FROM table1 (unsupported clause)");
  it("LOCKING DATABASE db1 FOR READ SELECT * FROM table1", () => {
    validateIdentity("LOCKING DATABASE db1 FOR READ SELECT * FROM table1");
  });
  it("LOCKING ROW FOR EXCLUSIVE SELECT * FROM table1", () => {
    validateIdentity("LOCKING ROW FOR EXCLUSIVE SELECT * FROM table1");
  });
  it("LOCKING VIEW view1 FOR ACCESS SELECT * FROM view1", () => {
    validateIdentity("LOCKING VIEW view1 FOR ACCESS SELECT * FROM view1");
  });
  it("LOCKING ROW FOR ACCESS SELECT col1, col2 FROM table1 WHERE col1 > 10", () => {
    validateIdentity("LOCKING ROW FOR ACCESS SELECT col1, col2 FROM table1 WHERE col1 > 10");
  });
  it("LOCKING TABLE table1 FOR ACCESS SELECT * FROM table1 JOIN table2 ON table1.id = table2.id", () => {
    validateIdentity("LOCKING TABLE table1 FOR ACCESS SELECT * FROM table1 JOIN table2 ON table1.id = table2.id");
  });
  it.todo("CREATE VIEW view_b AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM... (DDL/DML not supported)");
});

describe("Teradata: update", () => {
  it.todo("UPDATE A FROM schema.tableA AS A, (SELECT col1 FROM schema.tableA G... (DDL/DML not supported)");
});

describe("Teradata: statistics", () => {
  it.todo("COLLECT STATISTICS ON tbl INDEX(col) (check_command_warning)");
  it.todo("COLLECT STATS ON tbl COLUMNS(col) (check_command_warning)");
  it.todo("COLLECT STATS COLUMNS(col) ON tbl (check_command_warning)");
  it.todo("HELP STATISTICS personel.employee (check_command_warning)");
  it.todo("HELP STATISTICS personnel.employee FROM my_qcd (check_command_warning)");
});

describe("Teradata: create", () => {
  it("REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table...", () => {
    validateIdentity("REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b", "CREATE OR REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b");
  });
  it("REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table... (2)", () => {
    validateIdentity("REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b", "CREATE OR REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b");
  });
  it.todo("CREATE TABLE x (y INT) PRIMARY INDEX (y) PARTITION BY y INDEX (y) (DDL/DML not supported)");
  it.todo("CREATE TABLE x (y INT) PARTITION BY y INDEX (y) (DDL/DML not supported)");
  it.todo("CREATE MULTISET VOLATILE TABLE my_table (id INT) PRIMARY INDEX (id)... (DDL/DML not supported)");
  it.todo("CREATE SET VOLATILE TABLE my_table (id INT) PRIMARY INDEX (id) ON C... (DDL/DML not supported)");
  it.todo("CREATE TABLE a (b INT) PRIMARY INDEX (y) PARTITION BY RANGE_N(b BET... (DDL/DML not supported)");
  it.todo("CREATE TABLE a (b INT) PARTITION BY RANGE_N(b BETWEEN 0, 1 AND 2 EA... (DDL/DML not supported)");
  it.todo("CREATE TABLE a (b INT) PARTITION BY RANGE_N(b BETWEEN *, 1 AND * EA... (DDL/DML not supported)");
  it.todo("CREATE TABLE a, NO FALLBACK PROTECTION, NO LOG, NO JOURNAL, CHECKSU... (DDL/DML not supported)");
  it.todo("CREATE TABLE a, NO FALLBACK PROTECTION, NO LOG, NO JOURNAL, CHECKSU... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE a, WITH JOURNAL TABLE=x.y.z, CHECKSUM=OFF, MERGEBLOCKR... (DDL/DML not supported)");
  it.todo("CREATE TABLE a, BEFORE JOURNAL, AFTER JOURNAL, FREESPACE=1, DEFAULT... (DDL/DML not supported)");
  it.todo("CREATE TABLE a, DUAL JOURNAL, DUAL AFTER JOURNAL, MERGEBLOCKRATIO=1... (DDL/DML not supported)");
  it.todo("CREATE TABLE a, DUAL BEFORE JOURNAL, LOCAL AFTER JOURNAL, MAXIMUM D... (DDL/DML not supported)");
  it.todo("CREATE VOLATILE MULTISET TABLE a, NOT LOCAL AFTER JOURNAL, FREESPAC... (DDL/DML not supported)");
  it.todo("CREATE VOLATILE SET TABLE example1 AS (SELECT col1, col2, col3 FROM... (DDL/DML not supported)");
  it.todo("CREATE SET GLOBAL TEMPORARY TABLE a, NO BEFORE JOURNAL, NO AFTER JO... (DDL/DML not supported)");
  it.todo("\n            CREATE SET TABLE test, NO FALLBACK, NO BEFORE JOURNAL,... (DDL/DML not supported)");
  it.todo("REPLACE VIEW a AS (SELECT b FROM c) (DDL/DML in read/write)");
  it.todo("CREATE VOLATILE TABLE a (DDL/DML not supported)");
  it.todo("CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-... (DDL/DML not supported) (3)");
});

describe("Teradata: insert", () => {
  it.todo("INS INTO x SELECT * FROM y (DDL/DML in read/write)");
});

describe("Teradata: mod", () => {
  it("teradata -> teradata: a MOD b", () => {
    const result = transpile("a MOD b", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("a MOD b");
  });
  it("teradata -> mysql: a MOD b", () => {
    const result = transpile("a MOD b", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("a % b");
  });
});

describe("Teradata: power", () => {
  it("teradata -> teradata: a ** b", () => {
    const result = transpile("a ** b", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("a ** b");
  });
  it("teradata -> mysql: a ** b", () => {
    const result = transpile("a ** b", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("POWER(a, b)");
  });
});

describe("Teradata: abbrev", () => {
  it("a LT b -> a < b", () => {
    validateIdentity("a LT b", "a < b");
  });
  it("a LE b -> a <= b", () => {
    validateIdentity("a LE b", "a <= b");
  });
  it("a GT b -> a > b", () => {
    validateIdentity("a GT b", "a > b");
  });
  it("a GE b -> a >= b", () => {
    validateIdentity("a GE b", "a >= b");
  });
  it("a ^= b -> a <> b", () => {
    validateIdentity("a ^= b", "a <> b");
  });
  it("a NE b -> a <> b", () => {
    validateIdentity("a NE b", "a <> b");
  });
  it("a NOT= b -> a <> b", () => {
    validateIdentity("a NOT= b", "a <> b");
  });
  it("a EQ b -> a = b", () => {
    validateIdentity("a EQ b", "a = b");
  });
  it("SEL a FROM b -> SELECT a FROM b", () => {
    validateIdentity("SEL a FROM b", "SELECT a FROM b");
  });
  it("SELECT col1, col2 FROM dbc.table1 WHERE col1 EQ 'value1' MINUS SELECT col1, col2 FROM d...", () => {
    validateIdentity("SELECT col1, col2 FROM dbc.table1 WHERE col1 EQ 'value1' MINUS SELECT col1, col2 FROM dbc.table2", "SELECT col1, col2 FROM dbc.table1 WHERE col1 = 'value1' EXCEPT SELECT col1, col2 FROM dbc.table2");
  });
  it("UPD a SET b = 1 -> UPDATE a SET b = 1", () => {
    validateIdentity("UPD a SET b = 1", "UPDATE a SET b = 1");
  });
  it("DEL FROM a -> DELETE FROM a", () => {
    validateIdentity("DEL FROM a", "DELETE FROM a");
  });
});

describe("Teradata: datatype", () => {
  it.todo("CREATE TABLE z (a ST_GEOMETRY(1)) (DDL/DML not supported)");
  it.todo("CREATE TABLE z (a SYSUDTLIB.INT) (DDL/DML not supported)");
});

describe("Teradata: cast", () => {
  it("bigquery -> teradata: CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", () => {
    const result = transpile("CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST('1992-01' AS DATE FORMAT 'YYYY-DD')");
  });
  it("teradata -> teradata: CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", () => {
    const result = transpile("CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("CAST('1992-01' AS DATE FORMAT 'YYYY-DD')");
  });
  it("teradata -> bigquery: CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", () => {
    const result = transpile("CAST('1992-01' AS DATE FORMAT 'YYYY-DD')", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("PARSE_DATE('%Y-%d', '1992-01')");
  });
  it.todo("teradata -> databricks: CAST('1992-01' AS DATE FORMAT 'YYYY-DD') (cross-dialect transform)");
  it.todo("teradata -> mysql: CAST('1992-01' AS DATE FORMAT 'YYYY-DD') (cross-dialect transform)");
  it.todo("teradata -> spark: CAST('1992-01' AS DATE FORMAT 'YYYY-DD') (cross-dialect transform)");
  it.todo("teradata -> : CAST('1992-01' AS DATE FORMAT 'YYYY-DD') (cross-dialect transform)");
  it("CAST('1992-01' AS FORMAT 'YYYY-DD')", () => {
    validateIdentity("CAST('1992-01' AS FORMAT 'YYYY-DD')");
  });
  it("snowflake -> teradata: TRY_CAST('-2.5' AS DECIMAL(5, 2))", () => {
    const result = transpile("TRY_CAST('-2.5' AS DECIMAL(5, 2))", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("TRYCAST('-2.5' AS DECIMAL(5, 2))");
  });
  it("teradata -> snowflake: TRYCAST('-2.5' AS DECIMAL(5, 2))", () => {
    const result = transpile("TRYCAST('-2.5' AS DECIMAL(5, 2))", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("TRY_CAST('-2.5' AS DECIMAL(5, 2))");
  });
  it("teradata -> teradata: TRYCAST('-2.5' AS DECIMAL(5, 2))", () => {
    const result = transpile("TRYCAST('-2.5' AS DECIMAL(5, 2))", { readDialect: DIALECT, writeDialect: "teradata" })[0];
    expect(result).toBe("TRYCAST('-2.5' AS DECIMAL(5, 2))");
  });
});

describe("Teradata: format_override", () => {
  it.todo("SELECT ('a' || 'b') (FORMAT '...') (unsupported syntax)");
  it("SELECT Col1 (FORMAT '+9999') FROM Test1", () => {
    validateIdentity("SELECT Col1 (FORMAT '+9999') FROM Test1");
  });
  it("SELECT date_col (FORMAT 'YYYY-MM-DD') FROM t", () => {
    validateIdentity("SELECT date_col (FORMAT 'YYYY-MM-DD') FROM t");
  });
  it("SELECT CAST(Col1 AS INTEGER) FROM Test1 -> SELECT CAST(Col1 AS INT) FROM Test1", () => {
    validateIdentity("SELECT CAST(Col1 AS INTEGER) FROM Test1", "SELECT CAST(Col1 AS INT) FROM Test1");
  });
});

describe("Teradata: time", () => {
  it.todo("CAST(CURRENT_TIMESTAMP(6) AS TIMESTAMP WITH TIME ZONE) (unsupported syntax)");
  it("teradata -> teradata: CURRENT_TIMESTAMP", () => {
    const result = transpile("CURRENT_TIMESTAMP", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it("snowflake -> teradata: CURRENT_TIMESTAMP()", () => {
    const result = transpile("CURRENT_TIMESTAMP()", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CURRENT_TIMESTAMP");
  });
  it.todo("SELECT '2023-01-01' + INTERVAL '5' YEAR (unsupported syntax)");
  it.todo("SELECT '2023-01-01' - INTERVAL '5' YEAR (unsupported syntax)");
  it.todo("SELECT '2023-01-01' - INTERVAL '5' YEAR (unsupported syntax) (2)");
  it.todo("SELECT '2023-01-01' + INTERVAL '5' YEAR (unsupported syntax) (2)");
  it.todo("SELECT (90 * INTERVAL '1' DAY) (unsupported syntax)");
  it.todo("SELECT (7 * INTERVAL '1' DAY) (unsupported syntax)");
  it.todo("SELECT '2023-01-01' + (90 * INTERVAL '5' DAY) (unsupported syntax)");
  it.todo("SELECT '2023-01-01' + (7 * INTERVAL '5' DAY) (unsupported syntax)");
  it("teradata -> teradata: CAST(TO_CHAR(x, 'Q') AS INT)", () => {
    const result = transpile("CAST(TO_CHAR(x, 'Q') AS INT)", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TO_CHAR(x, 'Q') AS INT)");
  });
  it("snowflake -> teradata: DATE_PART(QUARTER, x)", () => {
    const result = transpile("DATE_PART(QUARTER, x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TO_CHAR(x, 'Q') AS INT)");
  });
  it.todo("bigquery -> teradata: EXTRACT(QUARTER FROM x) (unsupported syntax)");
  it("teradata -> teradata: EXTRACT(MONTH FROM x)", () => {
    const result = transpile("EXTRACT(MONTH FROM x)", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("EXTRACT(MONTH FROM x)");
  });
  it("snowflake -> teradata: DATE_PART(MONTH, x)", () => {
    const result = transpile("DATE_PART(MONTH, x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("EXTRACT(MONTH FROM x)");
  });
  it("bigquery -> teradata: EXTRACT(MONTH FROM x)", () => {
    const result = transpile("EXTRACT(MONTH FROM x)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("EXTRACT(MONTH FROM x)");
  });
  it("snowflake -> teradata: quarter(x)", () => {
    const result = transpile("quarter(x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TO_CHAR(x, 'Q') AS INT)");
  });
  it("teradata -> teradata: CAST(TO_CHAR(x, 'Q') AS INT) (2)", () => {
    const result = transpile("CAST(TO_CHAR(x, 'Q') AS INT)", { readDialect: "teradata", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(TO_CHAR(x, 'Q') AS INT)");
  });
});

describe("Teradata: query_band", () => {
  it.todo("SET QUERY_BAND = 'app=myapp;' FOR SESSION (command not supported)");
  it.todo("SET QUERY_BAND = 'app=myapp;user=john;' FOR TRANSACTION (command not supported)");
  it.todo("SET QUERY_BAND = 'priority=high;' UPDATE FOR SESSION (command not supported)");
  it.todo("SET QUERY_BAND = 'workload=batch;' UPDATE FOR TRANSACTION (command not supported)");
  it.todo("SET QUERY_BAND = 'org=Finance;report=Fin123;' FOR SESSION (command not supported)");
  it.todo("SET QUERY_BAND = NONE FOR SESSION (command not supported)");
  it.todo("SET QUERY_BAND = NONE FOR SESSION VOLATILE (command not supported)");
  it.todo("SET QUERY_BAND = 'priority=high;' UPDATE FOR SESSION VOLATILE (command not supported)");
  it.todo("SET QUERY_BAND = 'NONE' FOR SESSION (command not supported)");
  it.todo("SET QUERY_BAND = '' FOR SESSION (command not supported)");
});
