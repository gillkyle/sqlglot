// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "hive";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Hive: bits", () => {
  it("duckdb -> hive: x & 1", () => {
    const result = transpile("x & 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1");
  });
  it("presto -> hive: BITWISE_AND(x, 1)", () => {
    const result = transpile("BITWISE_AND(x, 1)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1");
  });
  it("spark -> hive: x & 1", () => {
    const result = transpile("x & 1", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1");
  });
  it("hive -> duckdb: x & 1", () => {
    const result = transpile("x & 1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x & 1");
  });
  it("hive -> hive: x & 1", () => {
    const result = transpile("x & 1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x & 1");
  });
  it("hive -> presto: x & 1", () => {
    const result = transpile("x & 1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("BITWISE_AND(x, 1)");
  });
  it("hive -> spark: x & 1", () => {
    const result = transpile("x & 1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x & 1");
  });
  it("duckdb -> hive: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it("presto -> hive: BITWISE_AND(x, 1) > 0", () => {
    const result = transpile("BITWISE_AND(x, 1) > 0", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it("spark -> hive: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it("hive -> duckdb: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it("hive -> presto: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("BITWISE_AND(x, 1) > 0");
  });
  it("hive -> hive: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it("hive -> spark: x & 1 > 0", () => {
    const result = transpile("x & 1 > 0", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x & 1 > 0");
  });
  it.todo("~x (unsupported syntax)");
  it("duckdb -> hive: x | 1", () => {
    const result = transpile("x | 1", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("x | 1");
  });
  it("presto -> hive: BITWISE_OR(x, 1)", () => {
    const result = transpile("BITWISE_OR(x, 1)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("x | 1");
  });
  it("spark -> hive: x | 1", () => {
    const result = transpile("x | 1", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x | 1");
  });
  it("hive -> duckdb: x | 1", () => {
    const result = transpile("x | 1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x | 1");
  });
  it("hive -> hive: x | 1", () => {
    const result = transpile("x | 1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x | 1");
  });
  it("hive -> presto: x | 1", () => {
    const result = transpile("x | 1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("BITWISE_OR(x, 1)");
  });
  it("hive -> spark: x | 1", () => {
    const result = transpile("x | 1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x | 1");
  });
  it("spark -> hive: SHIFTLEFT(x, 1)", () => {
    const result = transpile("SHIFTLEFT(x, 1)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x << 1");
  });
  it("hive -> duckdb: x << 1", () => {
    const result = transpile("x << 1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x << 1");
  });
  it("hive -> presto: x << 1", () => {
    const result = transpile("x << 1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("BITWISE_ARITHMETIC_SHIFT_LEFT(x, 1)");
  });
  it("hive -> hive: x << 1", () => {
    const result = transpile("x << 1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x << 1");
  });
  it("hive -> spark: x << 1", () => {
    const result = transpile("x << 1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SHIFTLEFT(x, 1)");
  });
  it("spark -> hive: SHIFTRIGHT(x, 1)", () => {
    const result = transpile("SHIFTRIGHT(x, 1)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x >> 1");
  });
  it("hive -> duckdb: x >> 1", () => {
    const result = transpile("x >> 1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x >> 1");
  });
  it("hive -> presto: x >> 1", () => {
    const result = transpile("x >> 1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("BITWISE_ARITHMETIC_SHIFT_RIGHT(x, 1)");
  });
  it("hive -> hive: x >> 1", () => {
    const result = transpile("x >> 1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x >> 1");
  });
  it("hive -> spark: x >> 1", () => {
    const result = transpile("x >> 1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SHIFTRIGHT(x, 1)");
  });
});

describe("Hive: cast", () => {
  it("hive -> duckdb: 1s", () => {
    const result = transpile("1s", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1 AS SMALLINT)");
  });
  it("hive -> presto: 1s", () => {
    const result = transpile("1s", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1 AS SMALLINT)");
  });
  it("hive -> hive: 1s", () => {
    const result = transpile("1s", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1 AS SMALLINT)");
  });
  it("hive -> spark: 1s", () => {
    const result = transpile("1s", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1 AS SMALLINT)");
  });
  it("hive -> duckdb: 1S", () => {
    const result = transpile("1S", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1 AS SMALLINT)");
  });
  it("hive -> presto: 1S", () => {
    const result = transpile("1S", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1 AS SMALLINT)");
  });
  it("hive -> hive: 1S", () => {
    const result = transpile("1S", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1 AS SMALLINT)");
  });
  it("hive -> spark: 1S", () => {
    const result = transpile("1S", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1 AS SMALLINT)");
  });
  it("hive -> duckdb: 1Y", () => {
    const result = transpile("1Y", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1 AS TINYINT)");
  });
  it("hive -> presto: 1Y", () => {
    const result = transpile("1Y", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1 AS TINYINT)");
  });
  it("hive -> hive: 1Y", () => {
    const result = transpile("1Y", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1 AS TINYINT)");
  });
  it("hive -> spark: 1Y", () => {
    const result = transpile("1Y", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1 AS TINYINT)");
  });
  it("hive -> duckdb: 1L", () => {
    const result = transpile("1L", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1 AS BIGINT)");
  });
  it("hive -> presto: 1L", () => {
    const result = transpile("1L", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1 AS BIGINT)");
  });
  it("hive -> hive: 1L", () => {
    const result = transpile("1L", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1 AS BIGINT)");
  });
  it("hive -> spark: 1L", () => {
    const result = transpile("1L", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1 AS BIGINT)");
  });
  it("hive -> duckdb: 1.0bd", () => {
    const result = transpile("1.0bd", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1.0 AS DECIMAL)");
  });
  it("hive -> presto: 1.0bd", () => {
    const result = transpile("1.0bd", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1.0 AS DECIMAL)");
  });
  it("hive -> hive: 1.0bd", () => {
    const result = transpile("1.0bd", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1.0 AS DECIMAL)");
  });
  it("hive -> spark: 1.0bd", () => {
    const result = transpile("1.0bd", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1.0 AS DECIMAL)");
  });
  it("presto -> hive: TRY_CAST(1 AS INT)", () => {
    const result = transpile("TRY_CAST(1 AS INT)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(1 AS INT)");
  });
  it("hive -> duckdb: CAST(1 AS INT)", () => {
    const result = transpile("CAST(1 AS INT)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("TRY_CAST(1 AS INT)");
  });
  it("hive -> presto: CAST(1 AS INT)", () => {
    const result = transpile("CAST(1 AS INT)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("TRY_CAST(1 AS INTEGER)");
  });
  it("hive -> hive: CAST(1 AS INT)", () => {
    const result = transpile("CAST(1 AS INT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(1 AS INT)");
  });
  it("hive -> spark: CAST(1 AS INT)", () => {
    const result = transpile("CAST(1 AS INT)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("CAST(1 AS INT)");
  });
});

describe("Hive: ddl", () => {
  it.todo("CREATE TABLE x (w STRING) PARTITIONED BY (y INT, z INT) (DDL/DML not supported)");
  it.todo("CREATE TABLE test STORED AS parquet TBLPROPERTIES ('x'='1', 'Z'='2'... (DDL/DML not supported)");
  it.todo("CREATE TABLE test STORED AS INPUTFORMAT 'foo1' OUTPUTFORMAT 'foo2' (DDL/DML not supported)");
  it.todo("ALTER TABLE x PARTITION(y = z) ADD COLUMN a VARCHAR(10) (DDL/DML not supported)");
  it.todo("ALTER TABLE x CHANGE a a VARCHAR(10) (DDL/DML not supported)");
  it.todo("ALTER TABLE x CHANGE COLUMN a a VARCHAR(10) (DDL/DML not supported)");
  it.todo("ALTER TABLE x CHANGE COLUMN a a VARCHAR(10) COMMENT 'comment' (DDL/DML not supported)");
  it.todo("ALTER TABLE x CHANGE COLUMN a b VARCHAR(10) (DDL/DML not supported)");
  it.todo("ALTER TABLE x CHANGE COLUMN a a VARCHAR(10) CASCADE (DDL/DML not supported)");
  it.todo("ALTER TABLE X ADD COLUMNS (y INT, z STRING) (DDL/DML not supported)");
  it.todo("ALTER TABLE X ADD COLUMNS (y INT, z STRING) CASCADE (DDL/DML not supported)");
  it.todo("CREATE EXTERNAL TABLE x (y INT) ROW FORMAT SERDE 'serde' ROW FORMAT... (DDL/DML not supported)");
  it.todo("CREATE EXTERNAL TABLE `my_table` (`a7` ARRAY<DATE>) ROW FORMAT SERD... (DDL/DML not supported)");
  it.todo("CREATE EXTERNAL TABLE X (y INT) STORED BY 'x' (DDL/DML not supported)");
  it.todo("ALTER VIEW v1 AS SELECT x, UPPER(s) AS s FROM t2 (DDL/DML not supported)");
  it.todo("ALTER VIEW v1 (c1, c2) AS SELECT x, UPPER(s) AS s FROM t2 (DDL/DML not supported)");
  it.todo("ALTER VIEW v7 (c1 COMMENT 'Comment for c1', c2) AS SELECT t1.c1, t1... (DDL/DML not supported)");
  it.todo("ALTER VIEW db1.v1 RENAME TO db2.v2 (DDL/DML not supported)");
  it.todo("ALTER VIEW v1 SET TBLPROPERTIES ('tblp1'='1', 'tblp2'='2') (DDL/DML not supported)");
  it.todo("ALTER VIEW v1 UNSET TBLPROPERTIES ('tblp1', 'tblp2') (check_command_warning)");
  it.todo("CREATE TABLE foo (col STRUCT<struct_col_a: VARCHAR((50))>) (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (col_a struct<struct_col_a:int, struc... (DDL/DML not supported)");
  it.todo("CREATE TABLE db.example_table (col_a struct<struct_col_a:int, struc... (DDL/DML not supported) (2)");
  it.todo("ALTER TABLE db.example_table ADD PARTITION(col_a = 'a') LOCATION 'b' (DDL/DML not supported)");
});

describe("Hive: lateral_view", () => {
  it.todo("SELECT a, b FROM x LATERAL VIEW EXPLODE(y) t AS a LATERAL VIEW EXPL... (unsupported clause)");
  it.todo("SELECT a FROM x LATERAL VIEW EXPLODE(y) t AS a (unsupported clause)");
  it.todo("SELECT a FROM x LATERAL VIEW POSEXPLODE(y) t AS pos, col (unsupported clause)");
  it.todo("SELECT * FROM x LATERAL VIEW POSEXPLODE(MAP(col, 'val')) t AS pos, ... (unsupported clause)");
  it.todo("SELECT a FROM x LATERAL VIEW EXPLODE(ARRAY(y)) t AS a (unsupported clause)");
});

describe("Hive: quotes", () => {
  it.todo("hive -> duckdb: '\\'' (unsupported syntax)");
  it.todo("hive -> presto: '\\'' (unsupported syntax)");
  it("hive -> hive: '\\''", () => {
    const result = transpile("'\\''", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'\\''");
  });
  it("hive -> spark: '\\''", () => {
    const result = transpile("'\\''", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'\\''");
  });
  it(`hive -> duckdb: '"x"'`, () => {
    const result = transpile(`'"x"'`, { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe(`'"x"'`);
  });
  it(`hive -> presto: '"x"'`, () => {
    const result = transpile(`'"x"'`, { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe(`'"x"'`);
  });
  it(`hive -> hive: '"x"'`, () => {
    const result = transpile(`'"x"'`, { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe(`'"x"'`);
  });
  it(`hive -> spark: '"x"'`, () => {
    const result = transpile(`'"x"'`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe(`'"x"'`);
  });
  it.todo(`hive -> duckdb: "'x'" (unsupported syntax)`);
  it.todo(`hive -> presto: "'x'" (unsupported syntax)`);
  it(`hive -> hive: "'x'"`, () => {
    const result = transpile(`"'x'"`, { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'\\'x\\''");
  });
  it(`hive -> spark: "'x'"`, () => {
    const result = transpile(`"'x'"`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'\\'x\\''");
  });
  it("drill -> hive: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: "drill", writeDialect: DIALECT })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
  it("duckdb -> hive: '\\\\a'", () => {
    const result = transpile("'\\\\a'", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
  it("presto -> hive: '\\\\a'", () => {
    const result = transpile("'\\\\a'", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
  it("hive -> drill: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: DIALECT, writeDialect: "drill" })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
  it("hive -> duckdb: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("'\\\\a'");
  });
  it("hive -> hive: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
  it("hive -> presto: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("'\\\\a'");
  });
  it("hive -> spark: '\\\\\\\\a'", () => {
    const result = transpile("'\\\\\\\\a'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("'\\\\\\\\a'");
  });
});

describe("Hive: regex", () => {
  it("hive -> duckdb: a RLIKE 'x'", () => {
    const result = transpile("a RLIKE 'x'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_MATCHES(a, 'x')");
  });
  it("hive -> presto: a RLIKE 'x'", () => {
    const result = transpile("a RLIKE 'x'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_LIKE(a, 'x')");
  });
  it("hive -> hive: a RLIKE 'x'", () => {
    const result = transpile("a RLIKE 'x'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
  it("hive -> spark: a RLIKE 'x'", () => {
    const result = transpile("a RLIKE 'x'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
  it("hive -> duckdb: a REGEXP 'x'", () => {
    const result = transpile("a REGEXP 'x'", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_MATCHES(a, 'x')");
  });
  it("hive -> presto: a REGEXP 'x'", () => {
    const result = transpile("a REGEXP 'x'", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_LIKE(a, 'x')");
  });
  it("hive -> hive: a REGEXP 'x'", () => {
    const result = transpile("a REGEXP 'x'", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
  it("hive -> spark: a REGEXP 'x'", () => {
    const result = transpile("a REGEXP 'x'", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("a RLIKE 'x'");
  });
});

describe("Hive: time", () => {
  it.todo("presto -> hive: DATE_DIFF('millisecond', x, y) (cross-dialect transform)");
  it.todo("presto -> hive: DATE_DIFF('second', x, y) (cross-dialect transform)");
  it.todo("presto -> hive: DATE_DIFF('minute', x, y) (cross-dialect transform)");
  it.todo("presto -> hive: DATE_DIFF('hour', x, y) (cross-dialect transform)");
  it.todo("hive -> duckdb: DATEDIFF(a, b) (cross-dialect transform)");
  it.todo("hive -> presto: DATEDIFF(a, b) (unsupported syntax)");
  it("hive -> hive: DATEDIFF(a, b)", () => {
    const result = transpile("DATEDIFF(a, b)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DATEDIFF(a, b)");
  });
  it.todo("hive -> spark: DATEDIFF(a, b) (cross-dialect transform)");
  it.todo("hive -> : DATEDIFF(a, b) (cross-dialect transform)");
  it.todo(`hive -> duckdb: from_unixtime(x, "yyyy-MM-dd'T'HH") (unsupported syntax)`);
  it.todo(`hive -> presto: from_unixtime(x, "yyyy-MM-dd'T'HH") (unsupported syntax)`);
  it(`hive -> hive: from_unixtime(x, "yyyy-MM-dd'T'HH")`, () => {
    const result = transpile(`from_unixtime(x, "yyyy-MM-dd'T'HH")`, { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("FROM_UNIXTIME(x, 'yyyy-MM-dd\\'T\\'HH')");
  });
  it.todo(`hive -> spark: from_unixtime(x, "yyyy-MM-dd'T'HH") (cross-dialect transform)`);
  it.todo("DATE_FORMAT('2020-01-01', 'yyyy-MM-dd HH:mm:ss') (unsupported syntax)");
  it("hive -> : DATE_ADD('2020-01-01', 1)", () => {
    const result = transpile("DATE_ADD('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("TS_OR_DS_ADD('2020-01-01', 1, DAY)");
  });
  it.todo("hive -> bigquery: DATE_ADD('2020-01-01', 1) (unsupported syntax)");
  it("hive -> duckdb: DATE_ADD('2020-01-01', 1)", () => {
    const result = transpile("DATE_ADD('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST('2020-01-01' AS DATE) + INTERVAL 1 DAY");
  });
  it("hive -> hive: DATE_ADD('2020-01-01', 1)", () => {
    const result = transpile("DATE_ADD('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DATE_ADD('2020-01-01', 1)");
  });
  it.todo("hive -> presto: DATE_ADD('2020-01-01', 1) (unsupported syntax)");
  it.todo("hive -> redshift: DATE_ADD('2020-01-01', 1) (cross-dialect transform)");
  it.todo("hive -> snowflake: DATE_ADD('2020-01-01', 1) (unsupported syntax)");
  it("hive -> spark: DATE_ADD('2020-01-01', 1)", () => {
    const result = transpile("DATE_ADD('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DATE_ADD('2020-01-01', 1)");
  });
  it.todo("hive -> tsql: DATE_ADD('2020-01-01', 1) (cross-dialect transform)");
  it("hive -> : DATE_SUB('2020-01-01', 1)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("TS_OR_DS_ADD('2020-01-01', 1 * -1, DAY)");
  });
  it.todo("hive -> bigquery: DATE_SUB('2020-01-01', 1) (unsupported syntax)");
  it("hive -> duckdb: DATE_SUB('2020-01-01', 1)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CAST('2020-01-01' AS DATE) + INTERVAL (1 * -1) DAY");
  });
  it("hive -> hive: DATE_SUB('2020-01-01', 1)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DATE_ADD('2020-01-01', 1 * -1)");
  });
  it.todo("hive -> presto: DATE_SUB('2020-01-01', 1) (unsupported syntax)");
  it.todo("hive -> redshift: DATE_SUB('2020-01-01', 1) (cross-dialect transform)");
  it.todo("hive -> snowflake: DATE_SUB('2020-01-01', 1) (unsupported syntax)");
  it("hive -> spark: DATE_SUB('2020-01-01', 1)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("DATE_ADD('2020-01-01', 1 * -1)");
  });
  it.todo("hive -> tsql: DATE_SUB('2020-01-01', 1) (cross-dialect transform)");
  it(" -> hive: DATE_SUB('2020-01-01', 1)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 1)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_ADD('2020-01-01', -1)");
  });
  it(" -> hive: DATE_SUB(a, b)", () => {
    const result = transpile("DATE_SUB(a, b)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_ADD(a, b * -1)");
  });
  it(" -> hive: DATE_SUB('2020-01-01', 2, month)", () => {
    const result = transpile("DATE_SUB('2020-01-01', 2, month)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("ADD_MONTHS('2020-01-01', -2)");
  });
  it.todo("hive -> duckdb: DATEDIFF(TO_DATE(y), x) (cross-dialect transform)");
  it.todo("hive -> presto: DATEDIFF(TO_DATE(y), x) (unsupported syntax)");
  it("hive -> hive: DATEDIFF(TO_DATE(y), x)", () => {
    const result = transpile("DATEDIFF(TO_DATE(y), x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DATEDIFF(TO_DATE(y), x)");
  });
  it.todo("hive -> spark: DATEDIFF(TO_DATE(y), x) (cross-dialect transform)");
  it.todo("hive -> : DATEDIFF(TO_DATE(y), x) (cross-dialect transform)");
  it("hive -> duckdb: UNIX_TIMESTAMP(x)", () => {
    const result = transpile("UNIX_TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("EPOCH(STRPTIME(x, '%Y-%m-%d %H:%M:%S'))");
  });
  it.todo("hive -> presto: UNIX_TIMESTAMP(x) (unsupported syntax)");
  it("hive -> hive: UNIX_TIMESTAMP(x)", () => {
    const result = transpile("UNIX_TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("UNIX_TIMESTAMP(x)");
  });
  it("hive -> spark: UNIX_TIMESTAMP(x)", () => {
    const result = transpile("UNIX_TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("UNIX_TIMESTAMP(x)");
  });
  it("hive -> : UNIX_TIMESTAMP(x)", () => {
    const result = transpile("UNIX_TIMESTAMP(x)", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("STR_TO_UNIX(x, '%Y-%m-%d %H:%M:%S')");
  });
  it.todo("hive -> duckdb: DAY(x) (cross-dialect transform)");
  it.todo("hive -> presto: DAY(x) (unsupported syntax)");
  it("hive -> hive: DAY(x)", () => {
    const result = transpile("DAY(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("DAY(x)");
  });
  it.todo("hive -> spark: DAY(x) (cross-dialect transform)");
  it("hive -> duckdb: MONTH(x)", () => {
    const result = transpile("MONTH(x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MONTH(CAST(x AS DATE))");
  });
  it.todo("hive -> presto: MONTH(x) (unsupported syntax)");
  it("hive -> hive: MONTH(x)", () => {
    const result = transpile("MONTH(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("MONTH(x)");
  });
  it("hive -> spark: MONTH(x)", () => {
    const result = transpile("MONTH(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("MONTH(x)");
  });
  it.todo("hive -> duckdb: YEAR(x) (cross-dialect transform)");
  it.todo("hive -> presto: YEAR(x) (unsupported syntax)");
  it("hive -> hive: YEAR(x)", () => {
    const result = transpile("YEAR(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("YEAR(x)");
  });
  it.todo("hive -> spark: YEAR(x) (cross-dialect transform)");
});

describe("Hive: order_by", () => {
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
});

describe("Hive: hive", () => {
  it("TO_DATE(TO_DATE(x))", () => {
    validateIdentity("TO_DATE(TO_DATE(x))");
  });
  it("DAY(TO_DATE(x))", () => {
    validateIdentity("DAY(TO_DATE(x))");
  });
  it("SELECT * FROM t WHERE col IN ('stream')", () => {
    validateIdentity("SELECT * FROM t WHERE col IN ('stream')");
  });
  it.todo("SET hiveconf:some_var = 5 (check_command_warning)");
  it.todo("(VALUES (1 AS a, 2 AS b, 3)) (unsupported syntax)");
  it("SELECT * FROM my_table TIMESTAMP AS OF DATE_ADD(CURRENT_DATE, -1)", () => {
    validateIdentity("SELECT * FROM my_table TIMESTAMP AS OF DATE_ADD(CURRENT_DATE, -1)");
  });
  it("SELECT * FROM my_table VERSION AS OF DATE_ADD(CURRENT_DATE, -1)", () => {
    validateIdentity("SELECT * FROM my_table VERSION AS OF DATE_ADD(CURRENT_DATE, -1)");
  });
  it("SELECT WEEKOFYEAR('2024-05-22'), DAYOFMONTH('2024-05-22'), DAYOFWEEK('2024-05-22')", () => {
    validateIdentity("SELECT WEEKOFYEAR('2024-05-22'), DAYOFMONTH('2024-05-22'), DAYOFWEEK('2024-05-22')");
  });
  it("SELECT ROW() OVER (DISTRIBUTE BY x SORT BY y) -> SELECT ROW() OVER (PARTITION BY x ORDE...", () => {
    validateIdentity("SELECT ROW() OVER (DISTRIBUTE BY x SORT BY y)", "SELECT ROW() OVER (PARTITION BY x ORDER BY y)");
  });
  it("SELECT transform", () => {
    validateIdentity("SELECT transform");
  });
  it("SELECT * FROM test DISTRIBUTE BY y SORT BY x DESC ORDER BY l", () => {
    validateIdentity("SELECT * FROM test DISTRIBUTE BY y SORT BY x DESC ORDER BY l");
  });
  it("SELECT * FROM test WHERE RAND() <= 0.1 DISTRIBUTE BY RAND() SORT BY RAND()", () => {
    validateIdentity("SELECT * FROM test WHERE RAND() <= 0.1 DISTRIBUTE BY RAND() SORT BY RAND()");
  });
  it("(SELECT 1 UNION SELECT 2) DISTRIBUTE BY z", () => {
    validateIdentity("(SELECT 1 UNION SELECT 2) DISTRIBUTE BY z");
  });
  it("(SELECT 1 UNION SELECT 2) DISTRIBUTE BY z SORT BY x", () => {
    validateIdentity("(SELECT 1 UNION SELECT 2) DISTRIBUTE BY z SORT BY x");
  });
  it("(SELECT 1 UNION SELECT 2) CLUSTER BY y DESC", () => {
    validateIdentity("(SELECT 1 UNION SELECT 2) CLUSTER BY y DESC");
  });
  it("SELECT * FROM test CLUSTER BY y", () => {
    validateIdentity("SELECT * FROM test CLUSTER BY y");
  });
  it("(SELECT 1 UNION SELECT 2) SORT BY z", () => {
    validateIdentity("(SELECT 1 UNION SELECT 2) SORT BY z");
  });
  it.todo("INSERT OVERWRITE TABLE zipcodes PARTITION(state = '0') VALUES (896,... (DDL/DML not supported)");
  it.todo("INSERT OVERWRITE TABLE zipcodes PARTITION(state = 0) VALUES (896, '... (DDL/DML not supported)");
  it.todo("INSERT OVERWRITE DIRECTORY 'x' ROW FORMAT DELIMITED FIELDS TERMINAT... (DDL/DML not supported)");
  it.todo("SELECT a, b, SUM(c) FROM tabl AS t GROUP BY a, b, GROUPING SETS ((a... (unsupported clause)");
  it.todo("SELECT a, b, SUM(c) FROM tabl AS t GROUP BY a, b, GROUPING SETS ((t... (unsupported clause)");
  it.todo("SELECT a, b, SUM(c) FROM tabl AS t GROUP BY a, FOO(b), GROUPING SET... (unsupported clause)");
  it.todo("SELECT key, value, GROUPING__ID, COUNT(*) FROM T1 GROUP BY key, val... (unsupported clause)");
  it.todo("SELECT key, value, GROUPING__ID, COUNT(*) FROM T1 GROUP BY key, val... (unsupported clause) (2)");
  it.todo("TRUNCATE TABLE t1 PARTITION(age = 10, name = 'test', address = 'abc') (DDL/DML not supported)");
  it("SELECT * FROM t1, t2 -> SELECT * FROM t1 CROSS JOIN t2", () => {
    validateIdentity("SELECT * FROM t1, t2", "SELECT * FROM t1 CROSS JOIN t2");
  });
  it("hive -> hive: SELECT ${hiveconf:some_var}", () => {
    const result = transpile("SELECT ${hiveconf:some_var}", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT ${hiveconf:some_var}");
  });
  it("hive -> spark: SELECT ${hiveconf:some_var}", () => {
    const result = transpile("SELECT ${hiveconf:some_var}", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT ${hiveconf:some_var}");
  });
  it("hive -> spark: SELECT A.1a AS b FROM test_a AS A", () => {
    const result = transpile("SELECT A.1a AS b FROM test_a AS A", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT A.1a AS b FROM test_a AS A");
  });
  it("hive -> spark: SELECT 1_a AS a FROM test_table", () => {
    const result = transpile("SELECT 1_a AS a FROM test_table", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT 1_a AS a FROM test_table");
  });
  it("hive -> trino: SELECT 1_a AS a FROM test_table", () => {
    const result = transpile("SELECT 1_a AS a FROM test_table", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe('SELECT "1_a" AS a FROM test_table');
  });
  it("hive -> spark: SELECT a_b AS 1_a FROM test_table", () => {
    const result = transpile("SELECT a_b AS 1_a FROM test_table", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT a_b AS 1_a FROM test_table");
  });
  it("hive -> spark: SELECT 1a_1a FROM test_a", () => {
    const result = transpile("SELECT 1a_1a FROM test_a", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT 1a_1a FROM test_a");
  });
  it("hive -> spark: SELECT 1a AS 1a_1a FROM test_a", () => {
    const result = transpile("SELECT 1a AS 1a_1a FROM test_a", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT 1a AS 1a_1a FROM test_a");
  });
  it.todo("CREATE TABLE test_table (1a STRING) (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table2 (1a_1a STRING) (DDL/DML not supported)");
  it("hive -> hive: PERCENTILE_APPROX(x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("presto -> hive: APPROX_PERCENTILE(x, 0.5)", () => {
    const result = transpile("APPROX_PERCENTILE(x, 0.5)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("duckdb -> hive: APPROX_QUANTILE(x, 0.5)", () => {
    const result = transpile("APPROX_QUANTILE(x, 0.5)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("spark -> hive: PERCENTILE_APPROX(x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("hive -> hive: PERCENTILE_APPROX(x, 0.5) (2)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("hive -> presto: PERCENTILE_APPROX(x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("APPROX_PERCENTILE(x, 0.5)");
  });
  it("hive -> duckdb: PERCENTILE_APPROX(x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_QUANTILE(x, 0.5)");
  });
  it("hive -> spark: PERCENTILE_APPROX(x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(x, 0.5)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("hive -> hive: PERCENTILE_APPROX(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("spark2 -> hive: PERCENTILE_APPROX(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("spark -> hive: PERCENTILE_APPROX(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("databricks -> hive: PERCENTILE_APPROX(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5)");
  });
  it("hive -> hive: PERCENTILE_APPROX(ALL x, 0.5, 200)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5, 200)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5, 200)");
  });
  it("spark2 -> hive: PERCENTILE_APPROX(ALL x, 0.5, 200)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5, 200)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5, 200)");
  });
  it("spark -> hive: PERCENTILE_APPROX(ALL x, 0.5, 200)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5, 200)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5, 200)");
  });
  it("databricks -> hive: PERCENTILE_APPROX(ALL x, 0.5, 200)", () => {
    const result = transpile("PERCENTILE_APPROX(ALL x, 0.5, 200)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE_APPROX(x, 0.5, 200)");
  });
  it("hive -> bigquery: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "bigquery" })[0];
    expect(result).toBe("APPROX_COUNT_DISTINCT(a)");
  });
  it("hive -> duckdb: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("APPROX_COUNT_DISTINCT(a)");
  });
  it("hive -> presto: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("APPROX_DISTINCT(a)");
  });
  it("hive -> hive: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("APPROX_COUNT_DISTINCT(a)");
  });
  it("hive -> snowflake: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("APPROX_COUNT_DISTINCT(a)");
  });
  it("hive -> spark: APPROX_COUNT_DISTINCT(a)", () => {
    const result = transpile("APPROX_COUNT_DISTINCT(a)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("APPROX_COUNT_DISTINCT(a)");
  });
  it("duckdb -> hive: LIST_HAS(x, 1)", () => {
    const result = transpile("LIST_HAS(x, 1)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_CONTAINS(x, 1)");
  });
  it("snowflake -> hive: ARRAY_CONTAINS(1, x)", () => {
    const result = transpile("ARRAY_CONTAINS(1, x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("ARRAY_CONTAINS(x, 1)");
  });
  it("hive -> duckdb: ARRAY_CONTAINS(x, 1)", () => {
    const result = transpile("ARRAY_CONTAINS(x, 1)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ARRAY_CONTAINS(x, 1)");
  });
  it("hive -> presto: ARRAY_CONTAINS(x, 1)", () => {
    const result = transpile("ARRAY_CONTAINS(x, 1)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CONTAINS(x, 1)");
  });
  it("hive -> hive: ARRAY_CONTAINS(x, 1)", () => {
    const result = transpile("ARRAY_CONTAINS(x, 1)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("ARRAY_CONTAINS(x, 1)");
  });
  it("hive -> spark: ARRAY_CONTAINS(x, 1)", () => {
    const result = transpile("ARRAY_CONTAINS(x, 1)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ARRAY_CONTAINS(x, 1)");
  });
  it("hive -> snowflake: ARRAY_CONTAINS(x, 1)", () => {
    const result = transpile("ARRAY_CONTAINS(x, 1)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_CONTAINS(CAST(1 AS VARIANT), x)");
  });
  it.todo("hive -> duckdb: SIZE(x) (cross-dialect transform)");
  it.todo("hive -> presto: SIZE(x) (cross-dialect transform)");
  it("hive -> hive: SIZE(x)", () => {
    const result = transpile("SIZE(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SIZE(x)");
  });
  it.todo("hive -> spark: SIZE(x) (cross-dialect transform)");
  it("hive -> duckdb: LOCATE('a', x)", () => {
    const result = transpile("LOCATE('a', x)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("STRPOS(x, 'a')");
  });
  it("hive -> presto: LOCATE('a', x)", () => {
    const result = transpile("LOCATE('a', x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("STRPOS(x, 'a')");
  });
  it("hive -> hive: LOCATE('a', x)", () => {
    const result = transpile("LOCATE('a', x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("LOCATE('a', x)");
  });
  it("hive -> spark: LOCATE('a', x)", () => {
    const result = transpile("LOCATE('a', x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LOCATE('a', x)");
  });
  it("hive -> duckdb: LOCATE('a', x, 3)", () => {
    const result = transpile("LOCATE('a', x, 3)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("CASE WHEN STRPOS(SUBSTRING(x, 3), 'a') = 0 THEN 0 ELSE STRPOS(SUBSTRING(x, 3), 'a') + 3 - 1 END");
  });
  it("hive -> presto: LOCATE('a', x, 3)", () => {
    const result = transpile("LOCATE('a', x, 3)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("IF(STRPOS(SUBSTRING(x, 3), 'a') = 0, 0, STRPOS(SUBSTRING(x, 3), 'a') + 3 - 1)");
  });
  it("hive -> hive: LOCATE('a', x, 3)", () => {
    const result = transpile("LOCATE('a', x, 3)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("LOCATE('a', x, 3)");
  });
  it("hive -> spark: LOCATE('a', x, 3)", () => {
    const result = transpile("LOCATE('a', x, 3)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LOCATE('a', x, 3)");
  });
  it("hive -> hive: INITCAP('new york')", () => {
    const result = transpile("INITCAP('new york')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("INITCAP('new york')");
  });
  it("hive -> spark: INITCAP('new york')", () => {
    const result = transpile("INITCAP('new york')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("INITCAP('new york')");
  });
  it.todo("test_hive: assert_duckdb_sql call");
  it.todo("SELECT * FROM x.z TABLESAMPLE(10 PERCENT) y (unsupported clause)");
  it.todo("SELECT SORT_ARRAY(x, FALSE) (unsupported syntax)");
  it("hive -> presto: GET_JSON_OBJECT(x, '$.name')", () => {
    const result = transpile("GET_JSON_OBJECT(x, '$.name')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("JSON_EXTRACT_SCALAR(x, '$.name')");
  });
  it("hive -> hive: GET_JSON_OBJECT(x, '$.name')", () => {
    const result = transpile("GET_JSON_OBJECT(x, '$.name')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("GET_JSON_OBJECT(x, '$.name')");
  });
  it("hive -> spark: GET_JSON_OBJECT(x, '$.name')", () => {
    const result = transpile("GET_JSON_OBJECT(x, '$.name')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("GET_JSON_OBJECT(x, '$.name')");
  });
  it(" -> hive: VAR_MAP(a, b, c, d)", () => {
    const result = transpile("VAR_MAP(a, b, c, d)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it("clickhouse -> hive: map(a, b, c, d)", () => {
    const result = transpile("map(a, b, c, d)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it("duckdb -> hive: MAP([a, c], [b, d])", () => {
    const result = transpile("MAP([a, c], [b, d])", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it("hive -> hive: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it.todo("presto -> hive: MAP(ARRAY[a, c], ARRAY[b, d]) (unsupported syntax)");
  it("spark -> hive: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it.todo("hive -> : MAP(a, b, c, d) (unsupported syntax)");
  it("hive -> clickhouse: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("map(a, b, c, d)");
  });
  it("hive -> duckdb: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MAP([a, c], [b, d])");
  });
  it.todo("hive -> presto: MAP(a, b, c, d) (unsupported syntax)");
  it("hive -> hive: MAP(a, b, c, d) (2)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it("hive -> spark: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("MAP(a, b, c, d)");
  });
  it("hive -> snowflake: MAP(a, b, c, d)", () => {
    const result = transpile("MAP(a, b, c, d)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("OBJECT_CONSTRUCT(a, b, c, d)");
  });
  it("hive -> duckdb: MAP(a, b)", () => {
    const result = transpile("MAP(a, b)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("MAP([a], [b])");
  });
  it.todo("hive -> presto: MAP(a, b) (unsupported syntax)");
  it("hive -> hive: MAP(a, b)", () => {
    const result = transpile("MAP(a, b)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("MAP(a, b)");
  });
  it("hive -> spark: MAP(a, b)", () => {
    const result = transpile("MAP(a, b)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("MAP(a, b)");
  });
  it("hive -> snowflake: MAP(a, b)", () => {
    const result = transpile("MAP(a, b)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("OBJECT_CONSTRUCT(a, b)");
  });
  it("hive -> duckdb: LOG(10)", () => {
    const result = transpile("LOG(10)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("LN(10)");
  });
  it("hive -> presto: LOG(10)", () => {
    const result = transpile("LOG(10)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("LN(10)");
  });
  it("hive -> hive: LOG(10)", () => {
    const result = transpile("LOG(10)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("LN(10)");
  });
  it("hive -> spark: LOG(10)", () => {
    const result = transpile("LOG(10)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("LN(10)");
  });
  it('hive -> duckdb: ds = "2020-01-01"', () => {
    const result = transpile('ds = "2020-01-01"', { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("ds = '2020-01-01'");
  });
  it('hive -> presto: ds = "2020-01-01"', () => {
    const result = transpile('ds = "2020-01-01"', { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("ds = '2020-01-01'");
  });
  it('hive -> hive: ds = "2020-01-01"', () => {
    const result = transpile('ds = "2020-01-01"', { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("ds = '2020-01-01'");
  });
  it('hive -> spark: ds = "2020-01-01"', () => {
    const result = transpile('ds = "2020-01-01"', { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ds = '2020-01-01'");
  });
  it.todo(`hive -> duckdb: ds = "1''2" (unsupported syntax)`);
  it.todo(`hive -> presto: ds = "1''2" (unsupported syntax)`);
  it(`hive -> hive: ds = "1''2"`, () => {
    const result = transpile(`ds = "1''2"`, { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("ds = '1\\'\\'2'");
  });
  it(`hive -> spark: ds = "1''2"`, () => {
    const result = transpile(`ds = "1''2"`, { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("ds = '1\\'\\'2'");
  });
  it("hive -> duckdb: x == 1", () => {
    const result = transpile("x == 1", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x = 1");
  });
  it("hive -> presto: x == 1", () => {
    const result = transpile("x == 1", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("x = 1");
  });
  it("hive -> hive: x == 1", () => {
    const result = transpile("x == 1", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("x = 1");
  });
  it("hive -> spark: x == 1", () => {
    const result = transpile("x == 1", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x = 1");
  });
  it("databricks -> hive: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("x DIV y");
  });
  it("duckdb -> hive: x // y", () => {
    const result = transpile("x // y", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("x DIV y");
  });
  it("hive -> hive: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("x DIV y");
  });
  it("spark2 -> hive: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("x DIV y");
  });
  it("spark -> hive: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("x DIV y");
  });
  it("hive -> duckdb: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("x // y");
  });
  it("hive -> databricks: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("x DIV y");
  });
  it("hive -> presto: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("CAST(CAST(x AS DOUBLE) / y AS INTEGER)");
  });
  it("hive -> spark2: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("x DIV y");
  });
  it("hive -> spark: x DIV y", () => {
    const result = transpile("x DIV y", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("x DIV y");
  });
  it("presto -> hive: ARRAY_AGG(x)", () => {
    const result = transpile("ARRAY_AGG(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("COLLECT_LIST(x)");
  });
  it.todo("hive -> duckdb: COLLECT_LIST(x) (unsupported syntax)");
  it.todo("hive -> presto: COLLECT_LIST(x) (unsupported syntax)");
  it("hive -> hive: COLLECT_LIST(x)", () => {
    const result = transpile("COLLECT_LIST(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("COLLECT_LIST(x)");
  });
  it("hive -> spark: COLLECT_LIST(x)", () => {
    const result = transpile("COLLECT_LIST(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("COLLECT_LIST(x)");
  });
  it("doris -> hive: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: "doris", writeDialect: DIALECT })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("presto -> hive: SET_AGG(x)", () => {
    const result = transpile("SET_AGG(x)", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("snowflake -> hive: ARRAY_UNIQUE_AGG(x)", () => {
    const result = transpile("ARRAY_UNIQUE_AGG(x)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("hive -> doris: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "doris" })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("hive -> hive: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("hive -> presto: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("SET_AGG(x)");
  });
  it("hive -> snowflake: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "snowflake" })[0];
    expect(result).toBe("ARRAY_UNIQUE_AGG(x)");
  });
  it("hive -> spark: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("COLLECT_SET(x)");
  });
  it("hive -> trino: COLLECT_SET(x)", () => {
    const result = transpile("COLLECT_SET(x)", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("ARRAY_AGG(DISTINCT x)");
  });
  it.todo("SELECT * FROM x TABLESAMPLE (1 PERCENT) AS foo (unsupported clause)");
  it.todo("SELECT a, SUM(c) FROM t GROUP BY a, DATE_FORMAT(b, 'yyyy'), GROUPIN... (unsupported clause)");
  it.todo("SELECT TRUNC(CAST(ds AS TIMESTAMP), 'MONTH') (unsupported syntax)");
  it.todo("TRUNC(date_col, 'MM') (assert_is check)");
  it("postgres -> hive: TRUNC(3.14159, 2)", () => {
    const result = transpile("TRUNC(3.14159, 2)", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("CAST(3.14159 AS BIGINT)");
  });
  it("hive -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("spark2 -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("spark -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("databricks -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("hive -> hive: REGEXP_EXTRACT('abc', '(a)(b)(c)') (2)", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("hive -> spark2: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("hive -> spark: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("hive -> databricks: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)')");
  });
  it("hive -> presto: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 1)");
  });
  it("hive -> trino: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "trino" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 1)");
  });
  it("hive -> duckdb: REGEXP_EXTRACT('abc', '(a)(b)(c)')", () => {
    const result = transpile("REGEXP_EXTRACT('abc', '(a)(b)(c)')", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("REGEXP_EXTRACT('abc', '(a)(b)(c)', 1)");
  });
  it.todo("EXISTS(col, x -> x % 2 = 0) (assert_is check)");
  it.todo("SELECT EXISTS(ARRAY(2, 3), x -> x % 2 = 0) (unsupported syntax)");
  it("SELECT 1_2", () => {
    validateIdentity("SELECT 1_2");
  });
  it("hive -> hive: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("spark2 -> hive: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("spark -> hive: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("databricks -> hive: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("hive -> spark2: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("hive -> spark: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("hive -> databricks: SELECT MAP(*), STRUCT(*) FROM t", () => {
    const result = transpile("SELECT MAP(*), STRUCT(*) FROM t", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT MAP(*), STRUCT(*) FROM t");
  });
  it("hive -> hive: SELECT FIRST(sample_col, TRUE)", () => {
    const result = transpile("SELECT FIRST(sample_col, TRUE)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT FIRST(sample_col) IGNORE NULLS");
  });
  it("spark2 -> hive: SELECT FIRST(sample_col, TRUE)", () => {
    const result = transpile("SELECT FIRST(sample_col, TRUE)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT FIRST(sample_col) IGNORE NULLS");
  });
  it("spark -> hive: SELECT FIRST(sample_col, TRUE)", () => {
    const result = transpile("SELECT FIRST(sample_col, TRUE)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT FIRST(sample_col) IGNORE NULLS");
  });
  it("databricks -> hive: SELECT FIRST(sample_col, TRUE)", () => {
    const result = transpile("SELECT FIRST(sample_col, TRUE)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT FIRST(sample_col) IGNORE NULLS");
  });
  it.todo("hive -> duckdb: SELECT FIRST(sample_col) IGNORE NULLS (cross-dialect transform)");
  it("DATE_SUB(CURRENT_DATE, 1 + 1) -> DATE_ADD(CURRENT_DATE, (1 + 1) * -1)", () => {
    validateIdentity("DATE_SUB(CURRENT_DATE, 1 + 1)", "DATE_ADD(CURRENT_DATE, (1 + 1) * -1)");
  });
  it("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result", () => {
    validateIdentity("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result");
  });
});

describe("Hive: escapes", () => {
  it.todo("'\n' (unsupported syntax)");
  it.todo("'\\n' (unsupported syntax)");
  it("'\\\n' -> '\\\\\\n'", () => {
    validateIdentity("'\\\n'", "'\\\\\\n'");
  });
  it.todo("'\\\\n' (unsupported syntax)");
  it("''", () => {
    validateIdentity("''");
  });
  it("'\\\\'", () => {
    validateIdentity("'\\\\'");
  });
  it("'\\\\z'", () => {
    validateIdentity("'\\\\z'");
  });
});

describe("Hive: data_type", () => {
  it("hive -> hive: CAST(a AS BIT)", () => {
    const result = transpile("CAST(a AS BIT)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("CAST(a AS BOOLEAN)");
  });
});

describe("Hive: joins_without_on", () => {
  it("hive -> hive: SELECT * FROM t1 FULL OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 FULL OUTER JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE");
  });
  it.todo("spark2 -> hive: SELECT * FROM t1 FULL OUTER JOIN t2 (cross-dialect transform)");
  it.todo("spark -> hive: SELECT * FROM t1 FULL OUTER JOIN t2 (cross-dialect transform)");
  it.todo("databricks -> hive: SELECT * FROM t1 FULL OUTER JOIN t2 (cross-dialect transform)");
  it.todo("sqlite -> hive: SELECT * FROM t1 FULL OUTER JOIN t2 (cross-dialect transform)");
  it("hive -> hive: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE");
  });
  it.todo("hive -> spark2: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE (cross-dialect transform)");
  it.todo("hive -> spark: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE (cross-dialect transform)");
  it.todo("hive -> databricks: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE (cross-dialect transform)");
  it.todo("hive -> sqlite: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE (cross-dialect transform)");
  it.todo("hive -> duckdb: SELECT * FROM t1 FULL OUTER JOIN t2 ON TRUE (cross-dialect transform)");
  it("hive -> hive: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("spark2 -> hive: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("spark -> hive: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("databricks -> hive: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("sqlite -> hive: SELECT * FROM t1 LEFT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> spark2: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> spark: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> databricks: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> sqlite: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> duckdb: SELECT * FROM t1 LEFT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("spark2 -> hive: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("spark -> hive: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("databricks -> hive: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("sqlite -> hive: SELECT * FROM t1 RIGHT JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> spark2: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> spark: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> databricks: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> sqlite: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> duckdb: SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("spark2 -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("spark -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("databricks -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("sqlite -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> spark2: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> spark: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> databricks: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> sqlite: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> duckdb: SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("spark2 -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("spark -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("databricks -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("sqlite -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> spark2: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> spark: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> databricks: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> sqlite: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> duckdb: SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1 RIGHT OUTER JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("spark2 -> hive: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("spark -> hive: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("databricks -> hive: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("sqlite -> hive: SELECT * FROM t1 INNER JOIN t2", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2", { readDialect: "sqlite", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> hive: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> spark2: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> spark: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> databricks: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> sqlite: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "sqlite" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
  it("hive -> duckdb: SELECT * FROM t1 INNER JOIN t2 ON TRUE", () => {
    const result = transpile("SELECT * FROM t1 INNER JOIN t2 ON TRUE", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("SELECT * FROM t1 INNER JOIN t2 ON TRUE");
  });
});

describe("Hive: percentile", () => {
  it("hive -> duckdb: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "duckdb" })[0];
    expect(result).toBe("QUANTILE(x, 0.5)");
  });
  it("hive -> presto: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "presto" })[0];
    expect(result).toBe("APPROX_PERCENTILE(x, 0.5)");
  });
  it("hive -> hive: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "hive" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("hive -> spark2: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "spark2" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("hive -> spark: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("hive -> databricks: PERCENTILE(x, 0.5)", () => {
    const result = transpile("PERCENTILE(x, 0.5)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("hive -> hive: PERCENTILE(DISTINCT x, 0.5)", () => {
    const result = transpile("PERCENTILE(DISTINCT x, 0.5)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(DISTINCT x, 0.5)");
  });
  it("spark -> hive: PERCENTILE(DISTINCT x, 0.5)", () => {
    const result = transpile("PERCENTILE(DISTINCT x, 0.5)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(DISTINCT x, 0.5)");
  });
  it("databricks -> hive: PERCENTILE(DISTINCT x, 0.5)", () => {
    const result = transpile("PERCENTILE(DISTINCT x, 0.5)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(DISTINCT x, 0.5)");
  });
  it("hive -> spark: PERCENTILE(DISTINCT x, 0.5)", () => {
    const result = transpile("PERCENTILE(DISTINCT x, 0.5)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("PERCENTILE(DISTINCT x, 0.5)");
  });
  it("hive -> databricks: PERCENTILE(DISTINCT x, 0.5)", () => {
    const result = transpile("PERCENTILE(DISTINCT x, 0.5)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("PERCENTILE(DISTINCT x, 0.5)");
  });
  it("hive -> hive: PERCENTILE(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE(ALL x, 0.5)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("spark2 -> hive: PERCENTILE(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE(ALL x, 0.5)", { readDialect: "spark2", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("spark -> hive: PERCENTILE(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE(ALL x, 0.5)", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
  it("databricks -> hive: PERCENTILE(ALL x, 0.5)", () => {
    const result = transpile("PERCENTILE(ALL x, 0.5)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("PERCENTILE(x, 0.5)");
  });
});
