// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "clickhouse";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Clickhouse: clickhouse", () => {
  it("cast(notEmpty(report_task_id)?report_task_id:'-1' AS text) -> CAST(CASE WHEN notEmpty(r...", () => {
    validateIdentity("cast(notEmpty(report_task_id)?report_task_id:'-1' AS text)", "CAST(CASE WHEN notEmpty(report_task_id) THEN report_task_id ELSE '-1' END AS String)");
  });
  it.todo("test_clickhouse: assertEqual call");
  it.todo("test_clickhouse: unresolvable for-loop iterable");
  it.todo("test_clickhouse: assertEqual call (2)");
  it.todo("test_clickhouse: assertEqual call (3)");
  it.todo("test_clickhouse: assertEqual call (4)");
  it.todo("test_clickhouse: assertEqual call (5)");
  it.todo("test_clickhouse: assertEqual call (6)");
  it.todo("test_clickhouse: assertEqual call (7)");
  it.todo("test_clickhouse: assertEqual call (8)");
  it.todo("test_clickhouse: assertEqual call (9)");
  it.todo("test_clickhouse: assertEqual call (10)");
  it.todo("test_clickhouse: assertEqual call (11)");
  it.todo("test_clickhouse: assertEqual call (12)");
  it.todo("test_clickhouse: assertEqual call (13)");
  it('SELECT DISTINCT ON ("id") * FROM t', () => {
    validateIdentity('SELECT DISTINCT ON ("id") * FROM t');
  });
  it("SELECT 1 OR (1 = 2)", () => {
    validateIdentity("SELECT 1 OR (1 = 2)");
  });
  it("SELECT 1 AND (1 = 2)", () => {
    validateIdentity("SELECT 1 AND (1 = 2)");
  });
  it("SELECT json.a.:Int64", () => {
    validateIdentity("SELECT json.a.:Int64");
  });
  it("SELECT json.a.:JSON.b.:Int64", () => {
    validateIdentity("SELECT json.a.:JSON.b.:Int64");
  });
  it("WITH arrayJoin([(1, [2, 3])]) AS arr SELECT arr", () => {
    validateIdentity("WITH arrayJoin([(1, [2, 3])]) AS arr SELECT arr");
  });
  it("CAST(1 AS Bool)", () => {
    validateIdentity("CAST(1 AS Bool)");
  });
  it("SELECT toString(CHAR(104.1, 101, 108.9, 108.9, 111, 32))", () => {
    validateIdentity("SELECT toString(CHAR(104.1, 101, 108.9, 108.9, 111, 32))");
  });
  it("SELECT toFloat(like)", () => {
    validateIdentity("SELECT toFloat(like)");
  });
  it("SELECT like", () => {
    validateIdentity("SELECT like");
  });
  it("SELECT STR_TO_DATE(str, fmt, tz)", () => {
    validateIdentity("SELECT STR_TO_DATE(str, fmt, tz)");
  });
  it("SELECT STR_TO_DATE('05 12 2000', '%d %m %Y')", () => {
    validateIdentity("SELECT STR_TO_DATE('05 12 2000', '%d %m %Y')");
  });
  it("SELECT EXTRACT(YEAR FROM toDateTime('2023-02-01'))", () => {
    validateIdentity("SELECT EXTRACT(YEAR FROM toDateTime('2023-02-01'))");
  });
  it("extract(haystack, pattern)", () => {
    validateIdentity("extract(haystack, pattern)");
  });
  it("SELECT * FROM x LIMIT 1 UNION ALL SELECT * FROM y", () => {
    validateIdentity("SELECT * FROM x LIMIT 1 UNION ALL SELECT * FROM y");
  });
  it.todo("SELECT CAST(x AS Tuple(String, Array(Nullable(Float64)))) (unsupported syntax)");
  it("countIf(x, y)", () => {
    validateIdentity("countIf(x, y)");
  });
  it("x = y", () => {
    validateIdentity("x = y");
  });
  it("x <> y", () => {
    validateIdentity("x <> y");
  });
  it.todo("SELECT * FROM (SELECT a FROM b SAMPLE 0.01) (unsupported clause)");
  it.todo("SELECT * FROM (SELECT a FROM b SAMPLE 1 / 10 OFFSET 1 / 2) (unsupported clause)");
  it.todo("SELECT sum(foo * bar) FROM bla SAMPLE 10000000 (unsupported clause)");
  it("CAST(x AS Nested(ID UInt32, Serial UInt32, EventTime DateTime))", () => {
    validateIdentity("CAST(x AS Nested(ID UInt32, Serial UInt32, EventTime DateTime))");
  });
  it("CAST(x AS Enum('hello' = 1, 'world' = 2))", () => {
    validateIdentity("CAST(x AS Enum('hello' = 1, 'world' = 2))");
  });
  it("CAST(x AS Enum('hello', 'world'))", () => {
    validateIdentity("CAST(x AS Enum('hello', 'world'))");
  });
  it("CAST(x AS Enum('hello' = 1, 'world'))", () => {
    validateIdentity("CAST(x AS Enum('hello' = 1, 'world'))");
  });
  it("CAST(x AS Enum8('hello' = -123, 'world'))", () => {
    validateIdentity("CAST(x AS Enum8('hello' = -123, 'world'))");
  });
  it("CAST(x AS FixedString(1))", () => {
    validateIdentity("CAST(x AS FixedString(1))");
  });
  it("CAST(x AS LowCardinality(FixedString))", () => {
    validateIdentity("CAST(x AS LowCardinality(FixedString))");
  });
  it("SELECT isNaN(1.0)", () => {
    validateIdentity("SELECT isNaN(1.0)");
  });
  it.todo("SELECT startsWith('Spider-Man', 'Spi') (unsupported syntax)");
  it.todo("SELECT xor(TRUE, FALSE) (unsupported syntax)");
  it.todo("CAST(['hello'], 'Array(Enum8(''hello'' = 1))') (unsupported syntax)");
  it("SELECT x, COUNT() FROM y GROUP BY x WITH TOTALS", () => {
    validateIdentity("SELECT x, COUNT() FROM y GROUP BY x WITH TOTALS");
  });
  it("SELECT INTERVAL t.days DAY", () => {
    validateIdentity("SELECT INTERVAL t.days DAY");
  });
  it("SELECT match('abc', '([a-z]+)')", () => {
    validateIdentity("SELECT match('abc', '([a-z]+)')");
  });
  it("dictGet(x, 'y')", () => {
    validateIdentity("dictGet(x, 'y')");
  });
  it("WITH final AS (SELECT 1) SELECT * FROM final", () => {
    validateIdentity("WITH final AS (SELECT 1) SELECT * FROM final");
  });
  it("SELECT * FROM x FINAL", () => {
    validateIdentity("SELECT * FROM x FINAL");
  });
  it("SELECT * FROM x AS y FINAL", () => {
    validateIdentity("SELECT * FROM x AS y FINAL");
  });
  it("'a' IN mapKeys(map('a', 1, 'b', 2))", () => {
    validateIdentity("'a' IN mapKeys(map('a', 1, 'b', 2))");
  });
  it("CAST((1, 2) AS Tuple(a Int8, b Int16))", () => {
    validateIdentity("CAST((1, 2) AS Tuple(a Int8, b Int16))");
  });
  it("SELECT * FROM foo LEFT ANY JOIN bla", () => {
    validateIdentity("SELECT * FROM foo LEFT ANY JOIN bla");
  });
  it("SELECT * FROM foo LEFT ASOF JOIN bla", () => {
    validateIdentity("SELECT * FROM foo LEFT ASOF JOIN bla");
  });
  it("SELECT * FROM foo ASOF JOIN bla", () => {
    validateIdentity("SELECT * FROM foo ASOF JOIN bla");
  });
  it("SELECT * FROM foo ANY JOIN bla", () => {
    validateIdentity("SELECT * FROM foo ANY JOIN bla");
  });
  it("SELECT * FROM foo GLOBAL ANY JOIN bla", () => {
    validateIdentity("SELECT * FROM foo GLOBAL ANY JOIN bla");
  });
  it("SELECT * FROM foo GLOBAL LEFT ANY JOIN bla", () => {
    validateIdentity("SELECT * FROM foo GLOBAL LEFT ANY JOIN bla");
  });
  it("SELECT quantile(0.5)(a)", () => {
    validateIdentity("SELECT quantile(0.5)(a)");
  });
  it("SELECT quantiles(0.5)(a) AS x FROM t", () => {
    validateIdentity("SELECT quantiles(0.5)(a) AS x FROM t");
  });
  it("SELECT quantilesIf(0.5)(a, a > 1) AS x FROM t", () => {
    validateIdentity("SELECT quantilesIf(0.5)(a, a > 1) AS x FROM t");
  });
  it("SELECT quantileState(0.5)(a) AS x FROM t", () => {
    validateIdentity("SELECT quantileState(0.5)(a) AS x FROM t");
  });
  it("SELECT deltaSumMerge(a) AS x FROM t", () => {
    validateIdentity("SELECT deltaSumMerge(a) AS x FROM t");
  });
  it("SELECT quantiles(0.1, 0.2, 0.3)(a)", () => {
    validateIdentity("SELECT quantiles(0.1, 0.2, 0.3)(a)");
  });
  it("SELECT quantileTiming(0.5)(RANGE(100))", () => {
    validateIdentity("SELECT quantileTiming(0.5)(RANGE(100))");
  });
  it("SELECT histogram(5)(a)", () => {
    validateIdentity("SELECT histogram(5)(a)");
  });
  it.todo("SELECT groupUniqArray(2)(a) (unsupported syntax)");
  it("SELECT exponentialTimeDecayedAvg(60)(a, b)", () => {
    validateIdentity("SELECT exponentialTimeDecayedAvg(60)(a, b)");
  });
  it("levenshteinDistance(col1, col2) -> editDistance(col1, col2)", () => {
    validateIdentity("levenshteinDistance(col1, col2)", "editDistance(col1, col2)");
  });
  it("jaroWinklerSimilarity('hello', 'world')", () => {
    validateIdentity("jaroWinklerSimilarity('hello', 'world')");
  });
  it("SELECT * FROM foo WHERE x GLOBAL IN (SELECT * FROM bar)", () => {
    validateIdentity("SELECT * FROM foo WHERE x GLOBAL IN (SELECT * FROM bar)");
  });
  it("SELECT * FROM foo WHERE x GLOBAL NOT IN (SELECT * FROM bar)", () => {
    validateIdentity("SELECT * FROM foo WHERE x GLOBAL NOT IN (SELECT * FROM bar)");
  });
  it("POSITION(haystack, needle)", () => {
    validateIdentity("POSITION(haystack, needle)");
  });
  it("POSITION(haystack, needle, position)", () => {
    validateIdentity("POSITION(haystack, needle, position)");
  });
  it("CAST(x AS DATETIME) -> CAST(x AS DateTime)", () => {
    validateIdentity("CAST(x AS DATETIME)", "CAST(x AS DateTime)");
  });
  it.todo("CAST(x AS TIMESTAMPTZ) (unsupported syntax)");
  it("CAST(x as MEDIUMINT) -> CAST(x AS Int32)", () => {
    validateIdentity("CAST(x as MEDIUMINT)", "CAST(x AS Int32)");
  });
  it("CAST(x AS DECIMAL(38, 2)) -> CAST(x AS Decimal(38, 2))", () => {
    validateIdentity("CAST(x AS DECIMAL(38, 2))", "CAST(x AS Decimal(38, 2))");
  });
  it("SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src", () => {
    validateIdentity("SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src");
  });
  it(`SELECT JSONExtractString('{"x": {"y": 1}}', 'x', 'y')`, () => {
    validateIdentity(`SELECT JSONExtractString('{"x": {"y": 1}}', 'x', 'y')`);
  });
  it("SELECT * FROM table LIMIT 1 BY a, b", () => {
    validateIdentity("SELECT * FROM table LIMIT 1 BY a, b");
  });
  it("SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b", () => {
    validateIdentity("SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b");
  });
  it.todo("TRUNCATE TABLE t1 ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("TRUNCATE DATABASE db (DDL/DML not supported)");
  it.todo("TRUNCATE DATABASE db ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("TRUNCATE DATABASE db ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("trunc(3.14159, 2) (assert_is check)");
  it.todo("trunc(3.14159) (assert_is check)");
  it.todo("postgres -> clickhouse: TRUNC(3.14159, 2) (cross-dialect transform)");
  it.todo("EXCHANGE TABLES x.a AND y.b (check_command_warning)");
  it.todo("CREATE TABLE test (id UInt8) ENGINE=Null() (DDL/DML not supported)");
  it.todo("SELECT * FROM foo ORDER BY bar OFFSET 0 ROWS FETCH NEXT 10 ROWS WIT... (unsupported clause)");
  it.todo("SELECT DATE_BIN(toDateTime('2023-01-01 14:45:00'), INTERVAL '1' MIN... (unsupported syntax)");
  it.todo("SELECT CAST(1730098800 AS DateTime64) AS DATETIME, 'test' AS interp... (unsupported syntax)");
  it.todo("SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_... (unsupported clause)");
  it.todo("SELECT id, quantileGK(100, 0.95)(reading) OVER (PARTITION BY id ORD... (unsupported clause)");
  it("SELECT * FROM table LIMIT 1 BY CONCAT(datalayerVariantNo, datalayerProductId, warehouse)", () => {
    validateIdentity("SELECT * FROM table LIMIT 1 BY CONCAT(datalayerVariantNo, datalayerProductId, warehouse)");
  });
  it(`SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a')`, () => {
    validateIdentity(`SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a')`);
  });
  it.todo("ATTACH DATABASE DEFAULT ENGINE = ORDINARY (check_command_warning)");
  it("SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM nu...", () => {
    validateIdentity("SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL");
  });
  it("SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM nu... (2)", () => {
    validateIdentity("SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5");
  });
  it("SELECT toDate((number * 10) * 86400) AS d1, toDate(number * 86400) AS d2, 'original' AS...", () => {
    validateIdentity("SELECT toDate((number * 10) * 86400) AS d1, toDate(number * 86400) AS d2, 'original' AS source FROM numbers(10) WHERE (number % 3) = 1 ORDER BY d2 WITH FILL, d1 WITH FILL STEP 5");
  });
  it("SELECT n, source, inter FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source,...", () => {
    validateIdentity("SELECT n, source, inter FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1)");
  });
  it.todo("SELECT SUM(1) AS impressions, arrayJoin(cities) AS city, arrayJoin(... (unsupported syntax)");
  it.todo("SELECT sum(1) AS impressions, (arrayJoin(arrayZip(cities, browsers)... (unsupported syntax)");
  it('SELECT CAST(tuple(1 AS "a", 2 AS "b", 3.0 AS "c").2 AS Nullable(String))', () => {
    validateIdentity('SELECT CAST(tuple(1 AS "a", 2 AS "b", 3.0 AS "c").2 AS Nullable(String))');
  });
  it.todo("CREATE TABLE test (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY... (DDL/DML not supported)");
  it.todo("CREATE TABLE test ON CLUSTER default (id UInt8) ENGINE=AggregatingM... (DDL/DML not supported)");
  it.todo("CREATE TABLE test ON CLUSTER '{cluster}' (id UInt8) ENGINE=Aggregat... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_view ON CLUSTER cl1 (id UInt8) ENGINE... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_view ON CLUSTER '{cluster}' (id UInt8... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_view ON CLUSTER cl1 TO table1 AS SELE... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_view ON CLUSTER '{cluster}' TO table1... (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW test_view TO db.table1 (id UInt8) AS SELEC... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (foo String CODEC(LZ4HC(9), ZSTD, DELTA), size Strin... (DDL/DML not supported)");
  it.todo("SELECT generate_series FROM generate_series(0, 10) AS g(x) (unsupported syntax)");
  it("SELECT t.c FROM (SELECT arrayJoin([1,2,3,4,5]) AS c) AS t WHERE (t.c + 0) NOT IN (1,2) ...", () => {
    validateIdentity("SELECT t.c FROM (SELECT arrayJoin([1,2,3,4,5]) AS c) AS t WHERE (t.c + 0) NOT IN (1,2)", "SELECT t.c FROM (SELECT arrayJoin([1, 2, 3, 4, 5]) AS c) AS t WHERE NOT ((t.c + 0) IN (1, 2))");
  });
  it("SELECT * FROM t1, t2 -> SELECT * FROM t1 CROSS JOIN t2", () => {
    validateIdentity("SELECT * FROM t1, t2", "SELECT * FROM t1 CROSS JOIN t2");
  });
  it("SELECT and(1, 2) -> SELECT 1 AND 2", () => {
    validateIdentity("SELECT and(1, 2)", "SELECT 1 AND 2");
  });
  it("SELECT or(1, 2) -> SELECT 1 OR 2", () => {
    validateIdentity("SELECT or(1, 2)", "SELECT 1 OR 2");
  });
  it.todo("SELECT generate_series FROM generate_series(0, 10) AS g (unsupported syntax)");
  it.todo("INSERT INTO tab VALUES ({'key1': 1, 'key2': 10}), ({'key1': 2, 'key... (DDL/DML not supported)");
  it("SELECT (toUInt8('1') + toUInt8('2')) IS NOT NULL -> SELECT NOT ((toUInt8('1') + toUInt8...", () => {
    validateIdentity("SELECT (toUInt8('1') + toUInt8('2')) IS NOT NULL", "SELECT NOT ((toUInt8('1') + toUInt8('2')) IS NULL)");
  });
  it.todo("SELECT $1$foo$1$ (unsupported syntax)");
  it("SELECT * FROM table LIMIT 1, 2 BY a, b -> SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b", () => {
    validateIdentity("SELECT * FROM table LIMIT 1, 2 BY a, b", "SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b");
  });
  it.todo("SELECT SUM(1) AS impressions FROM (SELECT ['Istanbul', 'Berlin', 'B... (unsupported syntax)");
  it("SELECT SUBSTRING_INDEX(str, delim, count)", () => {
    validateIdentity("SELECT SUBSTRING_INDEX(str, delim, count)");
  });
  it("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    validateIdentity("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it("SELECT SUBSTRING_INDEX('a.b.c.d', '.', -2)", () => {
    validateIdentity("SELECT SUBSTRING_INDEX('a.b.c.d', '.', -2)");
  });
  it("clickhouse -> databricks: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it("clickhouse -> spark: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it("clickhouse -> mysql: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it.todo("clickhouse -> databricks: SELECT substringIndex('a.b.c.d', '.', 2) (cross-dialect transform)");
  it.todo("clickhouse -> spark: SELECT substringIndex('a.b.c.d', '.', 2) (cross-dialect transform)");
  it.todo("clickhouse -> mysql: SELECT substringIndex('a.b.c.d', '.', 2) (cross-dialect transform)");
  it("clickhouse -> clickhouse: SELECT substringIndex('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT substringIndex('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT substringIndex('a.b.c.d', '.', 2)");
  });
  it("clickhouse -> clickhouse: SELECT CAST(STR_TO_DATE(SUBSTRING(a.eta, 1, 10), '%Y-%m-%d') ...", () => {
    const result = transpile("SELECT CAST(STR_TO_DATE(SUBSTRING(a.eta, 1, 10), '%Y-%m-%d') AS Nullable(DATE))", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST(STR_TO_DATE(SUBSTRING(a.eta, 1, 10), '%Y-%m-%d') AS Nullable(DATE))");
  });
  it.todo("oracle -> clickhouse: SELECT to_date(substr(a.eta, 1,10), 'YYYY-MM-DD') (cross-dialect transform)");
  it.todo("CHAR(67) || CHAR(65) || CHAR(84) (unsupported syntax)");
  it("clickhouse -> clickhouse: SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS ...", () => {
    const result = transpile("SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees");
  });
  it("oracle -> clickhouse: SELECT LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FR...", () => {
    const result = transpile("SELECT LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees");
  });
  it("clickhouse -> clickhouse: SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS...", () => {
    const result = transpile("SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees");
  });
  it("oracle -> clickhouse: SELECT LEAD(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal F...", () => {
    const result = transpile("SELECT LEAD(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees", { readDialect: "oracle", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees");
  });
  it("clickhouse -> clickhouse: SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable...", () => {
    const result = transpile("SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))");
  });
  it.todo("postgres -> clickhouse: SELECT TO_DATE('05 12 2000', 'DD MM YYYY') (cross-dialect transform)");
  it("clickhouse -> clickhouse: SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable... (2)", () => {
    const result = transpile("SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))");
  });
  it.todo("clickhouse -> postgres: SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(D... (cross-dialect transform)");
  it("clickhouse -> : SELECT * FROM x PREWHERE y = 1 WHERE z = 2", () => {
    const result = transpile("SELECT * FROM x PREWHERE y = 1 WHERE z = 2", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT * FROM x WHERE z = 2");
  });
  it("clickhouse -> clickhouse: SELECT * FROM x PREWHERE y = 1 WHERE z = 2", () => {
    const result = transpile("SELECT * FROM x PREWHERE y = 1 WHERE z = 2", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT * FROM x PREWHERE y = 1 WHERE z = 2");
  });
  it("clickhouse -> clickhouse: SELECT * FROM x AS prewhere", () => {
    const result = transpile("SELECT * FROM x AS prewhere", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM x AS prewhere");
  });
  it("duckdb -> clickhouse: SELECT * FROM x prewhere", () => {
    const result = transpile("SELECT * FROM x prewhere", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT * FROM x AS prewhere");
  });
  it("clickhouse -> clickhouse: SELECT a, b FROM (SELECT * FROM x) AS t(a, b)", () => {
    const result = transpile("SELECT a, b FROM (SELECT * FROM x) AS t(a, b)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT * FROM x) AS t(a, b)");
  });
  it("duckdb -> clickhouse: SELECT a, b FROM (SELECT * FROM x) AS t(a, b)", () => {
    const result = transpile("SELECT a, b FROM (SELECT * FROM x) AS t(a, b)", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT a, b FROM (SELECT * FROM x) AS t(a, b)");
  });
  it("clickhouse -> clickhouse: SELECT arrayJoin([1,2,3])", () => {
    const result = transpile("SELECT arrayJoin([1,2,3])", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT arrayJoin([1, 2, 3])");
  });
  it.todo("clickhouse -> postgres: SELECT arrayJoin([1,2,3]) (unsupported syntax)");
  it.todo("postgres -> clickhouse: x = any(array[1]) (unsupported syntax)");
  it.todo("postgres -> clickhouse: any(array[1]) <> x (unsupported syntax)");
  it("clickhouse -> clickhouse: has([1], x)", () => {
    const result = transpile("has([1], x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("has([1], x)");
  });
  it.todo("presto -> clickhouse: CONTAINS(ARRAY[1], x) (unsupported syntax)");
  it.todo("spark -> clickhouse: ARRAY_CONTAINS(ARRAY(1), x) (unsupported syntax)");
  it.todo("clickhouse -> presto: has([1], x) (unsupported syntax)");
  it.todo("clickhouse -> spark: has([1], x) (unsupported syntax)");
  it.todo("SELECT CAST('2020-01-01' AS Nullable(DateTime)) + INTERVAL '500' MI... (unsupported syntax)");
  it("clickhouse -> clickhouse: SELECT CURRENT_DATE()", () => {
    const result = transpile("SELECT CURRENT_DATE()", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_DATE()");
  });
  it("postgres -> clickhouse: SELECT CURRENT_DATE", () => {
    const result = transpile("SELECT CURRENT_DATE", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_DATE()");
  });
  it("clickhouse -> clickhouse: SELECT CURRENT_TIMESTAMP()", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP()", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP()");
  });
  it("postgres -> clickhouse: SELECT CURRENT_TIMESTAMP", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP()");
  });
  it.todo("postgres -> clickhouse: SELECT 'ThOmAs' ~* 'thomas' (unsupported syntax)");
  it("postgres -> clickhouse: SELECT 'ThOmAs' ~* x FROM t", () => {
    const result = transpile("SELECT 'ThOmAs' ~* x FROM t", { readDialect: "postgres", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT match('ThOmAs', CONCAT('(?i)', x)) FROM t");
  });
  it("mysql -> clickhouse: SELECT '\0'", () => {
    const result = transpile("SELECT '\0'", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT '\\0'");
  });
  it("clickhouse -> clickhouse: SELECT '\\0'", () => {
    const result = transpile("SELECT '\\0'", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT '\\0'");
  });
  it("clickhouse -> mysql: SELECT '\\0'", () => {
    const result = transpile("SELECT '\\0'", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT '\0'");
  });
  it("clickhouse -> clickhouse: dateAdd(DAY, 1, x)", () => {
    const result = transpile("dateAdd(DAY, 1, x)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_ADD(DAY, 1, x)");
  });
  it.todo("presto -> clickhouse: DATE_ADD('DAY', 1, x) (cross-dialect transform)");
  it("clickhouse -> clickhouse: DATE_ADD(DAY, 1, x)", () => {
    const result = transpile("DATE_ADD(DAY, 1, x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("DATE_ADD(DAY, 1, x)");
  });
  it.todo("clickhouse -> presto: DATE_ADD(DAY, 1, x) (cross-dialect transform)");
  it.todo("clickhouse -> : DATE_ADD(DAY, 1, x) (cross-dialect transform)");
  it("clickhouse -> clickhouse: dateDiff(DAY, a, b)", () => {
    const result = transpile("dateDiff(DAY, a, b)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("DATE_DIFF(DAY, a, b)");
  });
  it.todo("presto -> clickhouse: DATE_DIFF('DAY', a, b) (cross-dialect transform)");
  it("clickhouse -> clickhouse: DATE_DIFF(DAY, a, b)", () => {
    const result = transpile("DATE_DIFF(DAY, a, b)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("DATE_DIFF(DAY, a, b)");
  });
  it.todo("clickhouse -> presto: DATE_DIFF(DAY, a, b) (cross-dialect transform)");
  it.todo("clickhouse -> : DATE_DIFF(DAY, a, b) (cross-dialect transform)");
  it.todo("SELECT xor(1, 0) (unsupported syntax)");
  it.todo("SELECT xor(0, 1, xor(1, 0, 0)) (unsupported syntax)");
  it.todo("SELECT xor(xor(1, 0), 1) (unsupported syntax)");
  it.todo("SELECT xor(0, 1, 1, 0) (unsupported syntax)");
  it("clickhouse -> clickhouse: CONCAT(a, b)", () => {
    const result = transpile("CONCAT(a, b)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("CONCAT(a, b)");
  });
  it.todo("mysql -> clickhouse: CONCAT(a, b) (cross-dialect transform)");
  it.todo("clickhouse -> mysql: CONCAT(a, b) (cross-dialect transform)");
  it.todo("clickhouse -> postgres: CONCAT(a, b) (unsupported syntax)");
  it.todo("clickhouse -> clickhouse: 'Enum8(\\'Sunday\\' = 0)' (unsupported syntax)");
  it.todo("bigquery -> clickhouse: SELECT APPROX_COUNT_DISTINCT(x) FROM (SELECT ANY_VALUE(y) x FRO... (cross-dialect transform)");
  it.todo("clickhouse -> bigquery: SELECT uniq(x) FROM (SELECT any(y) AS x FROM (SELECT 1 AS y)) (cross-dialect transform)");
  it.todo("SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST,... (unsupported syntax)");
  it("clickhouse -> clickhouse: CAST(1 AS NULLABLE(Int64))", () => {
    const result = transpile("CAST(1 AS NULLABLE(Int64))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CAST(1 AS Nullable(Int64))");
  });
  it("clickhouse -> clickhouse: CAST(1 AS Nullable(DateTime64(6, 'UTC')))", () => {
    const result = transpile("CAST(1 AS Nullable(DateTime64(6, 'UTC')))", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CAST(1 AS Nullable(DateTime64(6, 'UTC')))");
  });
  it("clickhouse -> : SELECT x #! comment", () => {
    const result = transpile("SELECT x #! comment", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT x /* comment */");
  });
  it("clickhouse -> clickhouse: SELECT quantileIf(0.5)(a, true)", () => {
    const result = transpile("SELECT quantileIf(0.5)(a, true)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT quantileIf(0.5)(a, TRUE)");
  });
  it("SELECT POSITION(needle IN haystack) -> SELECT POSITION(haystack, needle)", () => {
    validateIdentity("SELECT POSITION(needle IN haystack)", "SELECT POSITION(haystack, needle)");
  });
  it("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result = 'break'", () => {
    validateIdentity("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result = 'break'");
  });
  it("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_", () => {
    validateIdentity("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_");
  });
  it("SELECT * FROM x FORMAT PrettyCompact", () => {
    validateIdentity("SELECT * FROM x FORMAT PrettyCompact");
  });
  it("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_ FORMAT PrettyCompact", () => {
    validateIdentity("SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_ FORMAT PrettyCompact");
  });
  it("clickhouse -> clickhouse: SELECT * FROM foo JOIN bar USING id, name", () => {
    const result = transpile("SELECT * FROM foo JOIN bar USING id, name", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT * FROM foo JOIN bar USING (id, name)");
  });
  it("clickhouse -> clickhouse: SELECT * FROM foo ANY LEFT JOIN bla ON foo.c1 = bla.c2", () => {
    const result = transpile("SELECT * FROM foo ANY LEFT JOIN bla ON foo.c1 = bla.c2", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT * FROM foo LEFT ANY JOIN bla ON foo.c1 = bla.c2");
  });
  it("clickhouse -> clickhouse: SELECT * FROM foo GLOBAL ANY LEFT JOIN bla ON foo.c1 = bla.c2", () => {
    const result = transpile("SELECT * FROM foo GLOBAL ANY LEFT JOIN bla ON foo.c1 = bla.c2", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT * FROM foo GLOBAL LEFT ANY JOIN bla ON foo.c1 = bla.c2");
  });
  it("clickhouse -> clickhouse: \n            SELECT\n                loyalty,\n                ...", () => {
    const result = transpile("\n            SELECT\n                loyalty,\n                count()\n            FROM hits SEMI LEFT JOIN users USING (UserID)\n            GROUP BY loyalty\n            ORDER BY loyalty ASC\n            ", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT loyalty, count() FROM hits LEFT SEMI JOIN users USING (UserID) GROUP BY loyalty ORDER BY loyalty ASC");
  });
  it.todo("duckdb -> clickhouse: SELECT quantile(a, 0.5) (cross-dialect transform)");
  it("clickhouse -> clickhouse: SELECT median(a)", () => {
    const result = transpile("SELECT median(a)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT quantile(0.5)(a)");
  });
  it("clickhouse -> clickhouse: SELECT quantile(0.5)(a)", () => {
    const result = transpile("SELECT quantile(0.5)(a)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT quantile(0.5)(a)");
  });
  it.todo("duckdb -> clickhouse: SELECT quantile(a, [0.5, 0.4]) (cross-dialect transform)");
  it("clickhouse -> clickhouse: SELECT quantiles(0.5, 0.4)(a)", () => {
    const result = transpile("SELECT quantiles(0.5, 0.4)(a)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT quantiles(0.5, 0.4)(a)");
  });
  it.todo("duckdb -> clickhouse: SELECT quantile(a, [0.5]) (cross-dialect transform)");
  it("clickhouse -> clickhouse: SELECT quantiles(0.5)(a)", () => {
    const result = transpile("SELECT quantiles(0.5)(a)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT quantiles(0.5)(a)");
  });
  it("SELECT isNaN(x)", () => {
    validateIdentity("SELECT isNaN(x)");
  });
  it("clickhouse -> clickhouse: SELECT IS_NAN(x), ISNAN(x)", () => {
    const result = transpile("SELECT IS_NAN(x), ISNAN(x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT isNaN(x), isNaN(x)");
  });
  it("SELECT startsWith('a', 'b')", () => {
    validateIdentity("SELECT startsWith('a', 'b')");
  });
  it("clickhouse -> clickhouse: SELECT STARTS_WITH('a', 'b'), STARTSWITH('a', 'b')", () => {
    const result = transpile("SELECT STARTS_WITH('a', 'b'), STARTSWITH('a', 'b')", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT startsWith('a', 'b'), startsWith('a', 'b')");
  });
  it.todo("SYSTEM STOP MERGES foo.bar (check_command_warning)");
  it.todo("INSERT INTO FUNCTION s3('url', 'CSV', 'name String, value UInt32', ... (DDL/DML not supported)");
  it.todo("INSERT INTO FUNCTION remote('localhost', default.simple_table) VALU... (DDL/DML not supported)");
  it.todo("INSERT INTO TABLE FUNCTION hdfs('hdfs://hdfs1:9000/test', 'TSV', 'n... (DDL/DML not supported)");
  it("SELECT 1 FORMAT TabSeparated", () => {
    validateIdentity("SELECT 1 FORMAT TabSeparated");
  });
  it("SELECT * FROM t FORMAT TabSeparated", () => {
    validateIdentity("SELECT * FROM t FORMAT TabSeparated");
  });
  it("SELECT FORMAT", () => {
    validateIdentity("SELECT FORMAT");
  });
  it.todo("1 AS FORMAT (assert_is check)");
  it.todo("SELECT formatDateTime(NOW(), '%Y-%m-%d', '%T') (unsupported syntax)");
  it.todo("SELECT formatDateTime(NOW(), '%Y-%m-%d') (unsupported syntax)");
  it.todo("ALTER TABLE visits DROP PARTITION 201901 (DDL/DML not supported)");
  it.todo("ALTER TABLE visits DROP PARTITION ALL (DDL/DML not supported)");
  it.todo("ALTER TABLE visits DROP PARTITION tuple(toYYYYMM(toDate('2019-01-25... (DDL/DML not supported)");
  it.todo("ALTER TABLE visits DROP PARTITION ID '201901' (DDL/DML not supported)");
  it.todo("ALTER TABLE visits REPLACE PARTITION 201901 FROM visits_tmp (DDL/DML not supported)");
  it.todo("ALTER TABLE visits REPLACE PARTITION ALL FROM visits_tmp (DDL/DML not supported)");
  it.todo("ALTER TABLE visits REPLACE PARTITION tuple(toYYYYMM(toDate('2019-01... (DDL/DML not supported)");
  it.todo("ALTER TABLE visits REPLACE PARTITION ID '201901' FROM visits_tmp (DDL/DML not supported)");
  it.todo("ALTER TABLE visits ON CLUSTER test_cluster DROP COLUMN col1 (DDL/DML not supported)");
  it.todo("ALTER TABLE visits ON CLUSTER '{cluster}' DROP COLUMN col1 (DDL/DML not supported)");
  it.todo("DELETE FROM tbl ON CLUSTER test_cluster WHERE date = '2019-01-01' (DDL/DML not supported)");
  it.todo("DELETE FROM tbl ON CLUSTER '{cluster}' WHERE date = '2019-01-01' (DDL/DML not supported)");
  it.todo("test_clickhouse: assertIsInstance call");
  it.todo("INSERT INTO t (col1, col2) VALUES ('abcd', 1234) (DDL/DML not supported)");
  it.todo("INSERT INTO t (col1, col2) VALUES ('abcd', 1234) (DDL/DML not supported) (2)");
  it.todo("SELECT TRIM(TRAILING ')' FROM '(   Hello, world!   )') (unsupported syntax)");
  it.todo("SELECT TRIM(LEADING '(' FROM '(   Hello, world!   )') (unsupported syntax)");
  it.todo("current_timestamp (assert_is check)");
  it("SELECT * APPLY(sum) FROM columns_transformers", () => {
    validateIdentity("SELECT * APPLY(sum) FROM columns_transformers");
  });
  it.todo("SELECT COLUMNS('[jk]') APPLY(toString) FROM columns_transformers (unsupported syntax)");
  it.todo("SELECT COLUMNS('[jk]') APPLY(toString) APPLY(length) APPLY(max) FRO... (unsupported syntax)");
  it.todo("SELECT * APPLY(sum), COLUMNS('col') APPLY(sum) APPLY(avg) FROM t (unsupported syntax)");
  it.todo("SELECT * FROM ABC WHERE hasAny(COLUMNS('.*field') APPLY(toUInt64) A... (unsupported syntax)");
  it("SELECT col apply -> SELECT col AS apply", () => {
    validateIdentity("SELECT col apply", "SELECT col AS apply");
  });
  it("SELECT name FROM data WHERE (SELECT DISTINCT name FROM data) IS NOT NULL -> SELECT name...", () => {
    validateIdentity("SELECT name FROM data WHERE (SELECT DISTINCT name FROM data) IS NOT NULL", "SELECT name FROM data WHERE NOT ((SELECT DISTINCT name FROM data) IS NULL)");
  });
  it("SELECT 1_2_3_4_5", () => {
    validateIdentity("SELECT 1_2_3_4_5");
  });
  it("SELECT 1_b -> SELECT 1_b", () => {
    validateIdentity("SELECT 1_b", "SELECT 1_b");
  });
  it("SELECT COUNT(1) FROM table SETTINGS additional_table_filters = {'a': 'b', 'c': 'd'}", () => {
    validateIdentity("SELECT COUNT(1) FROM table SETTINGS additional_table_filters = {'a': 'b', 'c': 'd'}");
  });
  it("SELECT arrayConcat([1, 2], [3, 4])", () => {
    validateIdentity("SELECT arrayConcat([1, 2], [3, 4])");
  });
  it("SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')", () => {
    validateIdentity("SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')");
  });
  it("SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s', 'Asia/Istanbul')", () => {
    validateIdentity("SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s', 'Asia/Istanbul')");
  });
  it("farmFingerprint64(x1, x2, x3)", () => {
    validateIdentity("farmFingerprint64(x1, x2, x3)");
  });
  it("cosineDistance(x, y)", () => {
    validateIdentity("cosineDistance(x, y)");
  });
  it("L2Distance(x, y)", () => {
    validateIdentity("L2Distance(x, y)");
  });
  it("tuple(1 = 1, 'foo' = 'foo')", () => {
    validateIdentity("tuple(1 = 1, 'foo' = 'foo')");
  });
  it("SELECT LIKE(a, b) -> SELECT a LIKE b", () => {
    validateIdentity("SELECT LIKE(a, b)", "SELECT a LIKE b");
  });
  it("SELECT notLike(a, b) -> SELECT NOT a LIKE b", () => {
    validateIdentity("SELECT notLike(a, b)", "SELECT NOT a LIKE b");
  });
  it("SELECT ilike(a, b) -> SELECT a ILIKE b", () => {
    validateIdentity("SELECT ilike(a, b)", "SELECT a ILIKE b");
  });
  it("currentDatabase() -> CURRENT_DATABASE()", () => {
    validateIdentity("currentDatabase()", "CURRENT_DATABASE()");
  });
  it("currentSchemas(TRUE) -> CURRENT_SCHEMAS(TRUE)", () => {
    validateIdentity("currentSchemas(TRUE)", "CURRENT_SCHEMAS(TRUE)");
  });
  it("VERSION()", () => {
    validateIdentity("VERSION()");
  });
  it("SELECT quantilesExactExclusive(0.25, 0.5, 0.75)(x) AS y FROM (SELECT number AS x FROM num)", () => {
    validateIdentity("SELECT quantilesExactExclusive(0.25, 0.5, 0.75)(x) AS y FROM (SELECT number AS x FROM num)");
  });
  it("SELECT or(0, 1, -2) -> SELECT 0 OR 1 OR -2", () => {
    validateIdentity("SELECT or(0, 1, -2)", "SELECT 0 OR 1 OR -2");
  });
  it("SELECT and(1, 2, 3) -> SELECT 1 AND 2 AND 3", () => {
    validateIdentity("SELECT and(1, 2, 3)", "SELECT 1 AND 2 AND 3");
  });
  it("SELECT or(and(3, 0), 5) -> SELECT (3 AND 0) OR 5", () => {
    validateIdentity("SELECT or(and(3, 0), 5)", "SELECT (3 AND 0) OR 5");
  });
});

describe("Clickhouse: clickhouse_values", () => {
  it.todo("test_clickhouse_values: assertEqual call");
  it.todo("test_clickhouse_values: assertEqual call (2)");
  it.todo("SELECT * FROM VALUES ((1, 1), (2, 1), (3, 1), (4, 1)) (unsupported syntax)");
  it.todo("SELECT type, id FROM VALUES ('id Int, type Int', (1, 1), (2, 1), (3... (unsupported syntax)");
  it.todo("INSERT INTO t (col1, col2) VALUES ('abcd', 1234) (DDL/DML not supported)");
  it.todo("INSERT INTO t (col1, col2) FORMAT Values('abcd', 1234) (DDL/DML not supported)");
  it.todo("duckdb -> clickhouse: SELECT col FROM (VALUES (1)) AS _t(col) (unsupported syntax)");
  it.todo("duckdb -> clickhouse: SELECT col1, col2 FROM (VALUES (1, 2), (3, 4)) AS _t(col1, col2) (unsupported syntax)");
});

describe("Clickhouse: cte", () => {
  it("WITH 'x' AS foo SELECT foo", () => {
    validateIdentity("WITH 'x' AS foo SELECT foo");
  });
  it("WITH ['c'] AS field_names SELECT field_names", () => {
    validateIdentity("WITH ['c'] AS field_names SELECT field_names");
  });
  it("WITH SUM(bytes) AS foo SELECT foo FROM system.parts", () => {
    validateIdentity("WITH SUM(bytes) AS foo SELECT foo FROM system.parts");
  });
  it("WITH (SELECT foo) AS bar SELECT bar + 5", () => {
    validateIdentity("WITH (SELECT foo) AS bar SELECT bar + 5");
  });
  it("WITH test1 AS (SELECT i + 1, j + 1 FROM test1) SELECT * FROM test1", () => {
    validateIdentity("WITH test1 AS (SELECT i + 1, j + 1 FROM test1) SELECT * FROM test1");
  });
  it.todo("test_cte: assertIsInstance call");
  it.todo("test_cte: assertEqual call");
  it.todo("test_cte: unresolvable for-loop iterable");
  it("arraySlice(x, 1)", () => {
    validateIdentity("arraySlice(x, 1)");
  });
});

describe("Clickhouse: ternary", () => {
  it("clickhouse -> clickhouse: x ? 1 : 2", () => {
    const result = transpile("x ? 1 : 2", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CASE WHEN x THEN 1 ELSE 2 END");
  });
  it("clickhouse -> clickhouse: IF(BAR(col), sign > 0 ? FOO() : 0, 1)", () => {
    const result = transpile("IF(BAR(col), sign > 0 ? FOO() : 0, 1)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CASE WHEN BAR(col) THEN CASE WHEN sign > 0 THEN FOO() ELSE 0 END ELSE 1 END");
  });
  it("clickhouse -> clickhouse: x AND FOO() > 3 + 2 ? 1 : 2", () => {
    const result = transpile("x AND FOO() > 3 + 2 ? 1 : 2", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CASE WHEN x AND FOO() > 3 + 2 THEN 1 ELSE 2 END");
  });
  it("clickhouse -> clickhouse: x ? (y ? 1 : 2) : 3", () => {
    const result = transpile("x ? (y ? 1 : 2) : 3", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CASE WHEN x THEN (CASE WHEN y THEN 1 ELSE 2 END) ELSE 3 END");
  });
  it("clickhouse -> clickhouse: x AND (foo() ? FALSE : TRUE) ? (y ? 1 : 2) : 3", () => {
    const result = transpile("x AND (foo() ? FALSE : TRUE) ? (y ? 1 : 2) : 3", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("CASE WHEN x AND (CASE WHEN foo() THEN FALSE ELSE TRUE END) THEN (CASE WHEN y THEN 1 ELSE 2 END) ELSE 3 END");
  });
  it.todo("test_ternary: assertIsInstance call");
  it.todo("test_ternary: assertIsInstance call (2)");
  it.todo("test_ternary: assertIsInstance call (3)");
  it.todo("test_ternary: assertIsInstance call (4)");
  it.todo("test_ternary: assertIsInstance call (5)");
  it.todo("test_ternary: assertIsInstance call (6)");
  it.todo("test_ternary: assertIsInstance call (7)");
});

describe("Clickhouse: parameterization", () => {
  it.todo("SELECT {abc: UInt32}, {b: String}, {c: DateTime},{d: Map(String, Ar... (unsupported syntax)");
  it("clickhouse -> clickhouse: SELECT * FROM {table: Identifier}", () => {
    const result = transpile("SELECT * FROM {table: Identifier}", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT * FROM {table: Identifier}");
  });
});

describe("Clickhouse: signed_and_unsigned_types", () => {
  it.todo("test_signed_and_unsigned_types: unresolvable for-loop iterable");
});

describe("Clickhouse: geom_types", () => {
  it.todo("test_geom_types: unresolvable for-loop iterable");
});

describe("Clickhouse: nothing_type", () => {
  it.todo("test_nothing_type: unresolvable for-loop iterable");
});

describe("Clickhouse: aggregate_function_column_with_any_keyword", () => {
  it.todo("\n            CREATE TABLE my_db.my_table\n            (\n            ... (pretty=True not supported)");
});

describe("Clickhouse: create_table_as_alias", () => {
  it.todo("test_create_table_as_alias: assertEqual call");
  it.todo("test_create_table_as_alias: unresolvable SQL string");
});

describe("Clickhouse: ddl", () => {
  it.todo("test_ddl: assertEqual call");
  it.todo("test_ddl: assertEqual call (2)");
  it.todo("test_ddl: assertEqual call (3)");
  it.todo("CREATE FUNCTION linear_equation AS (x, k, b) -> k * x + b (DDL/DML not supported)");
  it.todo("CREATE MATERIALIZED VIEW a.b TO a.c (c Int32) AS SELECT * FROM a.d (DDL/DML not supported)");
  it.todo("CREATE TABLE ip_data (ip4 IPv4, ip6 IPv6) ENGINE=TinyLog() (DDL/DML not supported)");
  it.todo("CREATE TABLE dates (dt1 Date32) ENGINE=TinyLog() (DDL/DML not supported)");
  it.todo("CREATE TABLE named_tuples (a Tuple(select String, i Int64)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (a String) EMPTY AS SELECT * FROM dummy (DDL/DML not supported)");
  it.todo("CREATE TABLE t1 (a String EPHEMERAL, b String EPHEMERAL func(), c S... (DDL/DML not supported)");
  it.todo("CREATE TABLE t (a String, b String, c UInt64, PROJECTION p1 (SELECT... (DDL/DML not supported)");
  it.todo("CREATE TABLE xyz (ts DateTime, data String) ENGINE=MergeTree() ORDE... (DDL/DML not supported)");
  it.todo("INSERT INTO FUNCTION s3('a', 'b', 'c', 'd', 'e') PARTITION BY CONCA... (DDL/DML not supported)");
  it.todo('CREATE TABLE data5 ("x" UInt32, "y" UInt32) ENGINE=MergeTree ORDER ... (DDL/DML not supported)');
  it.todo("CREATE TABLE foo (x UInt32) TTL time_column + INTERVAL '1' MONTH DE... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION parity_str AS (n) -> IF(n % 2, 'odd', 'even') (DDL/DML not supported)");
  it.todo("CREATE TABLE a ENGINE=Memory AS SELECT 1 AS c COMMENT 'foo' (DDL/DML not supported)");
  it.todo('CREATE TABLE t1 ("x" UInt32, "y" Dynamic, "z" Dynamic(max_types = 1... (DDL/DML not supported)');
  it.todo("CREATE TABLE test_table (id Int32, name String) ENGINE=MergeTree PR... (DDL/DML not supported)");
  it.todo("CREATE TABLE test_table (id Int32, name String) ENGINE=MergeTree PR... (DDL/DML not supported) (2)");
  it.todo("CREATE DATABASE x (DDL/DML not supported)");
  it.todo("DROP DATABASE x (DDL/DML not supported)");
  it.todo("\n            CREATE TABLE example1 (\n               timestamp DateT... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE test (id UInt64, timestamp DateTime64, da... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE test (id String, data String) ENGINE = Ag... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE example_table\n            (\n             ... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE table_with_where\n            (\n          ... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE table_for_recompression\n            (\n   ... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE table_for_aggregation\n            (\n     ... (pretty=True not supported)");
  it.todo("\n            CREATE DICTIONARY discounts_dict (\n                adv... (pretty=True not supported)");
  it.todo("\n            CREATE DICTIONARY my_ip_trie_dictionary (\n            ... (pretty=True not supported)");
  it.todo("\n            CREATE DICTIONARY polygons_test_dictionary\n           ... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE t (\n                a AggregateFunction(q... (pretty=True not supported)");
  it.todo("test_ddl: assertIsNotNone call");
  it.todo("\n            CREATE TABLE session_log\n            (\n               ... (pretty=True not supported)");
  it.todo("\n            CREATE TABLE visits\n            (\n                Visi... (pretty=True not supported)");
});

describe("Clickhouse: agg_functions", () => {
  it.todo("test_agg_functions: assertIsInstance call");
  it.todo("test_agg_functions: assertIsInstance call (2)");
  it.todo("test_agg_functions: assertIsInstance call (3)");
  it.todo("test_agg_functions: assertIsInstance call (4)");
});

describe("Clickhouse: drop_on_cluster", () => {
  it.todo("DROP DATABASE test ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("DROP DATABASE test ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("DROP TABLE test ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("DROP TABLE test ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("DROP VIEW test ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("DROP VIEW test ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("DROP DICTIONARY test ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("DROP DICTIONARY test ON CLUSTER '{cluster}' (DDL/DML not supported)");
  it.todo("DROP FUNCTION test ON CLUSTER test_cluster (DDL/DML not supported)");
  it.todo("DROP FUNCTION test ON CLUSTER '{cluster}' (DDL/DML not supported)");
});

describe("Clickhouse: datetime_funcs", () => {
  it.todo("test_datetime_funcs: unresolvable for-loop iterable");
  it.todo("test_datetime_funcs: unresolvable for-loop iterable (2)");
  it.todo("test_datetime_funcs: unresolvable for-loop iterable (3)");
});

describe("Clickhouse: convert", () => {
  it.todo("test_convert: assertEqual call");
  it.todo("test_convert: assertEqual call (2)");
  it.todo("test_convert: assertEqual call (3)");
  it.todo("test_convert: assertEqual call (4)");
  it.todo("test_convert: assertEqual call (5)");
});

describe("Clickhouse: timestr_to_time", () => {
  it.todo("test_timestr_to_time: unresolvable for-loop iterable");
  it.todo("test_timestr_to_time: unresolvable for-loop iterable (2)");
});

describe("Clickhouse: grant", () => {
  it.todo("GRANT SELECT(x, y) ON db.table TO john WITH GRANT OPTION (command not supported)");
  it.todo("GRANT INSERT(x, y) ON db.table TO john (command not supported)");
});

describe("Clickhouse: revoke", () => {
  it.todo("REVOKE SELECT(x, y) ON db.table FROM john (command not supported)");
  it.todo("REVOKE INSERT(x, y) ON db.table FROM john (command not supported)");
});

describe("Clickhouse: array_join", () => {
  it.todo("test_array_join: assertEqual call");
  it.todo("test_array_join: assertEqual call (2)");
  it.todo("test_array_join: assertIsInstance call");
  it.todo("test_array_join: assertEqual call (3)");
  it.todo("test_array_join: assertIsInstance call (2)");
  it.todo("test_array_join: assertIsInstance call (3)");
  it.todo("test_array_join: assertIsInstance call (4)");
  it.todo("test_array_join: assertIsInstance call (5)");
  it("SELECT s, arr FROM arrays_test ARRAY JOIN arr", () => {
    validateIdentity("SELECT s, arr FROM arrays_test ARRAY JOIN arr");
  });
  it("SELECT s, arr, a FROM arrays_test LEFT ARRAY JOIN arr AS a", () => {
    validateIdentity("SELECT s, arr, a FROM arrays_test LEFT ARRAY JOIN arr AS a");
  });
  it("SELECT s, arr_external FROM arrays_test ARRAY JOIN [1, 2, 3] AS arr_external", () => {
    validateIdentity("SELECT s, arr_external FROM arrays_test ARRAY JOIN [1, 2, 3] AS arr_external");
  });
  it("SELECT * FROM arrays_test ARRAY JOIN [1, 2, 3] AS arr_external1, ['a', 'b', 'c'] AS arr...", () => {
    validateIdentity("SELECT * FROM arrays_test ARRAY JOIN [1, 2, 3] AS arr_external1, ['a', 'b', 'c'] AS arr_external2, splitByString(',', 'asd,qwerty,zxc') AS arr_external3");
  });
});

describe("Clickhouse: traverse_scope", () => {
  it.todo("test_traverse_scope: assertEqual call");
  it.todo("test_traverse_scope: assertEqual call (2)");
});

describe("Clickhouse: window_functions", () => {
  it("SELECT row_number(column1) OVER (PARTITION BY column2 ORDER BY column3) FROM table", () => {
    validateIdentity("SELECT row_number(column1) OVER (PARTITION BY column2 ORDER BY column3) FROM table");
  });
  it("SELECT row_number() OVER (PARTITION BY column2 ORDER BY column3) FROM table", () => {
    validateIdentity("SELECT row_number() OVER (PARTITION BY column2 ORDER BY column3) FROM table");
  });
});

describe("Clickhouse: functions", () => {
  it("SELECT TRANSFORM(foo, [1, 2], ['first', 'second']) FROM table", () => {
    validateIdentity("SELECT TRANSFORM(foo, [1, 2], ['first', 'second']) FROM table");
  });
  it("SELECT TRANSFORM(foo, [1, 2], ['first', 'second'], 'default') FROM table", () => {
    validateIdentity("SELECT TRANSFORM(foo, [1, 2], ['first', 'second'], 'default') FROM table");
  });
});

describe("Clickhouse: array_offset", () => {
  it.todo("SELECT col[1] (unsupported syntax)");
  it.todo("test_array_offset: assertEqual call");
});

describe("Clickhouse: to_start_of", () => {
  it.todo("clickhouse -> databricks: toStartOfSECOND(x) (cross-dialect transform)");
  it.todo("clickhouse -> duckdb: toStartOfSECOND(x) (cross-dialect transform)");
  it.todo("clickhouse -> doris: toStartOfSECOND(x) (cross-dialect transform)");
  it.todo("clickhouse -> presto: toStartOfSECOND(x) (cross-dialect transform)");
  it.todo("clickhouse -> spark: toStartOfSECOND(x) (cross-dialect transform)");
  it.todo("clickhouse -> databricks: toStartOfDAY(x) (cross-dialect transform)");
  it.todo("clickhouse -> duckdb: toStartOfDAY(x) (cross-dialect transform)");
  it.todo("clickhouse -> doris: toStartOfDAY(x) (cross-dialect transform)");
  it.todo("clickhouse -> presto: toStartOfDAY(x) (cross-dialect transform)");
  it.todo("clickhouse -> spark: toStartOfDAY(x) (cross-dialect transform)");
  it.todo("clickhouse -> databricks: toStartOfYEAR(x) (cross-dialect transform)");
  it.todo("clickhouse -> duckdb: toStartOfYEAR(x) (cross-dialect transform)");
  it.todo("clickhouse -> doris: toStartOfYEAR(x) (cross-dialect transform)");
  it.todo("clickhouse -> presto: toStartOfYEAR(x) (cross-dialect transform)");
  it.todo("clickhouse -> spark: toStartOfYEAR(x) (cross-dialect transform)");
  it.todo("clickhouse -> databricks: toMonday(x) (cross-dialect transform)");
  it.todo("clickhouse -> duckdb: toMonday(x) (cross-dialect transform)");
  it.todo("clickhouse -> doris: toMonday(x) (cross-dialect transform)");
  it.todo("clickhouse -> presto: toMonday(x) (cross-dialect transform)");
  it.todo("clickhouse -> spark: toMonday(x) (cross-dialect transform)");
});

describe("Clickhouse: string_split", () => {
  it.todo("bigquery -> clickhouse: SPLIT(x, 's') (cross-dialect transform)");
  it.todo("duckdb -> clickhouse: STRING_SPLIT(x, 's') (cross-dialect transform)");
  it("clickhouse -> clickhouse: splitByString('s', x)", () => {
    const result = transpile("splitByString('s', x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("splitByString('s', x)");
  });
  it.todo("clickhouse -> doris: splitByString('s', x) (cross-dialect transform)");
  it.todo("clickhouse -> duckdb: splitByString('s', x) (cross-dialect transform)");
  it.todo("clickhouse -> hive: splitByString('s', x) (unsupported syntax)");
  it.todo("duckdb -> clickhouse: STRING_SPLIT_REGEX(x, '\\d+') (cross-dialect transform)");
  it.todo("hive -> clickhouse: SPLIT(x, '\\\\d+') (cross-dialect transform)");
  it("clickhouse -> clickhouse: splitByRegexp('\\\\d+', x)", () => {
    const result = transpile("splitByRegexp('\\\\d+', x)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("splitByRegexp('\\\\d+', x)");
  });
  it.todo("clickhouse -> duckdb: splitByRegexp('\\\\d+', x) (cross-dialect transform)");
  it.todo("clickhouse -> hive: splitByRegexp('\\\\d+', x) (cross-dialect transform)");
  it("splitByChar('', x)", () => {
    validateIdentity("splitByChar('', x)");
  });
});
