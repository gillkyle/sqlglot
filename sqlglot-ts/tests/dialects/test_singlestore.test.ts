// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "singlestore";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Singlestore: singlestore", () => {
  it.todo("test_singlestore: assertEqual call");
  it("SELECT 1", () => {
    validateIdentity("SELECT 1");
  });
  it("SELECT * FROM `users` ORDER BY ALL", () => {
    validateIdentity("SELECT * FROM `users` ORDER BY ALL");
  });
  it("SELECT ELT(2, 'foo', 'bar', 'baz')", () => {
    validateIdentity("SELECT ELT(2, 'foo', 'bar', 'baz')");
  });
  it.todo("SELECT CHARSET(CHAR(100 USING utf8)) (unsupported syntax)");
  it("SELECT TO_JSON(ROW(1, 2) :> RECORD(a INT, b INT))", () => {
    validateIdentity("SELECT TO_JSON(ROW(1, 2) :> RECORD(a INT, b INT))");
  });
  it("JSON_KEYS(json_doc, 'a', 'b', 'c', 2)", () => {
    validateIdentity("JSON_KEYS(json_doc, 'a', 'b', 'c', 2)");
  });
  it("SELECT VERSION()", () => {
    validateIdentity("SELECT VERSION()");
  });
  it.todo("SELECT CURTIME() (unsupported syntax)");
});

describe("Singlestore: byte_strings", () => {
  it.todo("SELECT e'text' (unsupported syntax)");
  it.todo("SELECT E'text' (unsupported syntax)");
});

describe("Singlestore: national_strings", () => {
  it.todo(" -> singlestore: SELECT N'text' (unsupported syntax)");
  it("singlestore -> singlestore: SELECT 'text'", () => {
    const result = transpile("SELECT 'text'", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 'text'");
  });
});

describe("Singlestore: restricted_keywords", () => {
  it("SELECT * FROM abs -> SELECT * FROM `abs`", () => {
    validateIdentity("SELECT * FROM abs", "SELECT * FROM `abs`");
  });
  it("SELECT * FROM ABS -> SELECT * FROM `ABS`", () => {
    validateIdentity("SELECT * FROM ABS", "SELECT * FROM `ABS`");
  });
  it("SELECT * FROM security_lists_intersect -> SELECT * FROM `security_lists_intersect`", () => {
    validateIdentity("SELECT * FROM security_lists_intersect", "SELECT * FROM `security_lists_intersect`");
  });
  it("SELECT * FROM vacuum -> SELECT * FROM `vacuum`", () => {
    validateIdentity("SELECT * FROM vacuum", "SELECT * FROM `vacuum`");
  });
});

describe("Singlestore: time_formatting", () => {
  it("SELECT STR_TO_DATE('March 3rd, 2015', '%M %D, %Y')", () => {
    validateIdentity("SELECT STR_TO_DATE('March 3rd, 2015', '%M %D, %Y')");
  });
  it.todo("SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %h:%i:%s') (unsupported syntax)");
  it("SELECT TO_DATE('03/01/2019', 'MM/DD/YYYY') AS `result`", () => {
    validateIdentity("SELECT TO_DATE('03/01/2019', 'MM/DD/YYYY') AS `result`");
  });
  it("SELECT TO_TIMESTAMP('The date and time are 01/01/2018 2:30:15.123456', 'The date and ti...", () => {
    validateIdentity("SELECT TO_TIMESTAMP('The date and time are 01/01/2018 2:30:15.123456', 'The date and time are MM/DD/YYYY HH12:MI:SS.FF6') AS `result`");
  });
  it("SELECT TO_CHAR('2018-03-01', 'MM/DD')", () => {
    validateIdentity("SELECT TO_CHAR('2018-03-01', 'MM/DD')");
  });
  it("SELECT TIME_FORMAT('12:05:47', '%s, %i, %h') -> SELECT DATE_FORMAT('12:05:47' :> TIME(6...", () => {
    validateIdentity("SELECT TIME_FORMAT('12:05:47', '%s, %i, %h')", "SELECT DATE_FORMAT('12:05:47' :> TIME(6), '%s, %i, %h')");
  });
  it("SELECT DATE('2019-01-01 05:06')", () => {
    validateIdentity("SELECT DATE('2019-01-01 05:06')");
  });
  it.todo(" -> singlestore: SELECT TS_OR_DS_TO_DATE('2019-01-01 05:06') (unsupported syntax)");
  it("singlestore -> singlestore: SELECT DATE('2019-01-01 05:06')", () => {
    const result = transpile("SELECT DATE('2019-01-01 05:06')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE('2019-01-01 05:06')");
  });
});

describe("Singlestore: cast", () => {
  it(" -> singlestore: SELECT CAST(1 AS INT)", () => {
    const result = transpile("SELECT CAST(1 AS INT)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 1 :> INT");
  });
  it("singlestore -> singlestore: SELECT 1 :> INT", () => {
    const result = transpile("SELECT 1 :> INT", { readDialect: DIALECT, writeDialect: "singlestore" })[0];
    expect(result).toBe("SELECT 1 :> INT");
  });
  it("singlestore -> : SELECT 1 :> INT", () => {
    const result = transpile("SELECT 1 :> INT", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CAST(1 AS INT)");
  });
  it(" -> singlestore: SELECT TRY_CAST(1 AS INT)", () => {
    const result = transpile("SELECT TRY_CAST(1 AS INT)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 1 !:> INT");
  });
  it("singlestore -> singlestore: SELECT 1 !:> INT", () => {
    const result = transpile("SELECT 1 !:> INT", { readDialect: DIALECT, writeDialect: "singlestore" })[0];
    expect(result).toBe("SELECT 1 !:> INT");
  });
  it("singlestore -> : SELECT 1 !:> INT", () => {
    const result = transpile("SELECT 1 !:> INT", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT TRY_CAST(1 AS INT)");
  });
  it(`SELECT '{"a" : 1}' :> JSON`, () => {
    validateIdentity(`SELECT '{"a" : 1}' :> JSON`);
  });
  it.todo("SELECT NOW() !:> TIMESTAMP(6) (unsupported syntax)");
  it("SELECT x :> GEOGRAPHYPOINT", () => {
    validateIdentity("SELECT x :> GEOGRAPHYPOINT");
  });
  it(" -> singlestore: SELECT CAST(age, 'TEXT') FROM users", () => {
    const result = transpile("SELECT CAST(age, 'TEXT') FROM users", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT age :> TEXT FROM `users`");
  });
  it("singlestore -> singlestore: SELECT age :> TEXT FROM `users`", () => {
    const result = transpile("SELECT age :> TEXT FROM `users`", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT age :> TEXT FROM `users`");
  });
});

describe("Singlestore: unix_functions", () => {
  it("SELECT FROM_UNIXTIME(1234567890)", () => {
    validateIdentity("SELECT FROM_UNIXTIME(1234567890)");
  });
  it("SELECT FROM_UNIXTIME(1234567890, '%M %D, %Y')", () => {
    validateIdentity("SELECT FROM_UNIXTIME(1234567890, '%M %D, %Y')");
  });
  it("SELECT UNIX_TIMESTAMP()", () => {
    validateIdentity("SELECT UNIX_TIMESTAMP()");
  });
  it("SELECT UNIX_TIMESTAMP('2009-02-13 23:31:30') AS funday", () => {
    validateIdentity("SELECT UNIX_TIMESTAMP('2009-02-13 23:31:30') AS funday");
  });
  it("duckdb -> singlestore: SELECT EPOCH('2009-02-13 23:31:30')", () => {
    const result = transpile("SELECT EPOCH('2009-02-13 23:31:30')", { readDialect: "duckdb", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_TIMESTAMP('2009-02-13 23:31:30')");
  });
  it.todo("duckdb -> singlestore: SELECT TIME_STR_TO_UNIX('2009-02-13 23:31:30') (unsupported syntax)");
  it.todo(" -> singlestore: SELECT TIME_STR_TO_UNIX('2009-02-13 23:31:30') (unsupported syntax)");
  it(" -> singlestore: SELECT UNIX_SECONDS('2009-02-13 23:31:30')", () => {
    const result = transpile("SELECT UNIX_SECONDS('2009-02-13 23:31:30')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNIX_TIMESTAMP('2009-02-13 23:31:30')");
  });
  it.todo("hive -> singlestore: SELECT FROM_UNIXTIME(1234567890) (cross-dialect transform)");
  it(" -> singlestore: SELECT UNIX_TO_TIME_STR(1234567890)", () => {
    const result = transpile("SELECT UNIX_TO_TIME_STR(1234567890)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT FROM_UNIXTIME(1234567890) :> TEXT");
  });
});

describe("Singlestore: json_extract", () => {
  it.todo("SELECT a::b FROM t (unsupported syntax)");
  it.todo("SELECT a::b FROM t (unsupported syntax) (2)");
  it("SELECT a::$b FROM t -> SELECT JSON_EXTRACT_STRING(a, 'b') FROM t", () => {
    validateIdentity("SELECT a::$b FROM t", "SELECT JSON_EXTRACT_STRING(a, 'b') FROM t");
  });
  it("SELECT a::%b FROM t -> SELECT JSON_EXTRACT_DOUBLE(a, 'b') FROM t", () => {
    validateIdentity("SELECT a::%b FROM t", "SELECT JSON_EXTRACT_DOUBLE(a, 'b') FROM t");
  });
  it("SELECT a::`b`::`2` FROM t -> SELECT JSON_EXTRACT_JSON(JSON_EXTRACT_JSON(a, 'b'), '2') F...", () => {
    validateIdentity("SELECT a::`b`::`2` FROM t", "SELECT JSON_EXTRACT_JSON(JSON_EXTRACT_JSON(a, 'b'), '2') FROM t");
  });
  it.todo("SELECT a::2 FROM t (unsupported syntax)");
  it("mysql -> singlestore: SELECT JSON_EXTRACT(a, '$.b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT(a, '$.b') FROM t", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_JSON(a, 'b') FROM t");
  });
  it("singlestore -> singlestore: SELECT JSON_EXTRACT_JSON(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_JSON(a, 'b') FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_JSON(a, 'b') FROM t");
  });
  it("singlestore -> mysql: SELECT JSON_EXTRACT_JSON(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_JSON(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT(a, '$.b') FROM t");
  });
  it("singlestore -> : SELECT JSON_EXTRACT_STRING(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_STRING(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(a, '$.b', STRING) FROM t");
  });
  it("singlestore -> : SELECT JSON_EXTRACT_DOUBLE(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_DOUBLE(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(a, '$.b', DOUBLE) FROM t");
  });
  it("singlestore -> : SELECT JSON_EXTRACT_BIGINT(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_BIGINT(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(a, '$.b', BIGINT) FROM t");
  });
  it("singlestore -> : SELECT JSON_EXTRACT_BIGINT(a, 'b') FROM t (2)", () => {
    const result = transpile("SELECT JSON_EXTRACT_BIGINT(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(a, '$.b', BIGINT) FROM t");
  });
  it("mysql -> singlestore: SELECT JSON_EXTRACT(a, '$.b[2]') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT(a, '$.b[2]') FROM t", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t");
  });
  it("singlestore -> singlestore: SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t");
  });
  it("singlestore -> mysql: SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_JSON(a, 'b', '2') FROM t", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT(a, '$.b[2]') FROM t");
  });
  it("singlestore -> : SELECT JSON_EXTRACT_STRING(a, 'b', 2) FROM t", () => {
    const result = transpile("SELECT JSON_EXTRACT_STRING(a, 'b', 2) FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSON_EXTRACT_SCALAR(a, '$.b[2]', STRING) FROM t");
  });
  it("mysql -> singlestore: SELECT JSONB_EXTRACT(a, 'b') FROM t", () => {
    const result = transpile("SELECT JSONB_EXTRACT(a, 'b') FROM t", { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BSON_EXTRACT_BSON(a, 'b') FROM t");
  });
  it("singlestore -> singlestore: SELECT BSON_EXTRACT_BSON(a, 'b') FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_BSON(a, 'b') FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT BSON_EXTRACT_BSON(a, 'b') FROM t");
  });
  it("singlestore -> mysql: SELECT BSON_EXTRACT_BSON(a, 'b') FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_BSON(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT(a, '$.b') FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_STRING(a, 'b') FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_STRING(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT_SCALAR(a, '$.b', STRING) FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_DOUBLE(a, 'b') FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_DOUBLE(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT_SCALAR(a, '$.b', DOUBLE) FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_BIGINT(a, 'b') FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_BIGINT(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT_SCALAR(a, '$.b', BIGINT) FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_BIGINT(a, 'b') FROM t (2)", () => {
    const result = transpile("SELECT BSON_EXTRACT_BIGINT(a, 'b') FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT_SCALAR(a, '$.b', BIGINT) FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_BSON(a, 'b', 2) FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_BSON(a, 'b', 2) FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT(a, '$.b[2]') FROM t");
  });
  it("singlestore -> : SELECT BSON_EXTRACT_STRING(a, 'b', 2) FROM t", () => {
    const result = transpile("SELECT BSON_EXTRACT_STRING(a, 'b', 2) FROM t", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT JSONB_EXTRACT_SCALAR(a, '$.b[2]', STRING) FROM t");
  });
  it(`mysql -> singlestore: SELECT JSON_VALUE('{"item": "shoes", "price": "49.95"}', '$.price...`, () => {
    const result = transpile(`SELECT JSON_VALUE('{"item": "shoes", "price": "49.95"}', '$.price' RETURNING DECIMAL(4, 2))`, { readDialect: "mysql", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT JSON_EXTRACT_STRING('{"item": "shoes", "price": "49.95"}', 'price') :> DECIMAL(4, 2)`);
  });
});

describe("Singlestore: json", () => {
  it(`SELECT JSON_ARRAY_CONTAINS_STRING('["a", "b"]', 'b')`, () => {
    validateIdentity(`SELECT JSON_ARRAY_CONTAINS_STRING('["a", "b"]', 'b')`);
  });
  it("SELECT JSON_ARRAY_CONTAINS_DOUBLE('[1, 2]', 1)", () => {
    validateIdentity("SELECT JSON_ARRAY_CONTAINS_DOUBLE('[1, 2]', 1)");
  });
  it(`SELECT JSON_ARRAY_CONTAINS_JSON('["{"a": 1}"]', '{"a":   1}')`, () => {
    validateIdentity(`SELECT JSON_ARRAY_CONTAINS_JSON('["{"a": 1}"]', '{"a":   1}')`);
  });
  it.todo(`mysql -> singlestore: SELECT 'a' MEMBER OF ('["a"]') (unsupported syntax)`);
  it(`singlestore -> singlestore: SELECT JSON_ARRAY_CONTAINS_JSON('["a"]', TO_JSON('a'))`, () => {
    const result = transpile(`SELECT JSON_ARRAY_CONTAINS_JSON('["a"]', TO_JSON('a'))`, { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT JSON_ARRAY_CONTAINS_JSON('["a"]', TO_JSON('a'))`);
  });
  it(`singlestore -> singlestore: SELECT JSON_PRETTY('["G","alpha","20",10]')`, () => {
    const result = transpile(`SELECT JSON_PRETTY('["G","alpha","20",10]')`, { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT JSON_PRETTY('["G","alpha","20",10]')`);
  });
  it(` -> singlestore: SELECT JSON_FORMAT('["G","alpha","20",10]')`, () => {
    const result = transpile(`SELECT JSON_FORMAT('["G","alpha","20",10]')`, { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT JSON_PRETTY('["G","alpha","20",10]')`);
  });
  it.todo("SELECT JSON_AGG(name ORDER BY id ASC NULLS LAST, name DESC NULLS FI... (unsupported syntax)");
  it.todo("SELECT JSON_AGG(name) FROM t (unsupported syntax)");
  it.todo("SELECT JSON_AGG(t.*) FROM t (unsupported syntax)");
  it.todo("SELECT JSON_BUILD_ARRAY(id, name) FROM t (unsupported syntax)");
  it.todo("JSON_BUILD_ARRAY(id, name) (assert_is check)");
  it(`singlestore -> singlestore: SELECT BSON_MATCH_ANY_EXISTS('{"x":true}', 'x')`, () => {
    const result = transpile(`SELECT BSON_MATCH_ANY_EXISTS('{"x":true}', 'x')`, { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT BSON_MATCH_ANY_EXISTS('{"x":true}', 'x')`);
  });
  it.todo(` -> singlestore: SELECT JSONB_EXISTS('{"x":true}', 'x') (cross-dialect transform)`);
  it(`singlestore -> singlestore: SELECT JSON_MATCH_ANY_EXISTS('{"a":1}', 'a')`, () => {
    const result = transpile(`SELECT JSON_MATCH_ANY_EXISTS('{"a":1}', 'a')`, { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe(`SELECT JSON_MATCH_ANY_EXISTS('{"a":1}', 'a')`);
  });
  it.todo(`oracle -> singlestore: SELECT JSON_EXISTS('{"a":1}', '$.a') (cross-dialect transform)`);
  it("singlestore -> singlestore: SELECT JSON_BUILD_OBJECT('name', name) FROM t", () => {
    const result = transpile("SELECT JSON_BUILD_OBJECT('name', name) FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_BUILD_OBJECT('name', name) FROM t");
  });
  it(" -> singlestore: SELECT JSON_OBJECT('name', name) FROM t", () => {
    const result = transpile("SELECT JSON_OBJECT('name', name) FROM t", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT JSON_BUILD_OBJECT('name', name) FROM t");
  });
  it.todo("JSON_BUILD_OBJECT('name', name) (assert_is check)");
});

describe("Singlestore: date_parts_functions", () => {
  it("SELECT DAYNAME('2014-04-18') -> SELECT DATE_FORMAT('2014-04-18', '%W')", () => {
    validateIdentity("SELECT DAYNAME('2014-04-18')", "SELECT DATE_FORMAT('2014-04-18', '%W')");
  });
  it("SELECT HOUR('2009-02-13 23:31:30') -> SELECT DATE_FORMAT('2009-02-13 23:31:30' :> TIME(...", () => {
    validateIdentity("SELECT HOUR('2009-02-13 23:31:30')", "SELECT DATE_FORMAT('2009-02-13 23:31:30' :> TIME(6), '%k') :> INT");
  });
  it("SELECT MICROSECOND('2009-02-13 23:31:30.123456') -> SELECT DATE_FORMAT('2009-02-13 23:3...", () => {
    validateIdentity("SELECT MICROSECOND('2009-02-13 23:31:30.123456')", "SELECT DATE_FORMAT('2009-02-13 23:31:30.123456' :> TIME(6), '%f') :> INT");
  });
  it("SELECT SECOND('2009-02-13 23:31:30.123456') -> SELECT DATE_FORMAT('2009-02-13 23:31:30....", () => {
    validateIdentity("SELECT SECOND('2009-02-13 23:31:30.123456')", "SELECT DATE_FORMAT('2009-02-13 23:31:30.123456' :> TIME(6), '%s') :> INT");
  });
  it.todo("SELECT MONTHNAME('2014-04-18') (unsupported syntax)");
  it("SELECT WEEKDAY('2014-04-18') -> SELECT (DAYOFWEEK('2014-04-18') + 5) % 7", () => {
    validateIdentity("SELECT WEEKDAY('2014-04-18')", "SELECT (DAYOFWEEK('2014-04-18') + 5) % 7");
  });
  it("SELECT MINUTE('2009-02-13 23:31:30.123456') -> SELECT DATE_FORMAT('2009-02-13 23:31:30....", () => {
    validateIdentity("SELECT MINUTE('2009-02-13 23:31:30.123456')", "SELECT DATE_FORMAT('2009-02-13 23:31:30.123456' :> TIME(6), '%i') :> INT");
  });
  it("singlestore -> singlestore: SELECT ((DAYOFWEEK('2014-04-18') % 7) + 1)", () => {
    const result = transpile("SELECT ((DAYOFWEEK('2014-04-18') % 7) + 1)", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ((DAYOFWEEK('2014-04-18') % 7) + 1)");
  });
  it(" -> singlestore: SELECT DAYOFWEEK_ISO('2014-04-18')", () => {
    const result = transpile("SELECT DAYOFWEEK_ISO('2014-04-18')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ((DAYOFWEEK('2014-04-18') % 7) + 1)");
  });
  it("singlestore -> singlestore: SELECT DAY('2014-04-18')", () => {
    const result = transpile("SELECT DAY('2014-04-18')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DAY('2014-04-18')");
  });
  it(" -> singlestore: SELECT DAY_OF_MONTH('2014-04-18')", () => {
    const result = transpile("SELECT DAY_OF_MONTH('2014-04-18')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DAY('2014-04-18')");
  });
});

describe("Singlestore: math_functions", () => {
  it("singlestore -> singlestore: SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_a...", () => {
    const result = transpile("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets");
  });
  it(" -> singlestore: SELECT HLL(asset_id) AS approx_distinct_asset_id FROM acd_assets", () => {
    const result = transpile("SELECT HLL(asset_id) AS approx_distinct_asset_id FROM acd_assets", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets");
  });
  it("SELECT APPROX_COUNT_DISTINCT(asset_id1, asset_id2) AS approx_distinct_asset_id FROM acd...", () => {
    validateIdentity("SELECT APPROX_COUNT_DISTINCT(asset_id1, asset_id2) AS approx_distinct_asset_id FROM acd_assets");
  });
  it("singlestore -> singlestore: SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_a... (2)", () => {
    const result = transpile("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets");
  });
  it(" -> singlestore: SELECT APPROX_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_...", () => {
    const result = transpile("SELECT APPROX_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_COUNT_DISTINCT(asset_id) AS approx_distinct_asset_id FROM acd_assets");
  });
  it("singlestore -> singlestore: SELECT SUM(CASE WHEN age > 18 THEN 1 ELSE 0 END) FROM `users`", () => {
    const result = transpile("SELECT SUM(CASE WHEN age > 18 THEN 1 ELSE 0 END) FROM `users`", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SUM(CASE WHEN age > 18 THEN 1 ELSE 0 END) FROM `users`");
  });
  it(" -> singlestore: SELECT COUNT_IF(age > 18) FROM users", () => {
    const result = transpile("SELECT COUNT_IF(age > 18) FROM users", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SUM(CASE WHEN age > 18 THEN 1 ELSE 0 END) FROM `users`");
  });
  it("singlestore -> singlestore: SELECT MAX(ABS(age > 18)) FROM `users`", () => {
    const result = transpile("SELECT MAX(ABS(age > 18)) FROM `users`", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MAX(ABS(age > 18)) FROM `users`");
  });
  it.todo(" -> singlestore: SELECT LOGICAL_OR(age > 18) FROM users (cross-dialect transform)");
  it("singlestore -> singlestore: SELECT MIN(ABS(age > 18)) FROM `users`", () => {
    const result = transpile("SELECT MIN(ABS(age > 18)) FROM `users`", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MIN(ABS(age > 18)) FROM `users`");
  });
  it(" -> singlestore: SELECT LOGICAL_AND(age > 18) FROM users", () => {
    const result = transpile("SELECT LOGICAL_AND(age > 18) FROM users", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MIN(ABS(age > 18)) FROM `users`");
  });
  it("SELECT `class`, student_id, test1, APPROX_PERCENTILE(test1, 0.3) OVER (PARTITION BY `cl...", () => {
    validateIdentity("SELECT `class`, student_id, test1, APPROX_PERCENTILE(test1, 0.3) OVER (PARTITION BY `class`) AS percentile FROM test_scores");
  });
  it("SELECT `class`, student_id, test1, APPROX_PERCENTILE(test1, 0.3, 0.4) OVER (PARTITION B...", () => {
    validateIdentity("SELECT `class`, student_id, test1, APPROX_PERCENTILE(test1, 0.3, 0.4) OVER (PARTITION BY `class`) AS percentile FROM test_scores");
  });
  it("singlestore -> singlestore: SELECT APPROX_PERCENTILE(test1, 0.3) FROM test_scores", () => {
    const result = transpile("SELECT APPROX_PERCENTILE(test1, 0.3) FROM test_scores", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(test1, 0.3) FROM test_scores");
  });
  it(" -> singlestore: SELECT APPROX_QUANTILE(test1, 0.3, 0.4) FROM test_scores", () => {
    const result = transpile("SELECT APPROX_QUANTILE(test1, 0.3, 0.4) FROM test_scores", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT APPROX_PERCENTILE(test1, 0.3) FROM test_scores");
  });
  it("singlestore -> singlestore: SELECT VAR_SAMP(yearly_total) FROM player_scores", () => {
    const result = transpile("SELECT VAR_SAMP(yearly_total) FROM player_scores", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT VAR_SAMP(yearly_total) FROM player_scores");
  });
  it.todo(" -> singlestore: SELECT VARIANCE(yearly_total) FROM player_scores (cross-dialect transform)");
  it.todo("singlestore -> : SELECT VAR_SAMP(yearly_total) FROM player_scores (cross-dialect transform)");
  it("singlestore -> singlestore: SELECT VARIANCE(yearly_total) FROM player_scores", () => {
    const result = transpile("SELECT VARIANCE(yearly_total) FROM player_scores", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT VAR_POP(yearly_total) FROM player_scores");
  });
  it.todo(" -> singlestore: SELECT VARIANCE_POP(yearly_total) FROM player_scores (cross-dialect transform)");
  it.todo("singlestore -> : SELECT VAR_POP(yearly_total) FROM player_scores (cross-dialect transform)");
  it(" -> singlestore: SELECT CBRT(id) FROM orders", () => {
    const result = transpile("SELECT CBRT(id) FROM orders", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT POWER(id, 1 / 3) FROM orders");
  });
  it("singlestore -> singlestore: SELECT POWER(id, 1 / 3) FROM orders", () => {
    const result = transpile("SELECT POWER(id, 1 / 3) FROM orders", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT POWER(id, 1 / 3) FROM orders");
  });
});

describe("Singlestore: logical", () => {
  it.todo("mysql -> singlestore: SELECT TRUE XOR FALSE (unsupported syntax)");
  it("singlestore -> singlestore: SELECT (TRUE AND (NOT FALSE)) OR ((NOT TRUE) AND FALSE)", () => {
    const result = transpile("SELECT (TRUE AND (NOT FALSE)) OR ((NOT TRUE) AND FALSE)", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT (TRUE AND (NOT FALSE)) OR ((NOT TRUE) AND FALSE)");
  });
});

describe("Singlestore: string_functions", () => {
  it("bigquery -> singlestore: SELECT REGEXP_CONTAINS('a', 'b')", () => {
    const result = transpile("SELECT REGEXP_CONTAINS('a', 'b')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 'a' RLIKE 'b'");
  });
  it("singlestore -> singlestore: SELECT 'a' RLIKE 'b'", () => {
    const result = transpile("SELECT 'a' RLIKE 'b'", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 'a' RLIKE 'b'");
  });
  it("SELECT 'a' REGEXP 'b' -> SELECT 'a' RLIKE 'b'", () => {
    validateIdentity("SELECT 'a' REGEXP 'b'", "SELECT 'a' RLIKE 'b'");
  });
  it(" -> singlestore: SELECT REPEAT('a', 3)", () => {
    const result = transpile("SELECT REPEAT('a', 3)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LPAD('', LENGTH('a') * 3, 'a')");
  });
  it("singlestore -> singlestore: SELECT LPAD('', LENGTH('a') * 3, 'a')", () => {
    const result = transpile("SELECT LPAD('', LENGTH('a') * 3, 'a')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LPAD('', LENGTH('a') * 3, 'a')");
  });
  it(" -> singlestore: SELECT REGEXP_EXTRACT('adog', 'O', 1, 1, 'c', 'gr1')", () => {
    const result = transpile("SELECT REGEXP_EXTRACT('adog', 'O', 1, 1, 'c', 'gr1')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')");
  });
  it("singlestore -> singlestore: SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')", () => {
    const result = transpile("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')");
  });
  it("singlestore -> singlestore: SELECT ('a' RLIKE '^[\0-]*$')", () => {
    const result = transpile("SELECT ('a' RLIKE '^[\0-]*$')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ('a' RLIKE '^[\0-]*$')");
  });
  it(" -> singlestore: SELECT IS_ASCII('a')", () => {
    const result = transpile("SELECT IS_ASCII('a')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT ('a' RLIKE '^[\0-]*$')");
  });
  it("singlestore -> singlestore: SELECT UNHEX(MD5('data'))", () => {
    const result = transpile("SELECT UNHEX(MD5('data'))", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNHEX(MD5('data'))");
  });
  it(" -> singlestore: SELECT MD5_DIGEST('data')", () => {
    const result = transpile("SELECT MD5_DIGEST('data')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UNHEX(MD5('data'))");
  });
  it(" -> singlestore: SELECT CHR(101)", () => {
    const result = transpile("SELECT CHR(101)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CHAR(101)");
  });
  it("singlestore -> singlestore: SELECT CHAR(101)", () => {
    const result = transpile("SELECT CHAR(101)", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CHAR(101)");
  });
  it.todo("SELECT INSTR('ohai', 'i') (unsupported syntax)");
  it(" -> singlestore: SELECT REGEXP_EXTRACT_ALL('adog', 'O', 1, 'c', 1, 'gr1')", () => {
    const result = transpile("SELECT REGEXP_EXTRACT_ALL('adog', 'O', 1, 'c', 1, 'gr1')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_MATCH('adog', 'O', 'c')");
  });
  it("singlestore -> singlestore: SELECT REGEXP_MATCH('adog', 'O', 'c')", () => {
    const result = transpile("SELECT REGEXP_MATCH('adog', 'O', 'c')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_MATCH('adog', 'O', 'c')");
  });
  it(" -> singlestore: SELECT REGEXP_EXTRACT('adog', 'O', 1, 1, 'c', 'gr1') (2)", () => {
    const result = transpile("SELECT REGEXP_EXTRACT('adog', 'O', 1, 1, 'c', 'gr1')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')");
  });
  it("singlestore -> singlestore: SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c') (2)", () => {
    const result = transpile("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_SUBSTR('adog', 'O', 1, 1, 'c')");
  });
  it(" -> singlestore: SELECT STARTS_WITH('abcd', 'ab')", () => {
    const result = transpile("SELECT STARTS_WITH('abcd', 'ab')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_INSTR('abcd', CONCAT('^', 'ab'))");
  });
  it("singlestore -> singlestore: SELECT REGEXP_INSTR('abcd', CONCAT('^', 'ab'))", () => {
    const result = transpile("SELECT REGEXP_INSTR('abcd', CONCAT('^', 'ab'))", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT REGEXP_INSTR('abcd', CONCAT('^', 'ab'))");
  });
  it("redshift -> singlestore: SELECT STRTOL('f',16)", () => {
    const result = transpile("SELECT STRTOL('f',16)", { readDialect: "redshift", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CONV('f', 16, 10)");
  });
  it("singlestore -> singlestore: SELECT CONV('f', 16, 10)", () => {
    const result = transpile("SELECT CONV('f', 16, 10)", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CONV('f', 16, 10)");
  });
  it.todo("postgres -> singlestore: SELECT 'ABC' ~* 'a.*' (unsupported syntax)");
  it("singlestore -> singlestore: SELECT LOWER('ABC') RLIKE LOWER('a.*')", () => {
    const result = transpile("SELECT LOWER('ABC') RLIKE LOWER('a.*')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT LOWER('ABC') RLIKE LOWER('a.*')");
  });
  it("singlestore -> singlestore: SELECT CONCAT(SUBSTRING('abcdef', 1, 2 - 1), 'xyz', SUBSTRI...", () => {
    const result = transpile("SELECT CONCAT(SUBSTRING('abcdef', 1, 2 - 1), 'xyz', SUBSTRING('abcdef', 2 + 3))", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CONCAT(SUBSTRING('abcdef', 1, 2 - 1), 'xyz', SUBSTRING('abcdef', 2 + 3))");
  });
  it(" -> singlestore: SELECT STUFF('abcdef', 2, 3, 'xyz')", () => {
    const result = transpile("SELECT STUFF('abcdef', 2, 3, 'xyz')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CONCAT(SUBSTRING('abcdef', 1, 2 - 1), 'xyz', SUBSTRING('abcdef', 2 + 3))");
  });
  it("singlestore -> singlestore: SELECT SHA(email) FROM t", () => {
    const result = transpile("SELECT SHA(email) FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SHA(email) FROM t");
  });
  it(" -> singlestore: SELECT STANDARD_HASH(email) FROM t", () => {
    const result = transpile("SELECT STANDARD_HASH(email) FROM t", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SHA(email) FROM t");
  });
  it("singlestore -> singlestore: SELECT SHA(email) FROM t (2)", () => {
    const result = transpile("SELECT SHA(email) FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SHA(email) FROM t");
  });
  it(" -> singlestore: SELECT STANDARD_HASH(email, 'sha') FROM t", () => {
    const result = transpile("SELECT STANDARD_HASH(email, 'sha') FROM t", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT SHA(email) FROM t");
  });
  it("singlestore -> singlestore: SELECT MD5(email) FROM t", () => {
    const result = transpile("SELECT MD5(email) FROM t", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MD5(email) FROM t");
  });
  it(" -> singlestore: SELECT STANDARD_HASH(email, 'MD5') FROM t", () => {
    const result = transpile("SELECT STANDARD_HASH(email, 'MD5') FROM t", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT MD5(email) FROM t");
  });
});

describe("Singlestore: reduce_functions", () => {
  it.todo("SELECT REDUCE(0, JSON_TO_ARRAY('[1,2,3,4]'), REDUCE_ACC() + REDUCE_... (unsupported syntax)");
});

describe("Singlestore: time_functions", () => {
  it.todo(" -> singlestore: SELECT DATE_BIN('1d', '2019-03-14 06:04:12', DAY, 'UTC', '2019-03-13 0... (cross-dialect transform)");
  it("singlestore -> singlestore: SELECT TIME_BUCKET('1d', '2019-03-14 06:04:12', '2019-03-13...", () => {
    const result = transpile("SELECT TIME_BUCKET('1d', '2019-03-14 06:04:12', '2019-03-13 03:00:00')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIME_BUCKET('1d', '2019-03-14 06:04:12', '2019-03-13 03:00:00')");
  });
  it(" -> singlestore: SELECT TIME_STR_TO_DATE('2019-03-14 06:04:12')", () => {
    const result = transpile("SELECT TIME_STR_TO_DATE('2019-03-14 06:04:12')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT '2019-03-14 06:04:12' :> DATE");
  });
  it("singlestore -> singlestore: SELECT '2019-03-14 06:04:12' :> DATE", () => {
    const result = transpile("SELECT '2019-03-14 06:04:12' :> DATE", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT '2019-03-14 06:04:12' :> DATE");
  });
  it.todo("SELECT CONVERT_TZ(NOW() :> TIMESTAMP, 'GMT', 'UTC') (unsupported syntax)");
  it(" -> singlestore: SELECT DI_TO_DATE(20190314)", () => {
    const result = transpile("SELECT DI_TO_DATE(20190314)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT STR_TO_DATE(20190314, '%Y%m%d')");
  });
  it("singlestore -> singlestore: SELECT STR_TO_DATE(20190314, '%Y%m%d')", () => {
    const result = transpile("SELECT STR_TO_DATE(20190314, '%Y%m%d')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT STR_TO_DATE(20190314, '%Y%m%d')");
  });
  it.todo("SELECT (DATE_FORMAT('2019-03-14 06:04:12', '%Y%m%d') :> INT) (unsupported syntax)");
  it.todo("SELECT (DATE_FORMAT('2019-03-14 06:04:12', '%Y%m%d') :> INT) (unsupported syntax) (2)");
  it("bigquery -> singlestore: SELECT TIME('2019-03-14 06:04:12', 'GMT')", () => {
    const result = transpile("SELECT TIME('2019-03-14 06:04:12', 'GMT')", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT '2019-03-14 06:04:12' :> TIME");
  });
  it("singlestore -> singlestore: SELECT '2019-03-14 06:04:12' :> TIME", () => {
    const result = transpile("SELECT '2019-03-14 06:04:12' :> TIME", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT '2019-03-14 06:04:12' :> TIME");
  });
  it.todo("SELECT DATE_ADD(NOW(), INTERVAL '1' MONTH) (unsupported syntax)");
  it("bigquery -> singlestore: SELECT DATETIME_TRUNC('2016-08-08 12:05:31', MINUTE)", () => {
    const result = transpile("SELECT DATETIME_TRUNC('2016-08-08 12:05:31', MINUTE)", { readDialect: "bigquery", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')");
  });
  it("singlestore -> singlestore: SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')", () => {
    const result = transpile("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')");
  });
  it.todo("SELECT DATE_SUB('2010-04-02', INTERVAL '1' WEEK) (unsupported syntax)");
  it("singlestore -> singlestore: SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')", () => {
    const result = transpile("SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')");
  });
  it(" -> singlestore: SELECT DATETIME_DIFF('2013-09-01', '2009-02-13', QUARTER)", () => {
    const result = transpile("SELECT DATETIME_DIFF('2013-09-01', '2009-02-13', QUARTER)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')");
  });
  it("singlestore -> singlestore: SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01') (2)", () => {
    const result = transpile("SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMPDIFF(QUARTER, '2009-02-13', '2013-09-01')");
  });
  it.todo("bigquery -> singlestore: SELECT DATE_DIFF('2013-09-01', '2009-02-13', QUARTER) (cross-dialect transform)");
  it.todo("duckdb -> singlestore: SELECT DATE_DIFF('QUARTER', '2009-02-13', '2013-09-01') (cross-dialect transform)");
  it.todo("hive -> singlestore: SELECT DATEDIFF('2013-09-01', '2009-02-13') (cross-dialect transform)");
  it("singlestore -> singlestore: SELECT DATEDIFF(DATE('2013-09-01'), DATE('2009-02-13'))", () => {
    const result = transpile("SELECT DATEDIFF(DATE('2013-09-01'), DATE('2009-02-13'))", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATEDIFF(DATE('2013-09-01'), DATE('2009-02-13'))");
  });
  it(" -> singlestore: SELECT TIMESTAMP_TRUNC('2016-08-08 12:05:31', MINUTE)", () => {
    const result = transpile("SELECT TIMESTAMP_TRUNC('2016-08-08 12:05:31', MINUTE)", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')");
  });
  it("singlestore -> singlestore: SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31') (2)", () => {
    const result = transpile("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATE_TRUNC('MINUTE', '2016-08-08 12:05:31')");
  });
  it.todo("redshift -> singlestore: SELECT datediff(week,'2009-01-01','2009-12-31') AS numweeks (cross-dialect transform)");
  it("singlestore -> singlestore: SELECT TIMESTAMPDIFF(WEEK, '2009-01-01', '2009-12-31') AS n...", () => {
    const result = transpile("SELECT TIMESTAMPDIFF(WEEK, '2009-01-01', '2009-12-31') AS numweeks", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TIMESTAMPDIFF(WEEK, '2009-01-01', '2009-12-31') AS numweeks");
  });
  it(" -> singlestore: SELECT TS_OR_DS_DIFF('2009-12-31', '2009-01-01') AS numweeks", () => {
    const result = transpile("SELECT TS_OR_DS_DIFF('2009-12-31', '2009-01-01') AS numweeks", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATEDIFF('2009-12-31', '2009-01-01') AS numweeks");
  });
  it("singlestore -> singlestore: SELECT DATEDIFF('2009-12-31', '2009-01-01') AS numweeks", () => {
    const result = transpile("SELECT DATEDIFF('2009-12-31', '2009-01-01') AS numweeks", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT DATEDIFF('2009-12-31', '2009-01-01') AS numweeks");
  });
  it(" -> singlestore: SELECT CURRENT_DATE()", () => {
    const result = transpile("SELECT CURRENT_DATE()", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_DATE()");
  });
  it("singlestore -> singlestore: SELECT CURRENT_DATE", () => {
    const result = transpile("SELECT CURRENT_DATE", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_DATE()");
  });
  it(" -> singlestore: SELECT CURRENT_DATE('UTC')", () => {
    const result = transpile("SELECT CURRENT_DATE('UTC')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_DATE()");
  });
  it("singlestore -> singlestore: SELECT UTC_DATE", () => {
    const result = transpile("SELECT UTC_DATE", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_DATE()");
  });
  it("singlestore -> : SELECT UTC_DATE()", () => {
    const result = transpile("SELECT UTC_DATE()", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CURRENT_DATE('UTC')");
  });
  it(" -> singlestore: SELECT CURRENT_TIME()", () => {
    const result = transpile("SELECT CURRENT_TIME()", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIME()");
  });
  it("singlestore -> singlestore: SELECT CURRENT_TIME", () => {
    const result = transpile("SELECT CURRENT_TIME", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIME()");
  });
  it("SELECT CURRENT_TIME(6)", () => {
    validateIdentity("SELECT CURRENT_TIME(6)");
  });
  it(" -> singlestore: SELECT CURRENT_TIME('UTC')", () => {
    const result = transpile("SELECT CURRENT_TIME('UTC')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_TIME()");
  });
  it("singlestore -> singlestore: SELECT UTC_TIME", () => {
    const result = transpile("SELECT UTC_TIME", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_TIME()");
  });
  it("singlestore -> : SELECT UTC_TIME()", () => {
    const result = transpile("SELECT UTC_TIME()", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CURRENT_TIME('UTC')");
  });
  it(" -> singlestore: SELECT CURRENT_TIMESTAMP()", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP()", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP()");
  });
  it("singlestore -> singlestore: SELECT CURRENT_TIMESTAMP", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP()");
  });
  it.todo("SELECT CURRENT_TIMESTAMP(6) (unsupported syntax)");
  it(" -> singlestore: SELECT CURRENT_TIMESTAMP('UTC')", () => {
    const result = transpile("SELECT CURRENT_TIMESTAMP('UTC')", { readDialect: "", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_TIMESTAMP()");
  });
  it("singlestore -> singlestore: SELECT UTC_TIMESTAMP", () => {
    const result = transpile("SELECT UTC_TIMESTAMP", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT UTC_TIMESTAMP()");
  });
  it("singlestore -> : SELECT UTC_TIMESTAMP()", () => {
    const result = transpile("SELECT UTC_TIMESTAMP()", { readDialect: DIALECT, writeDialect: "" })[0];
    expect(result).toBe("SELECT CURRENT_TIMESTAMP('UTC')");
  });
  it.todo("SELECT CURRENT_TIMESTAMP(6) :> DATETIME(6) (unsupported syntax)");
  it("SELECT UTC_TIMESTAMP(6)", () => {
    validateIdentity("SELECT UTC_TIMESTAMP(6)");
  });
  it("SELECT UTC_TIME(6)", () => {
    validateIdentity("SELECT UTC_TIME(6)");
  });
});

describe("Singlestore: types", () => {
  it.todo("CREATE TABLE testTypes (a DECIMAL(10, 20)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a BOOLEAN) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DATE) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DATETIME) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DECIMAL(9, 3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DECIMAL(18, 3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DECIMAL(38, 3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a DECIMAL(65, 3)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a ENUM('a')) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a ENUM('a')) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE testTypes (a TEXT(2)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHY) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHYPOINT) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHY) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHY) (DDL/DML not supported) (3)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHY) (DDL/DML not supported) (4)");
  it.todo("CREATE TABLE testTypes (a GEOGRAPHY) (DDL/DML not supported) (5)");
  it.todo("CREATE TABLE testTypes (a BSON) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a TIMESTAMP(6)) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a TIMESTAMP) (DDL/DML not supported)");
  it.todo("CREATE TABLE testTypes (a TIMESTAMP(6)) (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE testTypes (a BLOB) (DDL/DML not supported)");
});

describe("Singlestore: column_with_tablename", () => {
  it("SELECT `t0`.`name` FROM `t0`", () => {
    validateIdentity("SELECT `t0`.`name` FROM `t0`");
  });
});

describe("Singlestore: unicodestring_sql", () => {
  it("presto -> singlestore: SELECT U&'d\\0061t\\0061'", () => {
    const result = transpile("SELECT U&'d\\0061t\\0061'", { readDialect: "presto", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 'data'");
  });
  it("singlestore -> singlestore: SELECT 'data'", () => {
    const result = transpile("SELECT 'data'", { readDialect: "singlestore", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT 'data'");
  });
});

describe("Singlestore: collate_sql", () => {
  it.todo("SELECT name :> LONGTEXT COLLATE 'utf8mb4_bin' FROM `users` (unsupported syntax)");
  it.todo("SELECT name :> LONGTEXT COLLATE 'utf8mb4_bin' FROM `users` (unsupported syntax) (2)");
});

describe("Singlestore: show", () => {
  it.todo("SHOW AGGREGATES FROM db1 (command not supported)");
  it.todo("SHOW AGGREGATES LIKE 'multiply%' (command not supported)");
  it.todo("SHOW CDC EXTRACTOR POOL (command not supported)");
  it.todo("SHOW CREATE AGGREGATE avg_udaf (command not supported)");
  it.todo("SHOW CREATE PIPELINE mypipeline (command not supported)");
  it.todo("SHOW CREATE PROJECTION lineitem_sort_shipdate FOR TABLE lineitem (command not supported)");
  it.todo("SHOW DATABASE STATUS (command not supported)");
  it.todo("SHOW DISTRIBUTED_PLANCACHE STATUS (command not supported)");
  it.todo("SHOW FULLTEXT SERVICE STATUS (command not supported)");
  it.todo("SHOW FULLTEXT SERVICE METRICS LOCAL (command not supported)");
  it.todo("SHOW FULLTEXT SERVICE METRICS FOR NODE 1 (command not supported)");
  it.todo("SHOW FUNCTIONS FROM db LIKE 'a' (command not supported)");
  it.todo("SHOW GROUPS (command not supported)");
  it.todo("SHOW GROUPS FOR ROLE 'role_name_0' (command not supported)");
  it.todo("SHOW GROUPS FOR USER 'root' (command not supported)");
  it.todo("SHOW INDEXES FROM mytbl (command not supported)");
  it.todo("SHOW KEYS FROM mytbl (command not supported)");
  it.todo("SHOW LINKS ON Orderdb (command not supported)");
  it.todo("SHOW LOAD ERRORS (command not supported)");
  it.todo("SHOW LOAD WARNINGS (command not supported)");
  it.todo("SHOW PARTITIONS ON memsql_demo (command not supported)");
  it.todo("SHOW PIPELINES (command not supported)");
  it.todo("SHOW PLAN JSON 25 (command not supported)");
  it.todo("SHOW PLAN 25 (command not supported)");
  it.todo("SHOW PLANCACHE (command not supported)");
  it.todo("SHOW PROCEDURES FROM dbExample (command not supported)");
  it.todo("SHOW PROCEDURES LIKE '%sp%' (command not supported)");
  it.todo("SHOW PROJECTIONS ON TABLE t (command not supported)");
  it.todo("SHOW PROJECTIONS (command not supported)");
  it.todo("SHOW REPLICATION STATUS (command not supported)");
  it.todo("SHOW REPRODUCTION (command not supported)");
  it.todo("SHOW REPRODUCTION INTO OUTFILE 'a' (command not supported)");
  it.todo("SHOW RESOURCE POOLS (command not supported)");
  it.todo("SHOW ROLES LIKE 'xyz' (command not supported)");
  it.todo("SHOW ROLES FOR GROUP 'group_0' (command not supported)");
  it.todo("SHOW ROLES FOR USER 'root' (command not supported)");
  it.todo("SHOW STATUS (command not supported)");
  it.todo("SHOW USERS (command not supported)");
  it.todo("SHOW USERS FOR GROUP 'group_name' (command not supported)");
  it.todo("SHOW USERS FOR ROLE 'role_name' (command not supported)");
});

describe("Singlestore: truncate", () => {
  it.todo("TRUNCATE t1; TRUNCATE t2 (DDL/DML not supported)");
});

describe("Singlestore: vector", () => {
  it.todo("CREATE TABLE t (a VECTOR(10, I32)) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (a VECTOR(10)) (DDL/DML not supported)");
});

describe("Singlestore: alter", () => {
  it.todo("ALTER TABLE t CHANGE middle_initial middle_name (DDL/DML not supported)");
  it.todo("ALTER TABLE t MODIFY COLUMN name TEXT COLLATE 'binary' (DDL/DML not supported)");
});

describe("Singlestore: constraints", () => {
  it.todo("CREATE TABLE ComputedColumnConstraint (points INT, score AS (points... (DDL/DML not supported)");
  it.todo("CREATE TABLE ComputedColumnConstraint (points INT, score AS (points... (DDL/DML not supported) (2)");
});

describe("Singlestore: dcolonqmark", () => {
  it("SELECT * FROM employee WHERE JSON_MATCH_ANY(payroll::?names)", () => {
    validateIdentity("SELECT * FROM employee WHERE JSON_MATCH_ANY(payroll::?names)");
  });
});
