// @generated by codegen_tests.py -- DO NOT EDIT
import { describe, it, expect } from "vitest";
import { transpile } from "../../src/index.js";

const DIALECT = "databricks";

function validateIdentity(sql: string, writeSql?: string): void {
  const result = transpile(sql, { readDialect: DIALECT, writeDialect: DIALECT })[0];
  expect(result).toBe(writeSql ?? sql);
}

describe("Databricks: databricks", () => {
  it("SELECT COSH(1.5)", () => {
    validateIdentity("SELECT COSH(1.5)");
  });
  it.todo("test_databricks: assertEqual call");
  it.todo("test_databricks: assertEqual call (2)");
  it.todo("DESCRIBE EXTENDED staging.onetrade_startb AS JSON (command not supported)");
  it("SELECT BITMAP_BIT_POSITION(10)", () => {
    validateIdentity("SELECT BITMAP_BIT_POSITION(10)");
  });
  it("SELECT BITMAP_BUCKET_NUMBER(32769)", () => {
    validateIdentity("SELECT BITMAP_BUCKET_NUMBER(32769)");
  });
  it("SELECT BITMAP_CONSTRUCT_AGG(value)", () => {
    validateIdentity("SELECT BITMAP_CONSTRUCT_AGG(value)");
  });
  it("SELECT EXP(1)", () => {
    validateIdentity("SELECT EXP(1)");
  });
  it("SELECT MODE(category)", () => {
    validateIdentity("SELECT MODE(category)");
  });
  it("SELECT MODE(price, TRUE) AS deterministic_mode FROM products", () => {
    validateIdentity("SELECT MODE(price, TRUE) AS deterministic_mode FROM products");
  });
  it("REGEXP_LIKE(x, y)", () => {
    validateIdentity("REGEXP_LIKE(x, y)");
  });
  it("SELECT CAST(NULL AS VOID)", () => {
    validateIdentity("SELECT CAST(NULL AS VOID)");
  });
  it("SELECT void FROM t", () => {
    validateIdentity("SELECT void FROM t");
  });
  it("SELECT * FROM stream", () => {
    validateIdentity("SELECT * FROM stream");
  });
  it("SELECT * FROM STREAM t", () => {
    validateIdentity("SELECT * FROM STREAM t");
  });
  it("SELECT t.current_time FROM t", () => {
    validateIdentity("SELECT t.current_time FROM t");
  });
  it.todo("ALTER TABLE labels ADD COLUMN label_score FLOAT (DDL/DML not supported)");
  it.todo("DESCRIBE HISTORY a.b (command not supported)");
  it.todo("DESCRIBE history.tbl (command not supported)");
  it.todo("CREATE TABLE t (a STRUCT<c: MAP<STRING, STRING>>) (DDL/DML not supported)");
  it.todo("CREATE TABLE t (c STRUCT<interval: DOUBLE COMMENT 'aaa'>) (DDL/DML not supported)");
  it.todo("CREATE TABLE my_table TBLPROPERTIES (a.b=15) (DDL/DML not supported)");
  it.todo("CREATE TABLE my_table TBLPROPERTIES ('a.b'=15) (DDL/DML not supported)");
  it("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO HOUR)", () => {
    validateIdentity("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO HOUR)");
  });
  it("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO MINUTE)", () => {
    validateIdentity("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO MINUTE)");
  });
  it("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO SECOND)", () => {
    validateIdentity("SELECT CAST('11 23:4:0' AS INTERVAL DAY TO SECOND)");
  });
  it("SELECT CAST('23:00:00' AS INTERVAL HOUR TO MINUTE)", () => {
    validateIdentity("SELECT CAST('23:00:00' AS INTERVAL HOUR TO MINUTE)");
  });
  it("SELECT CAST('23:00:00' AS INTERVAL HOUR TO SECOND)", () => {
    validateIdentity("SELECT CAST('23:00:00' AS INTERVAL HOUR TO SECOND)");
  });
  it("SELECT CAST('23:00:00' AS INTERVAL MINUTE TO SECOND)", () => {
    validateIdentity("SELECT CAST('23:00:00' AS INTERVAL MINUTE TO SECOND)");
  });
  it.todo("CREATE TABLE target SHALLOW CLONE source (DDL/DML not supported)");
  it.todo("INSERT INTO a REPLACE WHERE cond VALUES (1), (2) (DDL/DML not supported)");
  it.todo("CREATE FUNCTION a.b(x INT) RETURNS INT RETURN x + 1 (DDL/DML not supported)");
  it.todo("CREATE FUNCTION a AS b (DDL/DML not supported)");
  it("SELECT ${x} FROM ${y} WHERE ${z} > 1", () => {
    validateIdentity("SELECT ${x} FROM ${y} WHERE ${z} > 1");
  });
  it.todo("CREATE TABLE foo (x DATE GENERATED ALWAYS AS (CAST(y AS DATE))) (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 PARTITION(age = 10, name = 'test', address) (DDL/DML not supported)");
  it("SELECT PARSE_JSON('{}')", () => {
    validateIdentity("SELECT PARSE_JSON('{}')");
  });
  it("SELECT RANDSTR(123)", () => {
    validateIdentity("SELECT RANDSTR(123)");
  });
  it("SELECT RANDSTR(123, 456)", () => {
    validateIdentity("SELECT RANDSTR(123, 456)");
  });
  it("PARSE_URL('https://example.com/path')", () => {
    validateIdentity("PARSE_URL('https://example.com/path')");
  });
  it("PARSE_URL('https://example.com/path', 'HOST')", () => {
    validateIdentity("PARSE_URL('https://example.com/path', 'HOST')");
  });
  it("PARSE_URL('https://example.com/path', 'QUERY', 'param')", () => {
    validateIdentity("PARSE_URL('https://example.com/path', 'QUERY', 'param')");
  });
  it.todo("CREATE TABLE IF NOT EXISTS db.table (a TIMESTAMP, b BOOLEAN GENERAT... (DDL/DML not supported)");
  it.todo("SELECT * FROM sales UNPIVOT INCLUDE NULLS (sales FOR quarter IN (q1... (unsupported clause)");
  it.todo("SELECT * FROM sales UNPIVOT EXCLUDE NULLS (sales FOR quarter IN (q1... (unsupported clause)");
  it.todo("CREATE FUNCTION add_one(x INT) RETURNS INT LANGUAGE PYTHON AS $$def... (DDL/DML not supported)");
  it.todo("CREATE FUNCTION add_one(x INT) RETURNS INT LANGUAGE PYTHON AS $FOO$... (DDL/DML not supported)");
  it.todo("TRUNCATE TABLE t1 PARTITION(age = 10, name = 'test', city LIKE 'LA') (DDL/DML not supported)");
  it.todo("COPY INTO target FROM `s3://link` FILEFORMAT = AVRO VALIDATE = ALL ... (command not supported)");
  it("SELECT * FROM t1, t2 -> SELECT * FROM t1 CROSS JOIN t2", () => {
    validateIdentity("SELECT * FROM t1, t2", "SELECT * FROM t1 CROSS JOIN t2");
  });
  it.todo("SELECT TIMESTAMP '2025-04-29 18.47.18'::DATE (unsupported syntax)");
  it.todo("SELECT DATE_FORMAT(CAST(FROM_UTC_TIMESTAMP(foo, 'America/Los_Angele... (unsupported syntax)");
  it(`SELECT r"\\\\foo.bar\\" -> SELECT '\\\\\\\\foo.bar\\\\'`, () => {
    validateIdentity('SELECT r"\\\\foo.bar\\"', "SELECT '\\\\\\\\foo.bar\\\\'");
  });
  it.todo("FROM_UTC_TIMESTAMP(x::TIMESTAMP, tz) (unsupported syntax)");
  it("SELECT SUBSTRING_INDEX(str, delim, count)", () => {
    validateIdentity("SELECT SUBSTRING_INDEX(str, delim, count)");
  });
  it("BITMAP_OR_AGG(x)", () => {
    validateIdentity("BITMAP_OR_AGG(x)");
  });
  it("databricks -> databricks: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it("databricks -> spark: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it("databricks -> mysql: SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", () => {
    const result = transpile("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)", { readDialect: DIALECT, writeDialect: "mysql" })[0];
    expect(result).toBe("SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)");
  });
  it.todo("SELECT SUBSTR('Spark' FROM 5 FOR 1) (unsupported syntax)");
  it("SELECT SUBSTR('Spark SQL', 5) -> SELECT SUBSTRING('Spark SQL', 5)", () => {
    validateIdentity("SELECT SUBSTR('Spark SQL', 5)", "SELECT SUBSTRING('Spark SQL', 5)");
  });
  it("SELECT SUBSTR(ENCODE('Spark SQL', 'utf-8'), 5) -> SELECT SUBSTRING(ENCODE('Spark SQL', ...", () => {
    validateIdentity("SELECT SUBSTR(ENCODE('Spark SQL', 'utf-8'), 5)", "SELECT SUBSTRING(ENCODE('Spark SQL', 'utf-8'), 5)");
  });
  it("databricks -> databricks: SELECT TYPEOF(1)", () => {
    const result = transpile("SELECT TYPEOF(1)", { readDialect: "databricks", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TYPEOF(1)");
  });
  it("snowflake -> databricks: SELECT TYPEOF(1)", () => {
    const result = transpile("SELECT TYPEOF(1)", { readDialect: "snowflake", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TYPEOF(1)");
  });
  it("hive -> databricks: SELECT TYPEOF(1)", () => {
    const result = transpile("SELECT TYPEOF(1)", { readDialect: "hive", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TYPEOF(1)");
  });
  it("clickhouse -> databricks: SELECT toTypeName(1)", () => {
    const result = transpile("SELECT toTypeName(1)", { readDialect: "clickhouse", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT TYPEOF(1)");
  });
  it("databricks -> clickhouse: SELECT TYPEOF(1)", () => {
    const result = transpile("SELECT TYPEOF(1)", { readDialect: DIALECT, writeDialect: "clickhouse" })[0];
    expect(result).toBe("SELECT toTypeName(1)");
  });
  it("spark -> databricks: SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", () => {
    const result = transpile("SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", { readDialect: "spark", writeDialect: DIALECT })[0];
    expect(result).toBe("SELECT c1:item[1].price");
  });
  it("databricks -> databricks: SELECT c1:item[1].price", () => {
    const result = transpile("SELECT c1:item[1].price", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT c1:item[1].price");
  });
  it("databricks -> spark: SELECT c1:item[1].price", () => {
    const result = transpile("SELECT c1:item[1].price", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(c1, '$.item[1].price')");
  });
  it("databricks -> databricks: SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", () => {
    const result = transpile("SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT c1:item[1].price");
  });
  it("databricks -> spark: SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", () => {
    const result = transpile("SELECT GET_JSON_OBJECT(c1, '$.item[1].price')", { readDialect: DIALECT, writeDialect: "spark" })[0];
    expect(result).toBe("SELECT GET_JSON_OBJECT(c1, '$.item[1].price')");
  });
  it.todo("CREATE TABLE foo (x INT GENERATED ALWAYS AS (YEAR(y))) (DDL/DML not supported)");
  it.todo("CREATE TABLE t1 AS (SELECT c FROM t2) (DDL/DML not supported)");
  it.todo("SELECT X'1A2B' (unsupported syntax)");
  it.todo("CREATE OR REPLACE FUNCTION func(a BIGINT, b BIGINT) RETURNS TABLE (... (DDL/DML not supported)");
  it.todo("CREATE OR REPLACE FUNCTION func(a BIGINT, b BIGINT) RETURNS BIGINT ... (DDL/DML not supported)");
  it.todo("SELECT ANY(col) FROM VALUES (TRUE), (FALSE) AS tab(col) (unsupported syntax)");
  it.todo("CREATE TABLE t1 (foo BIGINT NOT NULL CONSTRAINT foo_c FOREIGN KEY R... (DDL/DML not supported)");
  it.todo("CREATE TABLE t1 (foo BIGINT NOT NULL CONSTRAINT foo_c FOREIGN KEY R... (DDL/DML not supported) (2)");
  it.todo("CREATE TABLE t1 (foo BIGINT NOT NULL CONSTRAINT foo_c FOREIGN KEY R... (DDL/DML not supported) (3)");
  it.todo("CREATE TABLE t1 (foo BIGINT NOT NULL CONSTRAINT foo_c FOREIGN KEY R... (DDL/DML not supported) (4)");
  it("SELECT test, LISTAGG(email, '') AS Email FROM organizations GROUP BY test", () => {
    validateIdentity("SELECT test, LISTAGG(email, '') AS Email FROM organizations GROUP BY test");
  });
  it.todo("WITH t AS (VALUES ('foo_val') AS t(foo1)) SELECT foo1 FROM t (unsupported syntax)");
  it("NTILE() OVER (ORDER BY 1)", () => {
    validateIdentity("NTILE() OVER (ORDER BY 1)");
  });
  it("CURRENT_VERSION()", () => {
    validateIdentity("CURRENT_VERSION()");
  });
  it.todo("databricks -> snowflake: UNIFORM(1, 10, 5) (cross-dialect transform)");
  it("databricks -> databricks: UNIFORM(1, 10, 5)", () => {
    const result = transpile("UNIFORM(1, 10, 5)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("UNIFORM(1, 10, 5)");
  });
  it("databricks -> databricks: UNIFORM(1, 10)", () => {
    const result = transpile("UNIFORM(1, 10)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("UNIFORM(1, 10)");
  });
  it.todo("databricks -> snowflake: UNIFORM(1, 10) (cross-dialect transform)");
  it("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result", () => {
    validateIdentity("SELECT ELT(2, 'foo', 'bar', 'baz') AS Result");
  });
  it("GETDATE() -> CURRENT_TIMESTAMP()", () => {
    validateIdentity("GETDATE()", "CURRENT_TIMESTAMP()");
  });
  it.todo("NOW() (unsupported syntax)");
  it("CURRENT_TIMEZONE()", () => {
    validateIdentity("CURRENT_TIMEZONE()");
  });
  it.todo("CURDATE() (unsupported syntax)");
  it("CURDATE -> CURRENT_DATE", () => {
    validateIdentity("CURDATE", "CURRENT_DATE");
  });
  it("SELECT MAKE_INTERVAL(100, 11, 12, 13, 14, 14, 15)", () => {
    validateIdentity("SELECT MAKE_INTERVAL(100, 11, 12, 13, 14, 14, 15)");
  });
  it.todo("SELECT name, GROUPING_ID() FROM customer GROUP BY ROLLUP (name) (unsupported clause)");
});

describe("Databricks: json", () => {
  it("SELECT c1:price, c1:price.foo, c1:price.bar[1]", () => {
    validateIdentity("SELECT c1:price, c1:price.foo, c1:price.bar[1]");
  });
  it("SELECT TRY_CAST(c1:price AS ARRAY<VARIANT>)", () => {
    validateIdentity("SELECT TRY_CAST(c1:price AS ARRAY<VARIANT>)");
  });
  it('SELECT TRY_CAST(c1:["foo bar"]["baz qux"] AS ARRAY<VARIANT>)', () => {
    validateIdentity('SELECT TRY_CAST(c1:["foo bar"]["baz qux"] AS ARRAY<VARIANT>)');
  });
  it.todo(`SELECT c1:item[1].price FROM VALUES ('{ "item": [ { "model" : "basi... (unsupported syntax)`);
  it.todo(`SELECT c1:item[*].price FROM VALUES ('{ "item": [ { "model" : "basi... (unsupported syntax)`);
  it.todo("SELECT FROM_JSON(c1:item[*].price, 'ARRAY<DOUBLE>')[0] FROM VALUES ... (unsupported syntax)");
  it.todo("SELECT INLINE(FROM_JSON(c1:item[*], 'ARRAY<STRUCT<model STRING, pri... (unsupported syntax)");
  it.todo(`SELECT c1:['price'] FROM VALUES ('{ "price": 5 }') AS T(c1) (unsupported syntax)`);
  it.todo(`SELECT GET_JSON_OBJECT(c1, '$.price') FROM VALUES ('{ "price": 5 }'... (unsupported syntax)`);
  it(`SELECT raw:\`zip code\`, raw:\`fb:testid\`, raw:store['bicycle'], raw:store["zip code"] -> ...`, () => {
    validateIdentity(`SELECT raw:\`zip code\`, raw:\`fb:testid\`, raw:store['bicycle'], raw:store["zip code"]`, 'SELECT raw:["zip code"], raw:["fb:testid"], raw:store.bicycle, raw:store["zip code"]');
  });
  it("databricks -> databricks: SELECT col:`fr'uit`", () => {
    const result = transpile("SELECT col:`fr'uit`", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe(`SELECT col:["fr'uit"]`);
  });
  it.todo("databricks -> postgres: SELECT col:`fr'uit` (unsupported syntax)");
});

describe("Databricks: datediff", () => {
  it.todo("databricks -> tsql: SELECT DATEDIFF(year, 'start', 'end') (cross-dialect transform)");
  it("databricks -> databricks: SELECT DATEDIFF(year, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(year, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(YEAR, 'start', 'end')");
  });
  it("databricks -> databricks: SELECT DATEDIFF(microsecond, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(microsecond, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(MICROSECOND, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(microsecond, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(millisecond, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(millisecond, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(MILLISECOND, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(millisecond, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(second, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(second, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(SECOND, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(second, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(minute, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(minute, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(MINUTE, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(minute, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(hour, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(hour, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(HOUR, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(hour, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(day, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(day, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(DAY, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(day, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(week, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(week, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(WEEK, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(week, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(month, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(month, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(MONTH, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(month, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(quarter, 'start', 'end')", () => {
    const result = transpile("SELECT DATEDIFF(quarter, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(QUARTER, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(quarter, 'start', 'end') (unsupported syntax)");
  it("databricks -> databricks: SELECT DATEDIFF(year, 'start', 'end') (2)", () => {
    const result = transpile("SELECT DATEDIFF(year, 'start', 'end')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(YEAR, 'start', 'end')");
  });
  it.todo("databricks -> postgres: SELECT DATEDIFF(year, 'start', 'end') (unsupported syntax)");
});

describe("Databricks: add_date", () => {
  it.todo("databricks -> tsql: SELECT DATEADD(year, 1, '2020-01-01') (cross-dialect transform)");
  it("databricks -> databricks: SELECT DATEADD(year, 1, '2020-01-01')", () => {
    const result = transpile("SELECT DATEADD(year, 1, '2020-01-01')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEADD(YEAR, 1, '2020-01-01')");
  });
  it("databricks -> databricks: SELECT DATEDIFF('end', 'start')", () => {
    const result = transpile("SELECT DATEDIFF('end', 'start')", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEDIFF(DAY, 'start', 'end')");
  });
  it.todo("databricks -> tsql: SELECT DATE_ADD('2020-01-01', 1) (cross-dialect transform)");
  it("databricks -> databricks: SELECT DATE_ADD('2020-01-01', 1)", () => {
    const result = transpile("SELECT DATE_ADD('2020-01-01', 1)", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("SELECT DATEADD(DAY, 1, '2020-01-01')");
  });
});

describe("Databricks: without_as", () => {
  it.todo("CREATE TABLE x (SELECT 1) (DDL/DML not supported)");
  it("databricks -> databricks: WITH x (select 1) SELECT * FROM x", () => {
    const result = transpile("WITH x (select 1) SELECT * FROM x", { readDialect: DIALECT, writeDialect: "databricks" })[0];
    expect(result).toBe("WITH x AS (SELECT 1) SELECT * FROM x");
  });
});

describe("Databricks: streaming_tables", () => {
  it.todo("CREATE STREAMING TABLE raw_data AS SELECT * FROM STREAM READ_FILES(... (DDL/DML not supported)");
  it.todo("CREATE OR REFRESH STREAMING TABLE csv_data (id INT, ts TIMESTAMP, e... (DDL/DML not supported)");
});

describe("Databricks: grant", () => {
  it.todo("GRANT CREATE ON SCHEMA my_schema TO `alf@melmak.et` (command not supported)");
  it.todo("GRANT SELECT ON TABLE sample_data TO `alf@melmak.et` (command not supported)");
  it.todo("GRANT ALL PRIVILEGES ON TABLE forecasts TO finance (command not supported)");
  it.todo("GRANT SELECT ON TABLE t TO `fab9e00e-ca35-11ec-9d64-0242ac120002` (command not supported)");
});

describe("Databricks: revoke", () => {
  it.todo("REVOKE CREATE ON SCHEMA my_schema FROM `alf@melmak.et` (command not supported)");
  it.todo("REVOKE SELECT ON TABLE sample_data FROM `alf@melmak.et` (command not supported)");
  it.todo("REVOKE ALL PRIVILEGES ON TABLE forecasts FROM finance (command not supported)");
  it.todo("REVOKE SELECT ON TABLE t FROM `fab9e00e-ca35-11ec-9d64-0242ac120002` (command not supported)");
});

describe("Databricks: analyze", () => {
  it.todo("ANALYZE TABLE tbl COMPUTE DELTA STATISTICS NOSCAN (command not supported)");
  it.todo("ANALYZE TABLE tbl COMPUTE DELTA STATISTICS FOR ALL COLUMNS (command not supported)");
  it.todo("ANALYZE TABLE tbl COMPUTE DELTA STATISTICS FOR COLUMNS foo, bar (command not supported)");
  it.todo("ANALYZE TABLE ctlg.db.tbl COMPUTE DELTA STATISTICS NOSCAN (command not supported)");
  it.todo("ANALYZE TABLES COMPUTE STATISTICS NOSCAN (command not supported)");
  it.todo("ANALYZE TABLES FROM db COMPUTE STATISTICS (command not supported)");
  it.todo("ANALYZE TABLES IN db COMPUTE STATISTICS (command not supported)");
  it.todo("ANALYZE TABLE ctlg.db.tbl PARTITION(foo = 'foo', bar = 'bar') COMPU... (command not supported)");
});

describe("Databricks: udf_environment_property", () => {
  it.todo(`CREATE FUNCTION a() ENVIRONMENT (dependencies = '["foo1==1", "foo2=... (DDL/DML not supported)`);
});

describe("Databricks: to_char_is_numeric_transpile_to_cast", () => {
  it.todo("test_to_char_is_numeric_transpile_to_cast: assert statement");
  it.todo("test_to_char_is_numeric_transpile_to_cast: assert statement (2)");
  it.todo("test_to_char_is_numeric_transpile_to_cast: assert statement (3)");
});

describe("Databricks: qdcolon", () => {
  it.todo("SELECT '20'?::INTEGER (unsupported syntax)");
});

describe("Databricks: overlay", () => {
  it.todo("SELECT OVERLAY('Spark SQL', 'ANSI ', 7, 0) (unsupported syntax)");
  it.todo("SELECT OVERLAY('Spark SQL' PLACING 'CORE' FROM 7) (unsupported syntax)");
  it.todo("SELECT OVERLAY(ENCODE('Spark SQL', 'utf-8') PLACING ENCODE('_', 'ut... (unsupported syntax)");
  it.todo("SELECT OVERLAY('Spark SQL' PLACING 'ANSI ' FROM 7 FOR 0) (unsupported syntax)");
});
